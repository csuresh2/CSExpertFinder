
Creating Abstract Superclasses by Refactoring 238 1993
Real-Time Trajectory Generation for Mobile Robots 316 2007
Software engineering
smalltalk design patterns smalltalk design patterns
Real-Time Trajectory Generation for Mobile Robots 316 2007
Real-Time Trajectory Generation for Mobile Robots 316 2007
Real-Time Trajectory Generation for Mobile Robots 316 2007
smalltalk design patterns smalltalk design patterns
Real-Time Trajectory Generation for Mobile Robots 316 2007
Detecting Data Races on Framework-Based Applications 824 2006
smalltalk design patterns smalltalk design patterns
The RTL System: A Framework for Code Optimization 961 1991
Using Aspects to Make Adaptive Object-Models Adaptable 1368 2004
Patterns Generate Architectures 1367 1994
Wrappers to the Rescue 1367 1998
Efficient Multimethods in a Single Dispatch Language 1367 2005
Software engineering
Design Patterns: Abstraction and Reuse of Object-Oriented Design 1367 1993
smalltalk design patterns smalltalk design patterns
Automated Detection of Refactorings in Evolving Components 1367 2006
The Closing of the Frontier 1367 2006
Refactoring Tools 1370 2007
Transaction Support Using Unit of Work Modeling in the Context of MDA 1411 2005
Refactoring-Aware Configuration Management for Object-Oriented Programs 2126 2007
: factoring-aware inary daptation of evolving libraries 2126 2008
: a tool for generating binary adapters for evolving java libraries 2131 2008
Analyzing Multiple Configurations of a C Program 2139 2005
smalltalk design patterns smalltalk design patterns
The Role of Refactorings in API Evolution 2139 2005
On Language Choice for the Introductory Comuter Science Course 2195 1989
Software engineering
An Architecture for Tool Integration 2204 1986
smalltalk design patterns smalltalk design patterns
Refactoring and Aggregation 2539 1993
Refactoring C with Conditional Compilation 2677 2003
Automated upgrading of component-based applications 3106 2006
smalltalk design patterns smalltalk design patterns
MolhadoRef: a refactoring-aware software configuration management tool 3106 2006
A Framework for Run-Time Systems and its Visual Programming Language 3105 1996
Design patterns: beginnings and futures 3106 2006
Beyond the Hype: Do Patterns and Frameworks Reduce Discovery Costs? (Panel) 3105 1997
Reflective Facilities in smalltalk design patterns smalltalk design patterns-80 3105 1989
Software development: arts & crafts or math & science? 3106 2004
A Framework for Network Protocol Software 3105 1995
Type-Checking smalltalk design patterns smalltalk design patterns 3105 1986
Software engineering
Documenting Frameworks using Patterns 3105 1992
How to Get a Paper Accepted at OOPSLA (Panel) 3105 1993
TS: An Optimizing Compiler for smalltalk design patterns smalltalk design patterns 3105 1988
An Interactive Environment for Object-Oriented Music Composition and Sound Synthesis 3105 1988
Object-Oriented Megaprogramming (Panel) 3105 1992
Designing Reusable Designs - Experiences Designing Object-Oriented Frameworks (Panel) 3109 1990
Object-oriented success stories: "learning from our failures" 3106 2003
Towards a pattern language for adaptive object models 3106 2007
The 2nd workshop on refactoring tools (WRT'08) 3106 2008
Symmetry and Similarity in Distributed Systems 3228 1985
Software engineering
A Type System for smalltalk design patterns smalltalk design patterns 3233 1990
Using Re-factoring to Reduce the Pain of Component Evolution 3476 2005
Reuse Research and Development: Is It on the Right Track? 3644 1997
Components, Frameworks, Patterns 3644 1997
Multiparadigm Visual Programming Language 3799 1990
The Adaptive Object-Model Architectural Style 3891 2002
Creating Tools in HotDraw by Composition 4096 1994
Frameworks: A Programmer's View of Developing Reusable Software 4096 1994
Software engineering
A Programmer's View of Developing Reusable Software 4094 1992
Multiple design patterns for voice over IP (VoIP) security 4145 2006
MolhadoRef: a refactoring-aware infrastructure for OO programs 4320 2006
Generating Rewritable Abstract Syntax Trees 4549 2008
Software engineering
Systematically Eradicating Data Injection Attacks Using Security-Oriented Program Transformations 4556 2009
Frameworks = (Components + Patterns) 4620 1997
Software Patterns (Introduction to the Special Section) 4620 1996
Surveying Current Research in Object-Oriented Design 4620 1990
Software engineering
Language support for adaptive object-models using metaclasses 4640 2005
A system to implement primitive data types 4865 1999
Software engineering
Reducing the Latency of a Real-Time Garbage Collector 4952 1992
Software engineering
Using Static Single Assignment Form in a Code Optimizer 4952 1992
HotDraw: a structured drawing editor framework for smalltalk design patterns smalltalk design patterns (abstract) 4987 1993
The heart of object-oriented concurrent programming 5039 1989
Architecture and Design of Adaptive Object Models 5039 2001
How do APIs evolve? A story of refactoring 5044 2006
Guest Editor's Introduction: Why Explore Object Methods, Patterns, and Architectures? 5047 1997
Organizing Security Patterns 5047 2007
Software engineering
Evolution of the MTA architecture: the impact of security 5051 2008
A Refactoring Tool for smalltalk design patterns smalltalk design patterns 5066 1997
Software engineering
Effective Software Merging in the Presence of Object-Oriented Refactorings 5112 2008
-aware software merging and configuration management 5240 2006
Regrowing a language: refactoring tools allow programming languages to evolve 3105 2009
smalltalk design patterns smalltalk design patterns
Relooper: refactoring for loop parallelism in Java 3106 2009
Inferring Method Effect Summaries for Nested Heap Regions 2677 2009
Proceedings of the 20th Annual ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications, OOPSLA 2005, October 16-20, 2005, San Diego, CA, USA 3105 2005
Companion to the 20th Annual ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications, OOPSLA 2005, October 16-20, 2005, San Diego, CA, USA 3106 2005
Software engineering

2009 IEEE/ACM International Conference on Automated Software Engineering
2009 IEEE/ACM International Conference on Automated Software Engineering
2009 IEEE/ACM International Conference on Automated Software Engineering
2009 IEEE/ACM International Conference on Automated Software Engineering
2009 IEEE/ACM International Conference on Automated Software Engineering

Inferring Method Effect Summaries for Nested Heap Regions

Mohsen Vakilian, Danny Dig, Robert Bocchino, Jeffrey Overbey, Vikram Adve, Ralph Johnson
University of Illinois at Urbana-Champaign
Urbana, IL 61801, USA
Email: {mvakili2,dig,bocchino,overbey2,vadve,rjohnson}@illinois.edu

Abstract—Effect systems are important for reasoning about
the side effects of a program. Although effect systems have
been around for decades, they have not been widely adopted
in practice because of the large number of annotations that they
require. A tool that infers effects automatically can make effect
systems practical. We present an effect inference algorithm and
an Eclipse plug-in, DP J IZ ER, which alleviate the burden of
writing effect annotations for a language called Deterministic
Parallel Java (DPJ). The key novel feature of the algorithm
is the ability to infer effects on nested heap regions. Besides
DPJ, we also illustrate how the algorithm can be used for
a different effect system based on object ownership. Our
experience shows that DP J IZ ER is both useful and effective:
(i) inferring effect annotations automatically saves signiﬁcant
programming burden; and (ii) inferred effects are more precise
than those written manually, and are ﬁne-grained enough to
enable the compiler to prove determinism of the program.

I . INTRODUCT ION

Programs written in mainstream imperative languages
have side effects on the memory. Programmers have em-
braced this paradigm because it avoids copying the pro-
gram’s state between different method invocations. However,
this paradigm also makes it harder for programmers or tools
to understand or analyze programs in a modular fashion.
Knowing what parts of the program’s state are mutated
by a method can help programmers modify large programs
without introducing subtle mutation errors and can serve
as explicit, machine-checkable documentation. It can enable
safety tools to detect inconsistencies between intended usage
of API methods and their actual usage, it is a building
block for several other compiler analyses (e.g., MODREF
analysis), and it can enable compilers to check the safety of
parallel programs [1]–[3].
Effect systems express the effects of methods in terms of
reads and writes of a subsets of the heap. Such groups of
memory locations are referred to as “regions.” Modern effect
systems such as DPJ [4], [5] and JOE [6] express effects in
terms of nested heap regions. Nested heap regions specify
logical inclusion of regions, which is useful for recursion,
subtyping, etc.
Effect annotations describing the side effects of each
method can enable modular analysis of effects. But, although
these annotations have been around for decades, they have
not been used much in practice. The reason is that manually
writing such effects is tedious and error-prone. In this paper,

we present an algorithm that automatically infers the effects
of each program statement, and summarizes them at the
level of method declarations as method effect summaries.
There is prior work on inferring effects on ﬂat regions [7]–
[9], however, the key novelty of our algorithm is its ability
to infer effects for programs even on nested heap regions,
including recursive as well as non-recursive data structures.
Deterministic Parallel Java (DPJ) [4], [5] is an explicitly
parallel language that aims to enable programmers to write
safe parallel programs. DPJ is an extension to Java with an
effect system based on regions. DPJ gives static guarantees
that a program that
type-checks with the DPJ compiler
is safe,
the program’s behavior is deterministic. A
i.e.,
deterministic program produces identical externally visible
results in all executions for a given input.
The heart of DPJ is a type system that checks whether the
parallel constructs access the shared data without conﬂicts.
The programmer (i) speciﬁes the shared data by virtually
partitioning the heap into regions and (ii) speciﬁes which
regions are read or written by each method.
Using DPJ, we have safely parallelized several pro-
grams [5]; the parallel programs are deterministic and they
exhibit good speedup. However, to get these beneﬁts the pro-
grammer has to write region and effect annotations by hand.
This job is nontrivial, error-prone, and time consuming. For
example, a Monte Carlo ﬁnancial application contains 1502
LOC and 314 annotations. A Barnes-Hut N-body application
contains 698 LOC and 148 annotations.
This paper presents our tool, DP J IZ ER, which alleviates
the programmer’s burden when writing effect annotations.
Given a program with region annotations, DP J IZ ER infers
the method effect summaries and annotates the program.
When summarizing the effect information, DP J IZ ER elimi-
nates redundant effects, which makes the effect annotations
concise and easier to understand. We implemented DP J IZ ER
as an extension to Eclipse’s refactoring engine,
thus it
offers all the convenient features of a practical refactoring
engine: previewing changes, selection of edits to be applied,
undo/redo, etc.
The inference algorithm at
the heart of DP J IZ ER is
built on a classical constraint-based type-inference approach,
but we use it
to infer effects. The algorithm generates
constraints from primitive operations (variable access, as-
signment, method calls, and method overriding declarations),

1527-1366/09 $29.00 © 2009 IEEE
1527-1366/09 $29.00 © 2009 IEEE
1527-1366/09 $29.00 © 2009 IEEE
1527-1366/09 $29.00 © 2009 IEEE
1527-1366/09 $29.00 © 2009 IEEE
DOI 10.1109/ASE.2009.68
DOI 10.1109/ASE.2009.68
DOI 10.1109/ASE.2009.68
DOI 10.1109/ASE.2009.68
DOI 10.1109/ASE.2009.68

409
423
423
421
421

using the appropriate parameter and type substitutions at
method invocations. It
then solves these constraints by
processing them iteratively and propagating the constraints
through the call graph until a ﬁxed point is reached and
no more constraints are discovered. The novelty in the
algorithm lies in the constraint solving phase. This phase
handles nested regions by taking advantage of the structure
of region speciﬁcations in the target language (e.g., Region
Path Lists [5] in DPJ or object “levels” in the object
ownership system, JOE [6]). It handles recursive structures
by summarizing these nested heap regions in each case.
Although DP J IZ ER is designed to help in porting a Java
program to DPJ, its applicability goes well beyond DPJ.
Given a concurrent program that uses shared memory, by
inferring the method effects, DP J IZ ER helps a programmer
discover the patterns of shared data. This information is
crucial in helping the programmer ﬁnd out the accesses
to shared data that need to be protected. Moreover, the
underlying algorithm is useful beyond concurrent programs.
For example, we show how the algorithm can be used
to infer effects for a different effect speciﬁcation system
based on object ownership, which is a general mechanism to
reason about and express the side effects of object-oriented
programs.
This paper makes the following contributions:
1. Algorithm. To the best of our knowledge, this paper
presents the ﬁrst algorithm for inferring method effect sum-
maries for a full Object-Oriented language (e.g., aliasing,
recursion, polymorphism, generics, arrays, etc.) with a so-
phisticated effect system (e.g., parameterized regions, nested
regions for recursive data-structures, etc.).
2. Tool. We implemented the effect inference algorithm
in an interactive tool called DP J IZ ER. A programmer can
use DP J IZ ER to infer method effects for a Java or a DPJ
program. DP J IZ ER writes the inferred effects into the source
code as DPJ annotations or as code comments. DP J IZ ER is
built as an Eclipse plugin that extends Eclipse’s refactoring
engine.
3. Evaluation. We used DP J IZ ER to infer method effects
in several real programs. We compare the effects inferred
with DP J IZ ER against effects manually inferred by program-
mers. The comparison shows that DP J IZ ER can drastically
reduce the burden of writing annotations manually, while the
automatically inferred effects are more precise.

I I . OVERV IEW O F DP J

Deterministic Parallel Java (DPJ) [5] is a programming
language that ensures parallel tasks are noninterfering. Two
tasks are noninterfering if for each pair of memory accesses,
one from each task, either both accesses are reads, or the
two accesses operate on disjoint sets of memory locations.1

1 The full DPJ language [5], [10] also allows commutativity annotations
that specify noninterference directly, without checking reads and writes.
Here we focus on inferring read and write effects.

Noninterfering tasks can run in parallel while still exhibiting
the same behavior as if they were run sequentially.
DPJ provides a type system that guarantees noninterfer-
ence of parallel tasks for a well-typed program. In DPJ,
the programmer assigns every object ﬁeld and array cell
to a region of memory and annotates each method with a
summary (called a method effect summary) of the method
read and write effects. The programmer also marks which
code sections to run in parallel, using several standard con-
structs, such as cobegin for parallel statement execution
and foreach for parallel loops. The compiler uses the
region annotations and method effect summaries to check
that all pairs of parallel tasks are noninterfering.

A. Region Names

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

class Node {
region Mass, Force;
double mass in Mass;
double force in Force;
void setMass(double mass) writes Mass {
/* writes Mass */
this.mass = mass;

}
void setForce(double force) writes Force {
/* writes Force */
this.force = force;

}
void initialize(double mass, double force)
writes Mass, Force {
cobegin {
/* writes Mass */
this.setMass(mass);
/* writes Force */
this.setForce(force);

}

}

}

Figure 1. Using ﬁeld region names to distinguish writes to different object
ﬁelds. In Section III, we will show how to infer the underlined method effect
summaries.

Figure 1 illustrates the use of region names to distinguish
writes to different ﬁelds of an object. Line 2 declares
Mass and Force as region names that are available within
the scope of class Node. These are called ﬁeld region
declarations. Lines 3 and 4 declare ﬁelds mass and force
and place them in regions Mass and Force, respectively.
Field region declarations are static, so there is one for each
class. For example, all mass ﬁelds of all Node instances
are in the same region, Mass.
Each method must have a method effect summary record-
ing the effects that it performs on the heap, in terms of reads
and writes to regions. For example, method setMass (line
5) has the summary writes Mass, because the effect of
line 7 is to write the ﬁeld mass, located in region Mass;
and similarly for setForce (line 9). It
is permissible
for a method effect summary to be overly conservative;
for example, setMass could have said writes Mass,
Force. However, this may inhibit parallelism. It is an error
for a method effect summary to be not conservative enough,

410424424422422

for example if setMass had said pure, meaning “no
effect.”
Together,
the DPJ annotations allow the compiler to
efﬁciently analyze noninterference of parallel code sec-
tions, as illustrated in the initialize method. From
the method effect summaries, the compiler can infer that
the effect of line 17 is writes Mass and the effect of
line 19 is writes Force. The compiler can then use
the distinctness of the names Mass and Force to prove
noninterference: although both statements in the cobegin
perform writes, the writes are to disjoint regions of the heap.

B. Region Parameters

As shown in section II-A, region names are useful for
distinguishing parts of an object from each other. Often,
however, we need to distinguish different object instances
from each other. To do this, DPJ uses region parameters,
which operate similarly to Java generic parameters [11] and
allow us to instantiate different object instances of the same
class with different regions.

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

class Node<region P> {
region L, R;
double mass in P;
Node<L> left in L;
Node<R> right in R;
void setMass(double mass) writes P {
/* writes P */
this.mass = mass;

}
void setMassOfChildren(double mass)
writes L, R {
cobegin {
/* writes L */
if (left != null) left.setMass(mass);
/* writes R */
if (right != null) right.setMass(mass);

}

}

}

Figure 2. Using region parameters to distinguish writes to different object
instances.

Figure 2 illustrates the use of region parameters to dis-
tinguish writes to different object instances. In line 1, we
declare class Node to have one region parameter P (we use
the keyword region to distinguish DPJ region parameters
from Java type parameters). As with Java generics, when
we write a type using a class with region parameters, we
provide an argument to the parameter, as shown in lines 4
and 5. The argument must be a valid region name in scope.
We can use the region name P within the scope of the
class. For example, line 3 declares ﬁeld mass in region P.
When this.mass is accessed, the effect is on region P,
as shown in line 7. However, when we access ﬁeld mass
through a selector other than this, we resolve the region
P by substituting the actual argument given in the type of
the selector. For example, the effect of left.setMass
in line 14 is writes L. We get this by looking at the

declaration writes P of setMass and substituting L for
P from the type of left. (The read of ﬁeld left also
generates a read effect on region L; but in DPJ, write effects
imply read effects, so the read is covered by writes L.)
We can then use an analysis similar to the one discussed
in Section II-A to prove that the statements in lines 14 and
16 are noninterfering, since their write effects are on the
disjoint regions L and R.

C. Region Path Lists (RPLs)

In conjunction with array index regions and index-
parameterized arrays (discussed further in Section III-E1),
basic region names and region parameters can be used to
express important parallel algorithms. However, it is often
essential to be able to express a nesting relationship between
regions. For example, to express tree-like recursive updates
we need a nested hierarchy of regions. DPJ provides two
ways to express nesting: region path lists and owner regions.
Here we focus on region path lists; we defer the discussion
of owner regions until after we have presented the effect
inference algorithm.
A region path list (RPL) extends the idea of a simple
region name introduced in Section II-A. An RPL is a colon-
separated list of names that expresses the nesting relationship
syntactically: if P and R are names, then P:R is nested under
P. Nested RPLs are particularly useful in conjunction with
region parameters: if we append names to parameters, such
as P:L and P:R, then by left-recursive substitution we can
generate arbitrarily long chains of names, such as P:L:L:R.

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

class Node<region P> {
region L, R;
double mass in P;
Node<P:L> left in P:L;
Node<P:R> right in P:R;
void setMassForTree(double mass) writes P:* {
/* writes P */
this.mass = mass;
cobegin {
/* writes P:L:* */
if (left != null)
left.setMassForTree(mass);
/* writes P:R:* */
if (right !=null)
right.setMassForTree(mass);

}

}

}

Figure 3. Using RPLs and region parameters to recursively update a tree
in parallel.

Figure 3 illustrates the use of this technique to write a
recursive tree update. The example is similar to the one
shown in Figure 2, except that lines 4 and 5 use regions P:L
and P:R instead of L and R, and the method invocations in
lines 12 and 15 are recursive. To write the method effect
summary in line 6, we need some new syntax: because the
tree can be arbitrarily deep, and the RPLs arbitrarily long, we
use a star (*) to stand in for any sequence of RPL elements.

411425425423423

Then we can write the method effect summary writes
P:*, as shown in line 6. Note that the rules discussed in
Section II-A for method effect summaries are still followed:
by substituting the RPL arguments in the types of left and
right in for P, we get the inferred effects shown in lines
10 and 13; and those effects are covered by the summary.
Further, because the RPLs form a tree, we can conclude that
all regions under P:L and all regions under P:R are disjoint,
so effects of lines 12 and 15 are noninterfering.

(FIELD-ACCESS)

(this, C ) ∈ Γ ﬁeld(C, f ) = T f in r
Γ ⊢ this.f : T , {reads r}

(ASSIGN)

(this, C ) ∈ Γ Γ ⊢ e : T , K ﬁeld(C, f ) = T ′ f in r
Γ ⊢ this.f = e : T , K ∪ {writes r}

(INVOKE)

Γ ⊢ e1 : C, K1 Γ ⊢ e2 : T , K2 method(C, m) = µ
µ = Tr m(Tx x) { e }
Γ ⊢ e1 .m(e2 ) : Tr , K1 ∪ K2 ∪ {invokes µ}

(NEW)

·
new C : C, ∅

(VARIABLE)

(z , T ) ∈ Γ
z : T , ∅

I I I . E FF ECT IN F ERENCE A LGOR ITHM

Figure 5. Rules for computing the constraints generated by an expression.

We present our algorithm using Core DPJ [5], a small
skeleton language that illustrates the ideas yet is tractable
to formalize. To make the presentation easier to follow, we
start with a simpliﬁed form of Core DPJ corresponding to
the features introduced in Section II-A, i.e., basic region
names with no region parameters or nesting. Then we build
up the language to add region parameters, region path lists
and owner regions. We also discuss how to handle array
regions and inheritance. Finally, we discuss how to adapt
the algorithm for use with other languages.

A. Basic region names

Figure 4 shows the syntax of the initial language. Note
that we have moved ﬁeld region declarations to the global
scope to simplify the region names in the formal language.
The algorithm consists of two phases, constraint generation
and constraint solving.

Meaning
Programs
Region decls
Classes
Fields
Types
Methods
Expressions
Variables

Symbol
program
region-decl
class
ﬁeld
T
µ
e
z

Deﬁnition
region-decl∗ class∗
region r
class C {ﬁeld∗ µ∗ }
T f in r
C
T m(T x) { e }
this.f | this.f = e | e.m(e) | new T | z
this | x

Figure 4. Syntax of Core DPJ with basic region names. C , f , m, x and
r are identiﬁers.

1) Constraint Generation: The constraint generation
phase computes for each method µ a constraint set Kµ ,
where each element of Kµ is one of the constraints reads r,
writes r, and invokes µ′ . The ﬁrst two constraints indicate
the presence of a read or write effect in the method itself.
The invokes constraint asserts that one method is invoking
another, either directly or indirectly; these constraints will
cause the solving phase (Section III-A2) to account for the
read and write effects of callees.
The constraint generation phase visits each method body
and walks the AST to generate a set of constraints. Figure 5
shows the constraint generation rules for the simpliﬁed
language. The rules are similar to the ones for typing DPJ
expressions [5], except that we do not check assignments
or method formal parameter bindings for soundness (we

assume that full DPJ type checking has been done as a
separate pass).
The judgment Γ ⊢ e : T , K means that expression e has
type T and generates constraint set K in environment Γ.
The environment Γ is a set of pairs (z , T ) binding variable
z to type T . The term method(C, m) means the method
named m deﬁned in class C , while ﬁeld(C, f ) means the
ﬁeld named f deﬁned in class C . For each method µ =
Tr m(Tx x) { e } , let Cµ be the class where µ is deﬁned.
Then Kµ is just the set of constraints such that

{(this, Cµ ), (x, Tx )} ⊢ e : T , Kµ .

As an example, we show how to generate the constraints
for the bodies of methods setMass, setForce and
initialize in Figure 1. In line 7, rule ASSIGN generates
the constraint writes Mass for assignment to the ﬁeld in
region Mass. Similarly, rule ASSIGN generates the constraint
writes Force for method setForce. In method ini-
tialize, there are two method invocations (lines 17 and
19). Therefore, rule INVOKE generates two constraints invokes
setMass and invokes setForce.
2) Constraint Solving: The constraint solving phase com-
putes for each method µ an effect set Eµ , where each
element of Eµ is one of the effects reads r or writes r.
This phase comprises the following steps:
1) For each method µ, for each constraint invokes µ′ in
Kµ , add the elements of Kµ′ to Kµ .
2) Repeat step 1 until no more constraints are added to
any Kµ .
Step 1 prunes the constraint sets Kµ by never adding
redundant constraints. For example, since writes cover reads,
there is no need for any Kµ to contain both reads r and
writes r; the second constraint sufﬁces.
The algorithm terminates, because the total number of
regions is bounded, so the total number of constraints that
can be added to the Kµ is bounded. At the end of this
process, for each µ we let Eµ = effects(Kµ ), where
the function effects extracts the read and write constraints
(i.e., the effects) from Kµ . As an example, from Figure 1,
the constraints invokes setMass and invokes setForce
generate the effects writes Mass and writes Force.

412426426424424

B. Region Parameters

This section extends Core DPJ by adding region param-
eters. CoreDPJ allows only one region parameter to each
class in order to simplify the formal rules. Also, CoreDPJ
disallows type parameters, as they are irrelevant to our effect
inference algorithm. Figure 6 shows the new syntax.

Meaning
Classes
Regions
Types

Deﬁnition
Symbol
class C hP i {ﬁeld∗ µ∗ }
class
R r | P
C hRi
T

New syntax of Core DPJ with region parameters. P is an
Figure 6.
identiﬁer. Other syntactic elements are the same as in Figure 4.

1) Constraint Generation: Figure 7 shows the rules for
generating reads, writes, and invokes constraints in Core DPJ
with region parameters. The new rule INVOKE records the
region substitution θ = {P 7→ R} that the constraint solver
will need when translating the effects of one method to
another. The term param(C ) represents the region parameter
P of class C .

(FIELD-ACCESS)

(this, C hP i) ∈ Γ ﬁeld(C, f ) = T f in R
Γ ⊢ this.f : T , {reads R}

(ASSIGN)

(this, C hP i) ∈ Γ Γ ⊢ e : T , K ﬁeld(C, f ) = T ′ f in R
Γ ⊢ this.f = e : T , K ∪ {writes R}

(INVOKE)

Γ ⊢ e1 : C hRi, K1 Γ ⊢ e2 : T , K2 method(C, m) = µ
µ = Tr m(Tx x) { e }
θ = {param(C ) 7→ R}
Γ ⊢ e1 .m(e2 ) : θ(Tr ),K1 ∪ K2 ∪ {invokes µ where θ }

(NEW)

·
new C hRi : C hRi, ∅

(VARIABLE)

(z , T ) ∈ Γ
z : T , ∅

Figure 7.
parameters.

Rules for generating constraints in Core DPJ with region

Here we apply the substitution θ elementwise to sets Kµ ,
and we apply θ to constraints as follows:

θ(reads R) = reads θ(R)

θ(writes R) = writes θ(R)
θ(invokes µ where θ ′ ) = invokes µ where θ(θ ′ )
θ({P 7→ R}) = {P 7→ θ(R)}

The number of region parameters is ﬁnite, so the number
of region substitutions is ﬁnite. Therefore, there are a ﬁnite
number of invokes constaints. Thus, the algorithm terminates
for the same reason given in Section III-A2.
Figure 8 illustrates the constraints and effects inferred by
each iteration of the algorithm on the method setMas-
sOfChildren in Figure 2. For brevity, we show only
the effects coming from left.setMass(). Just before
iteration 1, the effect of method setMass is summarized as
writes P. In iteration 1, the invokes effect leads the algorithm
to infer the effect writes L by applying the substitutions
P 7→ L on the effect of setMass. The algorithm does not
infer any new effects in iteration 2, so it terminates after
iteration 2.

Effects
Constraints

Before Iteration 1
reads L
invokes setMass where {P 7→ L}

Iteration 1
writes L

Figure 8. Effects and constraints inferred in each iteration of the algorithm
for method setMassOfChildren in Figure 2

C. Region Path Lists (RPLs)

This section adds RPLs to Core DPJ. Only the syntax for
regions, shown in Figure 9, is new. Root is a special name
representing the root of the region tree.

Meaning
Regions

Symbol
Deﬁnition
R Root | r | P | R : r | R : ∗

As an example, we show how to generate the con-
straints for the code in Figure 2. According to rule AS-
SIGN,
line 8 generates the constraint writes P. In line
14, Rule FIELD -ACCESS generates the constraint reads L
for accessing the ﬁeld left. Then, because the type of
this.left is Node<L>, rule INVOKE generates the con-
set {reads L, invokes setMass where {P 7→ L}}.
straint
Line 16 generates similar constraints, using region R instead
of L.

2) Constraint Solving: The constraint solving phase is
identical to the one described in Section III-A2, except that
the algorithm applies substitutions θ in resolving invokes
constraints:

1) For each method µ, for each constraint (invokes µ′
where θ) in Kµ , add the elements of θ(Kµ′ ) to Kµ .
2) Repeat step 1 until no more constraints are added to
any Kµ .

Figure 9.
Figure 6.

Syntax of RPLs. Other syntactic elements are the same as in

Constraint generation is the same as explained in Sec-
tion III-B1. However, we need to extend the solving phase
to handle recursion that would not terminate if we naively
applied the algorithm from Section III-B2. For example, that
algorithm would not terminate on the code in Figure 3,
because it would try to infer effects on inﬁnite chains of
RPL elements, such as P : L : R : · · · . In such a case,
we want to cut off the recursion and summarize the inﬁnite
set of RPLs with a partially speciﬁed RPL ending in ∗, as
described in Section II-C.
1) Algorithm Description: We say that an invokes con-
straint (invokes µ where θ) ∈ Kµ′ is recursive if and only
if µ = µ′ , i.e., the method includes its own effects, through
a chain of one or more invocations. We deﬁne an expanding
substitution to be a substitution such as P 7→ R, where P

413427427425425

is the ﬁrst RPL element of R, and R has more than one
element. For example, P 7→ P : R is expanding but P 7→ P
and P 7→ P ′ : R are not.
RPLs can become arbitrarily long when going under
multiple region substitutions. We bound the length of RPLs
to get readable effects and guarantee the termination of the
algorithm. Usually, developers write RPLs of length at most
three.
Figure 10 shows the modiﬁed constraint solving algo-
rithm. In lines 1–6, the algorithm normalizes the invokes
constraints of all methods. This normalization step truncates
all long RPLs and appends a star to them. It also detects
expanding substitutions in recursive invokes constraints and
appends a star to the RPLs in such substitutions.
The truncate function makes sure that no RPL longer than
a predeﬁned length gets created. If it gets a long RPL, it
cuts it off to ﬁt within the limit and appends a star, e.g.
P : R : S : T becomes P : R : ∗ to have a length of
three. It is necessary to make sure that the truncated RPL
ends with a star so that it covers the original long RPL.
The summarize function makes sure that each expanding
substitution in the given recursive invokes constraint ends
with a star. For example, summarize returns the substitution
P 7→ P : R : ∗ given the expanding substitution P 7→ P : R.
The algorithm iterates until all the effect and constraint
sets stabilize. As before, each iteration of the main loop
iterates over the method set M and adds effects implied
by the invokes constraints of Kµ . After adding the effects
of the callee in line 10, the algorithm iterates over the
invokes constraints of the callee, applies the substitution of
the callee on the region substitution of the invokes constraint,
and truncates the resulting region substitution to make sure
that no long RPL occurs. If the truncated substitution is
recursive and expanding, then the algorithm summarizes it
before adding it back to Kµ .
As before, all unions are up to redundant constraints and
effects. For instance, once writes R : ∗ appears in Kµ , the
algorithm never again adds reads R or writes R to Kµ in line
10. Similarly, once invokes µ with P 7→ P : R : ∗ appears in
Kµ , the algorithm never adds invokes µ with P 7→ P : R : R
in lines 13 and 15. This pruning ensures that the algorithm
terminates (Section III-C3).
2) Example: Figure 11 illustrates the constraints and
effects inferred by each iteration of the repeat loop in
lines 7–16 of Figure 10 for the method setMassForTree
in Figure 3. Before starting iteration 1, the constraints and
effects are those computed up to line 7 of Figure 10. In this
example, we let the cut-off limit for the truncate function
be three. As a result, before iteration 1, the normalization
step of the algorithm (Section III-C1), appends stars to the
invokes constraints. In iteration 1, the algorithm detects two
recursive invokes constraints with expanding substitutions.
Then,
it applies the substitutions of these two invokes
constraints on the effects discovered before iteration 1. This

input : Program P with region annotations
Set M of methods
Set Kµ of constraints for each method µ
output: A set of effects, Eµ , for each method µ
foreach µ ∈ M do
foreach c = (invokes µ′ where θ) ∈ Kµ do
if µ′ = µ and isExpanding(θ) then
c ← (invokes µ′ where summarize(truncate(θ)))

else

c ← (invokes µ′ where (truncate(θ)))

repeat
foreach µ ∈ M do
foreach c = (invokes µ′ where θ) ∈ Kµ do
Kµ ← Kµ ∪ truncate(effects(Kµ
′ ))
′ = (invokes µ′′ where θ ′ ) ∈ Kµ
foreach c
′ do
if µ′′ = µ and isExpanding(θ(θ ′ )) then
Kµ ← Kµ ∪ (invokes µ′′ where
summarize(truncate(θ(θ ′ ))))

else

until no Kµ changes
foreach µ ∈ M do
Eµ = effects(Kµ )

Kµ ← Kµ ∪ (invokes µ′′ where truncate(θ(θ ′ )))

Figure 10. The inference algorithm for RPLs.

1
2
3
4
5
6
7
8
9
10
11
12
13

14
15
16
17
18

Effects

Constraints

Before Iteration 1
reads P:L, P:R writes P

invokes
where
setMassForTree()
{P 7→ P:L:*}, setMassForTree()
where {P 7→ P:R:*}

Iteration 1
writes
P:L:*, P:R:*

Figure 11. Effects and constraints inferred in each iteration of Figure 10
for the method setMassForTree in Figure 3.

application discovers the two new effects of iteration 1. The
algorithm terminates after iteration 2 because it does not ﬁnd
any new effects in iteration 2.
Note that even though the effect summary writes P:*
shown in Figure 3 is correct (i.e., it type-checks), DP J IZ ER
infers a more precise (i.e., a more reﬁned) summary. For
this program, DP J IZ ER infers writes P, P:L:*, P:R:*.
The effect writes P comes from the write access in line 8,
while writes P:L:* comes from the recursive function in
line 12. DP J IZ ER recognizes the recursive traversal of the
data structure, and partially speciﬁes the affected regions as
P:L:*. The effect writes P:R:* comes from the recursive
function in line 15.
3) Termination and Algorithmic Complexity: There are
only a ﬁnite number of RPLs of a certain maximum length.
So, the total number of effects and constraints that can be
added to each set Kµ is ﬁnite. Because all Kµ sets are ﬁnite,
the algorithm terminates.
We analyze the running time of our algorithm in terms of
two parameters m and n and a constant c. The parameter m
is the maximum number of method invocations in a method
body, n is the number of possible RPL elements, and the
constant c is the maximum length of RPLs.
Because the length of RPLs is bounded by c, the total
number of possible RPLs is O(nc ). Therefore, the number
of reads and writes effects of a method is O(nc ).
Each method makes at most m invocations and each

414428428426426

invokes constraint has at most n region substitutions of a
length of at most nc . Therefore, the number of invokes
constraints of a method is O(mnc+1 ). In other words,
∀µ |Kµ | = O(mnc+1 ).
Assuming that the running time set union operation is
linear in the size of its operands, the running of the algorithm
is a polynomial in terms of m and n.

D. Owner Regions

DPJ provides a mechanism called owner regions for
recursively partitioning a ﬂat data structure (such as an
array) in a divide-and-conquer manner. Figure 12 illustrates
how to use owner regions to write parallel quicksort. The
class DPJArray wraps an ordinary Java array and can
be used to partition the array into subranges, and class
DPJPartition is used to split the DPJArray into left
and right segments segs.left and segs.right, as
shown in lines 7 and 8.
The class DPJPartition dynamically partitions an
array into two subarrays which are nested under the this
region. Therefore, QSort.sort creates a binary tree of
QSort objects, with each in its own region. The compiler
veriﬁes the noninterference of effects because the object
references to DPJPartition are distinct and the subarrays
are in disjoint regions nested under the object references.
In lines 11 and 12,
the
type of segs.left
is segs:DPJPartition.Left, where DPJParti-
tion.Left is a ﬁeld region name (Section II-A) and the
final local variable segs functions as an RPL. When
a variable appears as an RPL, the region it represents is
associated with the object reference stored in the variable
at runtime, as in ownership type systems [6], [12]. The
region of the variable is nested under the region bound to
the ﬁrst parameter of the variable’s type. Here, segs has
type DPJPartition<P>, so segs is nested under P. This
fact allows us to write the method effect summary writes
P:* covering both the write to P in line 6 and the recursive
invocations of sort in lines 12 and 15. Given this effect
summary, the compiler can use the inferred effects shown in
lines 10 and 13 to prove that the statements in the cobegin
block are noninterfering.
Figure 13 shows the syntax of Core DPJ extended to
support owner regions. Note that we have changed the
syntax of expressions in the following ways: (1) we add
a let construct to simulate final local variables; and (2)
we require the selector and actual argument of a method
invocation expression to be variables to keep the typing rules
simple.
Constraint generation works exactly as described in Sec-
tion III-B1 except for rules LET and INVOKE, shown in
Figure 14. In rule LET, we have to account for the fact that
RPLs generated inside the let expression may contain a
local variable z that is not in scope outside the body of
the expression. Therefore, we coarsen any such RPL z : R

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

class QSort<region P> {
final DPJArray<P> A in P;
QSort(DPJArray<R> A) pure { this.A = A; }
void sort() writes P:* {
/* Quicksort partition: writes P */
int p = qsPartition(A);
final DPJPartition<P> segs =
new DPJPartition<P>(A, p);
cobegin {
/* writes segs:DPJPartition.Left:* */
new QSort<segs:DPJPartition.Left>
(segs.left).sort();
/* writes segs:DPJPartition.Right:* */
new QSort<segs:DPJPartition.Right>
(segs.right).sort();

}

}

}

class DPJPartition<region P> {
region Left, Right;
DPJArray<this:Left> left in this:Left;
DPJArray<this:Right> right in this:Right;

DPJPartition(DPJArray<P> A, int pivot) {
left = (DPJArray<this:Left>)
A.subarray(0, pivot);
right = (DPJArray<this:Right>)
A.subarray(pivot, A.length - pivot);

}

}

Figure 12. Using owner regions to write quicksort.

Meaning
Regions
Expressions

Symbol
R
e

Deﬁnition
Root | r | P | z | R : r | R : ∗
let z = e in e | this.f | this.f = e |
z .m(z) | new C hRi | z

Figure 13. Core DPJ with owner regions.

to R′
: ∗, where the type of z is C hR′ i. Rule INVOKE
is nearly identical to the one shown in Figure 7, except
that we record the substitutions this 7→ z1 and x 7→ z2
as well as the substitution param(C ) 7→ R. With these
changes, the solving algorithm works exactly as described
in Section III-C1.

(LET)

Γ ⊢ e1 : C hRi, K1 Γ ∪ {(x, T1 )} ⊢ e2 : T2 , K2
θ = {x 7→ R : ∗}
Γ ⊢ let x = e1 in e2 : θ(T2 ), θ(K1 ∪ K2 )

(INVOKE)

{(z1 , C hRi), (z2 , T )} ⊆ Γ method(C, m) = µ
µ = Tr m(Tx x) { e′ }
θ = {param(C ) 7→ R, this 7→ z1 , x 7→ z2 }
Γ ⊢ z1 .m(z2 ) : θ(Tr ),K ∪ {invokes µ where θ }

Figure 14.
regions.

Rules for generating constraints in Core DPJ with owner

E. Other DPJ Features

We now show how we extended the algorithm described
in Section III-C to handle the key remaining features of DPJ:
arrays and inheritance.
1) Arrays: DPJ provides two capabilities for computing
with arrays: array RPL elements and index-parameterized

415429429427427

arrays. An array RPL element is [e], where e is an integer
expression. Since array regions are just RPL elements (e.g.,
Root:[e]:r), the algorithm can handle them in exactly
the same way as described for name RPL elements. We just
need a constraint collection rule that says that if expression
e uses a method-local variable that is out of scope at the
point of the method prototype, then we replace the element
[e] in any RPL with [?], representing an unknown array
index element in the DPJ type system.
An index-parameterized array allows the programmer to
use an array index expression in the type of an indexed
element. For example,
the programmer can specify that
the type of array index expression A[e] is C<[e]>. To
handle index-parameterized arrays, we just add constraint
generation rules for assignment and access through array
index expressions that are nearly identical to the rules for
ﬁeld assignment and access shown in Figure 7. The rules
are also similar to the rules for array access typing shown
in [5].
2) Inheritance: DPJ supports inheritance, e.g., class
B hP i extends AhRi. Inheritance raises two issues for the
inference algorithm. First, we must translate inherited meth-
ods and ﬁelds from the superclass to the subclass. We do
this by applying the translating substitution θ implied by
the chain of extends clauses from the superclass to the
subclass. For example, if class C1 hP1 i extends C2 hR1 i, and
C2 hP2 i extends Object, then the translating substitution
from C2 to C1 is {P2 7→ R1}.
Second, DPJ requires that the declared effects of a method
include the effects of all overriding methods [5]. This gives
rise to a constraint similar to the one we represented by an
invokes constraint, except that it is simpler, because there
is no recursion in the inheritance graph. To handle this
constraint, we make two simple extensions to the algorithm.
First,
in the constraint collection phase, after collecting
constraints from each method body, we add to each Kµ the
constraint isOverriddenBy µ′ where θ, for each method µ′
such that µ is overridden by µ′ . Here, θ is the translating
substitution deﬁned above. Second, in the constraint solving
phase, in each iteration of the repeat loop in Figure 10,
between lines 7 and 16, we add another iteration over all
methods µ ∈ M to add θ(Kµ′ ) to Kµ for each constraint
isOverriddenBy µ′ where θ in Kµ .

F. Applicability Beyond DPJ

The relevance of our effect inference algorithm is not
limited to DPJ: with suitable modiﬁcations, the algorithm
can be adapted to infer effects for other object-oriented effect
systems, such as ownership-based systems [6], [13], [14],
that have features similar to DPJ’s. Here, we illustrate how
the inference algorithm might be adapted to work on the
ownership-based effect system by Clarke and Drossopoulou
called Java with Ownership and Effects, or JOE [6].

JOE also employs method effect summaries and supports
effects on regions similar to DPJ’s owner regions, except
that JOE has no RPLs. Instead, JOE uses effect shapes of the
form p.n and under p.n, where p is a final local variable
or context parameter (similar to a DPJ region parameter),
and n ≥ 0 is a natural number. The shape p.n refers to all
descendants of p in the region tree that are n levels below
p in the tree, with p.0 being equivalent to p. The shape
under p.n is similar to an RPL with ∗ at the end and refers
to all p.n′ such that n′ ≥ n. The key rule of JOE, which
deﬁnes the region tree, is that if variable z has type C hoi,
then the shape z .n is covered by the shape o.n + 1, where
o = owner(z ) is the region bound to the owner parameter
in the type of z .
To adapt our algorithm to JOE, we make the following
modiﬁcations. First, instead of substitutions P 7→ R, we
use substitutions p.n 7→ p′ .n + k , for k ≥ 0. Second, in
rule LET (Figure 14), when a variable z goes out of scope,
we generate an effect for the outer scope by applying the
substitution z .n 7→ o.n + 1, where o = owner(z ). (We could
also replace z .n with under o, as our LET rule does for
DPJ, but replacing z .n with o.n + 1 is more precise.) Third,
we deﬁne an expanding substitution to be p.n 7→ p.n + k ,
for k > 0, and when we see an expanding substitution, we
replace its right-hand side with under p.n + k . Otherwise,
the algorithm works as described in the previous sections.

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

class List<o> {
int data;
List<this> next;
void update(int data)
writes this, under this+1 {
/* writes this */
this.data = data;
/* invokes update where
{this.n 7→ this.n+1} */
let z = next in
/* invokes update where
{this.n 7→ z.n+0} */
if (z != null) z.update(data);

}

}

Figure 15. Example of inferring effects for JOE.

Figure 15 shows how the algorithm infers effects for a
simple recursive JOE program. This code traverses and up-
dates a list such that each node of the list owns the next node.
The initial constraints gathered in the constraint collecting
phase are shown in the comments. Rule INVOKE generates
the effect in lines 11–12, which is adjusted to the effect
in lines 8–9 by the LET rule discussed above. At the end
of initial constraint collection, the constraints are as shown
in lines 8–9 and 11–12. In the ﬁrst iteration of the solving
algorithm, the expanding substitution shown in lines 8–9 gets
summarized as this.n 7→ under this.n + 1. Applying
this substitution to the effect writes this and putting the
result back into the constraint set yields the inferred effects
shown in line 5. The algorithm then terminates because there

416430430428428

are no new effects to add.

IV. THE DP J IZ ER TOOL

We have built an interactive tool, DP J IZ ER, incorporating
the algorithm discussed in Section III. We implemented
DP J IZ ER as an Eclipse plug-in. Given a partial DPJ program
with legal region annotations, DP J IZ ER produces a legal DPJ
program with region and effect annotations. In addition, the
tool has some valuable interactive features. A programmer
can select an effect in a method summary, and DP J IZ ER
highlights the statements or expressions that generated that
effect (as seen in the screen fragment in Figure 16). Alter-
nately, the programmer can select a statement or expression,
and DP J IZ ER highlights its corresponding effect in the effect
summary. Thus, when the compiler reports interference
warnings, the developer can use DP J IZ ER to localize the
problem and reﬁne the region annotations accordingly.
We now describe in more detail how DP J IZ ER helps pro-
grammers write DPJ programs. Typically, a DPJ programmer
carries out the following steps to convert a given sequential
Java program to DPJ.

1) Choose which sections of code are to be run in
parallel, but do not yet insert the parallel constructs
(cobegin, foreach, etc.).
2) Devise a strategy for using region declarations, region
parameters, and RPLs to express the noninterference
of the parallel sections. Add these annotations and
make sure they pass the type checker. At this point,
the methods all have an empty summary, which in
DPJ means the most conservative effect, i.e., writes
Root:*. Such effect summaries will pass the type
checker but will not allow parallelism to be safely
expressed.
3) For methods transitively invoked by a parallel section,
reﬁne the method summaries as necessary to make the
parallel tasks mutually noninterfering.
4) Add the parallel constructs to the parallel sections.
5) If there are any interference warnings, then revisit
steps two and three to revise the region annotations
and/or method effect summaries to eliminate the in-
terference.

DP J IZ ER helps this process in the following ways. First,
step three is completely automated. This automation removes
a lot of work from the development process, particularly if
the user has to do two or more iterations of steps two and
three. While the compiler provides error information of the
form “effect E is missing from the summary of method
m” that helps the user ﬁx bad summaries, step three is still
time consuming and difﬁcult. Code with many methods and
invocations requires a lot of summaries. Further, it is difﬁcult
for a user to manually propagate effects backwards along
the call graph and around cycles. DP J IZ ER automates this
process.

Figure 16. The programmer selects an effect in the effect summary and
D P J I Z ER highlights the statement that generated that effect.

Second, DP J IZ ER helps step ﬁve by identifying the state-
ments and expressions within a method that are contributing
“bad” effects. A key part of this step is understanding the
statements and methods that contribute these effects; the tool
simpliﬁes that greatly by allowing users to map effects back
to the expressions that produce them, and vice versa. With
additional programming (not yet implemented for lack of
time), the tool will also help understand better how effects
are propagated from methods to call sites, along with the
relevant substitutions and how they propagate around cycles
in the call graph, in some cases leading to summarization
with ‘*’.

V. EVALUAT ION

Research Questions. To evaluate the effectiveness of
DP J IZ ER, we answer the following two questions:
• Q1: Is DP J IZ ER useful? Does it alleviate the burden
of writing effect annotations?
• Q2: Are the inferred effects precise? Do the inferred
effects enable the compiler to prove determinism of the
program?

We answer these questions in two ways: with a case study
running the tool ourselves, and with a survey in which we
asked other programmers who have written DPJ programs to
run the tool and describe their experience using it. The case
study (Section V-A) provides quantitative answers, while the
survey (Section V-B) provides qualitative answers.

A. Case Study

1) Methodology: Table I lists the programs that we used
as case studies. Program size is given in non-blank, non-
comment lines of source code, counted by sloccount. These
programs were manually annotated with regions and effects
by other programmers before the existence of DP J IZ ER. We
took these programs, erased the effect annotations leaving
only the region annotations, and used DP J IZ ER to infer the
method effects.
To answer the ﬁrst question (usefulness), we report the
number of effects that programmers wrote manually. To
answer the second question (precision), we check that the
effects inferred by DP J IZ ER are not interfering in the parallel
constructs (e.g., cobegin). We also compare the effects
written manually with those inferred by DP J IZ ER.
Note that DP J IZ ER’s analysis does not take parallel state-
ments into account. When using DP J IZ ER, it is assumed that
the code has an appropriate set of region annotations such

417431431429429

that a ﬁne-grained enough set of effects would make the
effects of statements in parallel statements noninterfering.
So, the answer to the second question (precision) clariﬁes
whether DP J IZ ER infers such ﬁne-grained effects.
2) Quantitative Results:

Q1: Is DP J IZ ER useful? From Table I one can see that
if the programmers had used DP J IZ ER to infer the method
effects, they would have saved writing 406 effects. Further,
the programmers would have saved the time it
took to
generate these effects by manually propagating constraints
backwards through the call graph, around cycles, and up the
inheritance graph.
Q2: Are the inferred effects precise? Do the inferred
effects enable the compiler to prove determinism of the
program? We carefully analyzed the programs in Table I
and compared the effects written by programmers with the
effects inferred automatically by DP J IZ ER. Since program-
mers did not write effects for all methods, we can only
compare the effects for the methods that were annotated.
Table I shows the number of differences between the
manually and automatically inferred effects. Note that in all
cases, DP J IZ ER infers effects that are the same as, or more
precise than those written by the programmer. In terms of
precision, there are two categories of differences between
manually and automatically inferred effects: (i) granularity
and (ii) redundancy.
In terms of granularity, some of the manual effects are
too coarse-grained in the choice of effect keyword, e.g.,
writes R instead of reads R. This is legal (i.e., it type-checks)
but unnecessarily coarse and forbids the parallel execution
of two methods (e.g., two get() methods) that only read
region R and otherwise could have been executed in parallel.
Second, some manually inferred effects are too coarse-
grained in the region speciﬁcation. For example, the pro-
grammer speciﬁed writes P:* when the appropriate effect
inferred by DP J IZ ER was writes P, P:L:*, P:R:*. The
coarser region inferred by programmer forbids any other
method that writes in a subregion of P to run in parallel.
This is an unnecessary restriction because the method only
writes in subregions created using the L or R preﬁxes, so
that another method that writes into P:M should be allowed
to run in parallel.
In terms of redundancy, some of the manually written
summaries contain redundant effects. For example, the pro-
grammer speciﬁed reads R writes R, but the read effect
is subsumed by the write. Alternatively, the programmer
wrote writes P, P:*, where the ﬁrst region is redundant
since it is subsumed by the second region. Such redundan-
cies do not hinder parallelism but make the method effect
summary unnecessarily verbose, which can hinder program
understanding.
We carefully analyzed the source code of the methods,
and indeed DP J IZ ER inferred the most ﬁne-grained effects

that are possible to express with the current DPJ language
and the user-deﬁned threshold on the RPL length, and the
summaries do not contain redundant effects.
With respect to redundancy, DP J IZ ER does a better job
than the programmer. With respect
to granularity,
there
is a trade-off between expressible parallelism, reusability,
and readability of code. Fine-grained effects enable more
parallelism. However, the programmer might prefer coarser-
grained effects to aid reusability. For example, the program-
mer might make effects of a method coarser-grained to
allow future code extensions. For instance, she may prefer to
summarize the effect of a method as writes R, even though
reads R covers the effects of that method. But, she chooses
the coarser-grained effect, writes R, because she anticipates
subclasses that will override the method with the effect
writes R. DP J IZ ER works in a closed-world environment:
it only infers effects based on the available code and does
not take reusability into account. Therefore, the programmer
has to rerun DP J IZ ER each time she extends the code. Also,
an effect like writes P:* is coarser-grained than writes P,
P:L:*, P:R:*, but it is more readable.
For each program, the programmer wrote a set of regions
and parallel constructs. Then, DP J IZ ER inferred a set of
sufﬁciently ﬁne-grained effects that enabled the compiler
to prove determinism of the program. That is, DP J IZ ER
inferred ﬁne-grained effects that did not interfere in the
parallel statement, and enabled all of the speciﬁed parallel
constructs to run safely. To verify this, we checked that the
compiler did not report any interference warnings in the
code with inferred effects. The other way to verify this is to
notice that DP J IZ ER inferred effects that were ﬁner-grained
than those written manually. Therefore, because none of the
manually written effects interfered in the parallel statements,
none of the inferred effects interfered either.

B. User Survey

We also conducted a preliminary survey of other program-
mers who have previously written DPJ programs. This study
comprised the following steps:

1) We elided the effect annotations on the programs
previously parallelized by these users, but retained the
region annotations they had written.
2) The users then used DP J IZ ER to infer the effect
annotations for those programs.
3) The users ﬁnally ﬁlled out a brief questionnaire asking
about the results, usability and overall experience of
using DP J IZ ER.

This study is limited because it only has a small number
of users and they all know the study authors. Nevertheless,
it provides some preliminary feedback on the usefulness of
the tool from experienced DPJ programmers not involved in
designing or building DP J IZ ER (none of them had seen or
even participated in discussions about DP J IZ ER before the
survey).

418432432430430

Program

SLOC

Barnes-Hut

698

CollisionTree

1021

IDEA

K-means

ListRanking

MergeSort

299

540

106

147

47

83

3

3

4

7

MonteCarlo

1502

179

QuadTree

QuickSort

StringMatch

SumReduce

143

150

380

60

13

12

54

1

Total

5046

406

17

# of
Manually
Written
Effects

# of Effects
Too
Coarse
By

keyword

region

# of
Redundant
Effects

1

4

0

0

1

0

5

1

0

5

0

0

14

0

0

2

4

0

2

0

21

0

43

3

0

0

0

0

0

16

0

3

2

0

24

Table I
L I S T O F P ROG RAM S , S I Z E S O F THO S E P ROG RAM S , AND TH E NUM B ER O F
E FFEC T S P ROG RAMM ER S HAV E W R I T T EN . W E A L S O R E P O RT TH E
MANUA L E FFEC T S THAT A R E TOO COA R S E - G RA I N ED BY K EYWO RD
( E . G . , P ROG RAMM ER W ROT E writes R I N S T EAD O F reads R) O R BY
R EG I ON ( E . G . , P ROG RAMM ER W ROT E reads R:* I N S T EAD O F reads R) .
T H E LA S T CO LUMN S HOW S TH E NUM B ER O F R EDUNDAN T E FFEC T S
( E . G . , P ROG RAMM ER W ROT E BOTH reads R writes R) .

Usefulness: The users said the tool saved “a signiﬁcant
fraction” of porting effort. One user said the tool saved “a lot
of time in the process of writing/adding annotations . . . and
then compiling to ﬁnd more methods to annotate.”
Accuracy: One user thought the tool inferred too many
annotations: he would prefer to see fewer effect annotations,
and could re-run the tool if more were needed. Conversely,
he said the tool did help eliminate some redundant annota-
tions (compared with his manual effect summaries).
Requested features: The most requested features
included incremental addition of annotations; presenting
choices of annotations to the user and letting him choose;
and recommending better region structure to produce more
ﬁne-grain effects. (The latter is outside the scope of the
current work but is a subject of future work, as described in
Section VII.)
Summary: Overall, all users said that they would use
DP J IZ ER to help write DPJ programs. One user said “I think
it will also help me redesign region structures to be more
precise and effective.”

V I . RE LAT ED WORK

Effect inference. The seminal work on inferring effects
is from Jouvelot and Gifford [7]. They use a technique
called algebraic reconstruction to infer types and effects in
a mostly functional language. Talpin and Jouvelot [8] build
on this work to develop a constraint-based solving algo-
rithm. These algorithms are tailored to a mostly-functional
language with a much simpler effect system than DPJ’s:
nested effects cannot be expressed, so no summaries such
as R : ∗ have to be inferred.

Bierman and Parkinson [9] present an inference algorithm
for Greenhouse and Boyland’s effect system [3]. The fea-
tures they consider are similar to the smallest subset of Core
DPJ we covered in section III-A, plus support for unique
reference annotations and a limited form of nesting. Again
there is no unbounded nesting.

Side-effect analysis [17]–[20] uses interprocedural alias
analysis and dataﬂow propagation algorithms to compute the
side effects of functions. There are two major differences
between these algorithms and DP J IZ ER. First, DP J IZ ER op-
erates on programmer-speciﬁed region types, which identify
and express effects more precisely than alias analysis. Sec-
ond, DP J IZ ER exploits the structure of RPLs to do a custom
solution for recursive calls, which should signiﬁcantly speed
up convergence of the constraint solver.

Commutativity analysis [21] uses symbolic execution to
collect the side effects of methods and reason about which
pairs of methods commute with each other. The analysis
is fully automatic, but less expressive than DPJ, because
programs must be written in a certain restricted style in order
for the analysis to work.

Region and type inference. There is extensive litera-
ture on region inference for region-based memory man-
agement [22]–[25]. Several researchers have studied the
problem of inferring types or type qualiﬁers for imperative
programs with references. Kiezun et al. [26] show how to
infer Java generic parameters and arguments. Agarwal and
Stoller show how to do type inference for parameterized
race-free Java [27]. Quinonez et al. [28] present a tool called
Javariﬁer for inferring reference immutability for variables
(i.e., that the reference is never used to update the state
of any object that it transitively points to). Terauchi and
Aiken [29] present a type inference algorithm for deter-
ministic parallelism using linear types supplemented with
fractional permissions [30].

Method effect summaries. Many effect systems employ
effect summaries to enable modular analysis and compos-
ability of program components. The original proposals for an
object-oriented effect system [3], [15] use summaries, as do
several systems combining object ownership with some form
of effects [6], [14], [16]. Our work presents an algorithm and
a tool that can be used to infer such summaries.

These algorithms are broadly similar to ours, in that they
collect constraints across the whole program and solve them.
However, the technical details are quite different because the
problem domains differ from our problem of inferring effects
for nested regions. The region and type inference techniques
may be useful in extending DP J IZ ER to infer DPJ region
annotations.

419433433431431

V I I . CONCLU S ION S

We have presented an effect
inference algorithm and
a tool, DP J IZ ER,
that ease the burden of writing DPJ
programs. Our experience shows that DP J IZ ER infers ef-
fects that are are both readable and precise. The DP J IZ ER
algorithm is also applicable to other effect systems that rely
on method effect summaries and nested heap regions. As
future work, we plan to extend the capabilities of DP J IZ ER
so that it can help with region inference, i.e., inferring region
declarations, region parameters, and region arguments. Re-
gion inference in DPJ is challenging, but preliminary work
indicates that it should be possible to infer regions for many
common parallel patterns.

[12] D. G. Clarke et al., “Ownership types for ﬂexible alias
protection,” OOPSLA, 1998.

[13] C. Boyapati, B. Liskov, and L. Shrira, “Ownership types for
object encapsulation,” in POPL, 2003.

[14] C. Boyapati, R. Lee, and M. Rinard, “Ownership types for
safe programming: preventing data races and deadlocks,” in
OOPSLA, 2002.

[15] K. R. M. Leino et al., “Using data groups to specify and
check side effects,” 2002.

[16] N. R. Cameron, S. Drossopoulou, J. Noble, and M. J. Smith,
“Multiple ownership,” OOPSLA, 2007.

V I I I . ACKNOW L EDGMENT S

[17] J. P. Banning, “An efﬁcient way to ﬁnd the side effects of
procedure calls and the aliases of variables,” in POPL, 1979.

This work is funded by Microsoft and Intel through the
Universal Parallel Computing Research Center (UPCRC) at
the University of Illinois and by NSF grants 07-02724, 07-
20772, 08-33128 and 08-33188.

RE F ERENCE S

[18] B. G. Ryder, W. A. Landi, P. A. Stocks, S. Zhang, and
R. Altucher, “A schema for interprocedural modiﬁcation side-
effect analysis with pointer aliasing,” TOPLAS, 2001.

[19] A. Salcianu and M. C. Rinard, “Purity and side effect analysis
for Java programs,” in VMCAI, 2005.

[1] J. M. Lucassen et al., “Polymorphic effect systems,” in POPL,
1988.

[20] A. Rountev, “Precise identiﬁcation of side-effect-free methods
in java,” in ICSM, 2004.

[2] R. T. Hammel
“FX-87 perfor-
and D. K. Gifford,
mance measurements: Dataﬂow implementation,” Tech. Rep.
MIT/LCS/TR-421, 1988.

[3] A. Greenhouse and J. Boyland, “An object-oriented effects
system,” ECOOP, 1999.

[4] “DPJ homepage,” http://dpj.cs.illinois.edu.

[5] R. L. Bocchino, V. S. Adve, D. Dig, S. Adve, S. Heumann,
R. Komuravelli, J. Overbey, P. Simmons, H. Sung, and
M. Vakilian, “A Type and Effect System for Deterministic
Parallel Java,” to appear in OOPSLA 2009.

[6] D. Clarke and S. Drossopoulou, “Ownership, encapsulation
and the disjointness of type and effect,” in OOPSLA, 2002.

[7] P. Jouvelot and D. Gifford, “Algebraic reconstruction of types
and effects,” in POPL, 1991.

[8] J.-P. Talpin and P. Jouvelot, “Polymorphic type, region and
effect inference,” J. Funct. Prog., July 1992.

[9] G. Bierman and M. Parkinson, “Effects and effect inference
for a core java calculus,” Workshop on Object Oriented
Developments (WOOD), 2003.

[10] R. L. Bocchino, V. S. Adve, S. V. Adve, and M. Snir, “Parallel
Programming Must Be Deterministic By Default,” in First
USENIX Workshop on Hot Topics in Parallelism (HotPar),
2009.

[11] J. Gosling, B. Joy, G. Steele, and G. Bracha, The Java
Language Speciﬁcation, Third Edition.
Addison-Wesley
Longman, 2005.

420434434432432

[21] P. C. Diniz, “Commutativity analysis: A new analysis tech-
nique for parallelizing compilers,” TOPLAS, 1997.

[22] M. Tofte and L. Birkedal, “A region inference algorithm,”
TOPLAS, 1998.

[23] W.-N. Chin, F. Craciun, S. Qin, and M. Rinard, “Region
inference for an object-oriented language,” in PLDI, 2004.

[24] A. Banerjee, M. Barnett, and D. A. Naumann, “Boogie meets
Regions: A veriﬁcation experience report,” in VSTTE, 2008.

[25] D. Grossman, G. Morrisett, T. Jim, M. Hicks, Y. Wang, and
J. Cheney, “Region-based memory management in Cyclone,”
PLDI, 2002.

[26] A. Kiezun, M. D. Ernst, F. Tip, and R. M. Fuhrer, “Refactor-
ing for parameterizing Java classes,” in ICSE, 2007.

[27] R. Agarwal and S. D. Stoller, “Type inference for parameter-
ized race-free Java,” in VMCAI, 2004.

[28] J. Quinonez, M. S. Tschantz, and M. D. Ernst, “Inference of
reference immutability,” in ECOOP, 2008.

[29] T. Terauchi and A. Aiken, “A capability calculus for concur-
rency and determinism,” TOPLAS, 2008.

[30] J. Boyland, “Checking interference with fractional permis-
sions,” SAS, 2003.

IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 34, NO. 3, MAY/JUNE 2008

321

Effective Software Merging in the
Presence of Object-Oriented Refactorings

Danny D ig, Kash if Manzoor, Ra lph Johnson, Member, IEEE Computer Soc iety, and
T ien N. Nguyen, Member, IEEE

Abstract—Current text-based Software Configuration Management (SCM) systems have trouble with refactorings. Refactorings result
in global changes, which lead to merge conflicts. A refactoring-aware SCM system reduces merge conflicts. This paper describes
MolhadoRef, a refactoring-aware SCM system, and the merge algorithm at its core. MolhadoRef records change operations
(refactorings and edits) used to produce one version and replays them when merging versions. Since refactorings are change
operations with well-defined semantics, MolhadoRef treats them intelligently. A case study and a controlled experiment show that
MolhadoRef automatically solves more merge conflicts than CVS while resulting in fewer merge errors.

Index Terms—Refactoring, merging, Software Configuration Management, version control systems.

Ç

1 INTRODUCTION
ONE of the important kinds of change in object-oriented
programs is refactoring [2]. Refactorings are program
transformations that improve the internal design without
changing the observable behavior (e.g., renamings, moving
methods between classes, changing method signatures).
Automated refactoring tools have become popular because
they allow programmers to change source code more
quickly and safely than manually. However, refactoring
tools make particular demands on text-based SCM systems.
SCM systems work best with modular systems. Different
programmers tend to work on different modules and, so, it
is easy to merge changes. However, refactorings cut across
module boundaries and cause changes to many parts of the
system. SCM systems signal a conflict when two program-
mers change the same line of code even if each just changes
the name of a different function or variable. So, SCM
systems have trouble merging refactorings.
A common process [3] for refactoring on large projects is
“check everything in and then wait until refactoring is
done,” analogous to a “code freeze.” However,
this
serializes the development of a code. In addition, by forcing
refactorings to be performed by only a few people at a
certain time, opportunities for refactoring are lost.
Although the number of global changes varies from
system to system, our previous study [4] of five widely used

. D. Dig is with MIT CSAIL, The Stata Center, Building 32-G720, 32
Vassar Street, Cambridge, MA 02139. E-mail: dannydig @csail.mit.edu.
. K. Manzoor is with Techlogix, Pakistan.
E-mail: cashifmanzoor@gmail.com.
. R. Johnson is with the Department of Computer Science, Siebel Center,
University of Illinois at Urbana-Champaign, 201 N. Goodwin Ave.,
Urbana, IL 61801. E-mail: johnson @cs.uiuc.edu.
. T.N. Nguyen is with the Department of Electrical and Computer
Engineering, Iowa State University, 3218 Coover Hall, Ames, IA 50011.
E-mail: tien@iastate.edu.

Manuscript received 21 Jan. 2007; revised 5 Oct. 2007; accepted 21 Jan. 2008;
published online 22 Apr. 2008.
Recommended for acceptance by B.G. Ryder.
For information on obtaining reprints of this article, please send e-mail to:
tse@computer.org, and reference IEEECS Log Number TSE-0016-0107.
Digital Object Identifier no. 10.1109/TSE.2008.29.

mature Java components showed a significant number of
global changes. For instance, Struts had 136 API changes over
a period of 14 months. In each system, more than 80 percent of
the API changes were caused by refactorings. Because of lack
of support from SCM systems, these changes were tedious to
incorporate manually, although a refactoring-aware SCM
could have incorporated them automatically.
Text-based SCM systems are unreliable. They report
merge conflicts only when two users change the same line
of code. However, a merge might result in an incorrect
program, even when the changes are not on the same line.
This is especially true in object-oriented programs. For
instance,
if one user renames a virtual method while
another user adds a new method in a subclass, even though
these changes are not lexically near each other, textual
merging could result in accidental method overriding, thus
leading to unexpected runtime behavior.
This paper describes MolhadoRef, a refactoring-aware
SCM for Java, and the merge algorithm at
its core.
MolhadoRef has an important advantage over a traditional
text-based SCM. MolhadoRef automatically resolves more
conflicts (even changes to the same lines of code). Because it
takes into account
the semantics of refactorings,
the
merging is also more reliable: There are no compile errors
after merging and the semantics of the two versions to be
merged are preserved with respect to refactorings.
Correct merging of refactorings and manual edits is not
trivial: Edits can refer to old program entities as well as to
newly refactored program entities. MolhadoRef uses the
operation-based approach [5]: It represents a version as a
sequence of change operations (refactorings and edits) and
replays them when merging.
If all edits came before
refactorings, it would be easy to merge the two versions
by first doing a textual merge and then replaying the
refactorings. However, edits and refactorings are mixed, so,
in order to commute an edit and a refactoring, MolhadoRef
inverts refactorings. Moreover, refactorings will sometimes
have dependences between them.
MolhadoRef uses Eclipse [6] as the front end for changing
code and customizes Molhado [7], a framework for SCM, to

0098-5589/08/$25.00 ß 2008 IEEE

Published by the IEEE Computer Society

322

IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 34, NO. 3, MAY/JUNE 2008

store Java programs. Although the merging algorithm is
independent of the Molhado infrastructure and can be reused
with other SCM back ends, building on top of an ID-based
SCM like Molhado allows our system to keep track of the
refactored entities. When evaluating MolhadoRef on a case
study of three weeks of its own development and through one
controlled experiment, we found that MolhadoRef merges
more safely and more automatically than CVS while never
losing the history of refactored entities.
MolhadoRef merges edits using the same three-way
merging [8] of text-based SCMs. It is when MolhadoRef
merges refactorings that it eliminates merge errors and
unnecessary merge conflicts. So, the more that refactorings
are used, the more benefits MolhadoRef provides.
This paper makes the following contributions:

.

.

.

It presents an important problem that appears when
merging refactored code in multiuser environments.
It presents the first algorithm to effectively merge
refactorings and edit operations.
It evaluates the effectiveness of refactoring-aware
merging on one real-world case study and one
controlled experiment.
Without
losing any power to merge manual edits,
MolhadoRef converts refactorings from being the weakest
link in an SCM system to being the strongest.

2 MOTIVATING EXAMPLE

To see the limitations of text-based SCM, consider the
simulation of a Local Area Network (LAN) shown in Fig. 1.
This example is used as a refactoring teaching device [9] in
many European universities.
Initially, there are five classes: Packet, a superclass
LANNode, and its subclasses PrintServer, NetworkTes-
ter, and Workstation. All LANNode objects are linked in a
token ring network (via the nextNode variable) and they can
send or accept a Packet object. PrintServer overrides
accept to achieve specific behavior for printing the Packet.
A Packet object sequentially visits every LANNode object in
the network until it reaches its addressee.
Two users, Alice and Bob, both start from version V0 and
make changes. Alice is the first to commit her changes, thus
creating version V1 , while Bob creates version V2 .
Since method getPacketInfo accesses only fields from
class Packet, Alice moves method getPacketInfo from
class PrintServer to Packet ð1 Þ. Next, she defines a new
method, sendPacket(Packet) ð2 Þ, in class Network-
Tester. The implementation of this method is empty
because this method simulates a broken network that loses
packets. In the same class, she also defines a test method,
testLosePacket ð3 Þ and implements it to call method
sendPacket ð4 Þ. Last, Alice renames WorkStation.
originate(Packet) to generatePacket(Packet)
ð5 Þ. Alice finishes her coding session and commits her
changes to the repository.
In parallel with Alice, Bob renames method PrintSer-
ver.getPacketInfo(Packet) to getPacketInfor-
mation(Packet) ð6 Þ. He also renames the polymorphic
method LANNode.send() to sendPacket ð7 Þ. Last, Bob
renames class WorkStation to Workstation (different
capitalization 8 ). Before Bob can commit his changes, he
must merge his changes with Alice’s.

A text-based SCM system reports merge conflicts when
two users change the same line. For instance, because Alice
moved the declaration of method ð1 Þ while Bob altered the
declaration location of the same method through renaming
ð6 Þ, textual merging cannot automatically merge these
changes. This is an unnecessary merge conflict because a
tool like MolhadoRef which understands the semantics of
the changes can merge them.
In addition, because a text-based merging does not know
anything about the syntax and semantics of the program-
ming language, even a “successful” merge (e.g., when there
are no changes to the same lines of code) can result in a
merge error. Sometimes errors can be detected at compile
time. For instance, after textual merging, the code in method
testLosePacket does not compile because it calls
method send, whose declaration was replaced by send-
Packet through a rename ð7 Þ. Such an error is easy to
catch, though it is annoying to fix.
Other errors result in programs that compile but have
unintended changes to their behavior. For instance, because
Alice introduces a new method sendPacket in subclass
NetworkTester and Bob renames the polymorphic
method send to sendPacket, a textual merge results in
accidental method overriding. Therefore, the call
inside
testSendToSelf to sendPacket uses the empty im-
plementation provided by Aliceð2 Þ to simulate loss of
packets , whi le th is method cal l or iginally used the
implementation of LANNode.send. Since this type of
conflict is not reported during merging or compilation,
the user can erroneously assume that the merged program
is correct, when in fact
the merging introduced an
unintended change of behavior.
Fig. 2 shows the merged program after merging with
MolhadoRef. MolhadoRef catches the accidental method
overriding caused by adding a new method ð2 Þ and
renaming another method ð7 Þ and presents it to the user.
The user decides to rename the newly introduced method
NetworkTester.sendPacket to losePacket. This is
the only time when MolhadoRef asks for user intervention;
it automatically merges all of the remaining changes. The
merged version contains all of the edits and refactorings
performed by Alice and Bob (e.g., notice that method
getPacketInformation is both renamed and moved).

3 BACKGROUND AND TERMINOLOGY

Our approach to refactorings-tolerant SCM systems is based
on a different paradigm, called operation-based merging [5].
In the operation-based approach, an SCM tool records the
operations that were performed to transform one version
into another and replays them when updating to that
version. An operation-based system treats a version as the
sequence of operations used to create it.
Our goal is to provide merging at the API level, that is,
our merging algorithm aims for correct usage of all of the
APIs. For this reason, we distinguish between operations
that affect the APIs and those that do not. MolhadoRef
treats a version as being composed of the following three
operations: API refactorings, API edits, and code edits.
MolhadoRef handles the following API refactorings: re-
name package, rename class, rename method, move class,
move method, and changing the method signature (these
were among the most popular refactorings found in
previous studies [4]). MolhadoRef handles the following
API edits : added package, deleted package, added class,

DIG ET AL.: EFFECTIVE SOFTWARE MERGING IN THE PRESENCE OF OBJECT-ORIENTED REFACTORINGS

323

Fig. 1. Motivating example. Versions V1 and V2 are created in parallel and are both based on V0 . Shaded boxes show the changes in each version: 1
, 5
, 2 and 3 add methods, 4 adds a call
to Packet
moves method PrintServer.getPacketInfo
renames
to sendPacket
, 7 renames
, 6 renames PrintServer.getPacketInfo
to getPacketInformation
to generatePacket
, 8 renames class WorkStation
to Workstation
.

WorkStation.originate
to sendPacket

LANNode.send

deleted class, added method declaration, deleted method
declaration, added field declaration, deleted field declara-
tion. Any other types of edits are categorized as code edits.

Code edits do not have well-defined semantics, making
it difficult to merge them correctly. API edits have better
defined semantics. However, refactorings are the operations

324

IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 34, NO. 3, MAY/JUNE 2008

Fig. 2. Resolved motivating example using MolhadoRef.

with the most well-defined semantics and thus are the ones
that can benefit the most from operation-based merging.
Therefore, MolhadoRef merges code edits textually and,
since it is aware of the semantics of refactorings and API
edits, it merges them semantically.
Any operation can be regarded as a function from
programs to programs, more precisely, a source-to-source
program transformation:  : P rogram ! P rogram
When necessary, we make the distinction between
refactorings ðÞ and edits ðÞ. Refactorings are transforma-
tions that preserve the semantics, while edits usually
change the semantics of programs.
Operations usually have preconditions. Adding a meth-
od to a class requires that the class exists and does not
already define another method with the same name and
signature, while changing the name of a method requires
that the new name is not in use. Applying an operation 
inappropriately to a program P results in an invalid
program, represented by ? . The result of applying an
operation to ? is ? :
(cid:2)
 ðP Þ ¼ P 0
if preconditions of  hold
? if preconditions of  do not hold:

ð1Þ

The application of two operations is modeled by the
function composition, denoted by “;”. “;” also models the
precedence: i ; j means first apply i and then apply j on
the result: i ; j ðP Þ ¼ j i ðP Þ
ð
Þ.
Definition 1. Two operations commute on a program P if
applying them in either order produces the same valid
program P 00 : j ; i ðP Þ ¼ i ; j ðP Þ ¼ P 00 ^ P 00 6¼? .
Definition 2. Two operations conflict with each other
if
applying them in either order produces an invalid program:
j ; i ðP Þ ¼? ^i ; j ðP Þ ¼? .

For example, adding two methods with the same name
and signature in the same class results in a conflict.
Definition 2 describes conflicts that produce compile
errors. MolhadoRef also catches some conflicts that produce
runtime errors. MolhadoRef currently catches conflicts that
involve method overriding, such as the accidental method
overriding between 2 and 7 .
When two operations do not commute for a program P ,
we say that there is an ordering dependence between them.
We denote this ordering dependence with the P symbol.
Definition 3. j depends on i ði P j Þ if j and i do not
commute:
(cid:3)
(cid:4)
i  j iff i ; j ðP Þ 6¼? ^ i ; j ðP Þ 6¼ j ; i ðP Þ
:
The P dependence is strict partial order, that is, it is
irreflexive, asymmetric, and transitive.
An example of dependence is the renaming of method
WorkStation.originate to generatePacket done by
Alice ð5 Þ and the renaming of class WorkStation to
Workstation done by Bob ð8 Þ. If 8 is played first, the
replaying of 5 is not possible because, at this time, the fully
qualified name WorkStation.originate no longer
exists, thus 5 P 8 .
This dependence between 5 and 8 exists because current
refactoring engines are based on the names of the program
entities and class WorkStation no longer exists after
replaying 8 . If the refactoring engine used the IDs of the
program elements, changing the names would never pose a
problem [10]. To make name-based refactoring engines be ID-
based requires rewriting the engine. This is unfeasible, so the
next best solution is to emulate ID-based engines.
To make the current name-based refactoring engines
emulate ID-based ones, there are at least two approaches.
The first is to reorder the refactorings (e.g., rename method
WorkStation.originate() before renam ing c lass

DIG ET AL.: EFFECTIVE SOFTWARE MERGING IN THE PRESENCE OF OBJECT-ORIENTED REFACTORINGS

325

Fig. 3. Overview of the merging algorithm.

WorkStation). The second is to modify the refactoring
engine so that, when it changes source code, it also changes
subsequent refactorings. For example, during the replay of
renaming class WorkStation to Workstation,
the
refactoring engine changes the subsequent refactoring
RenameMethod(WorkStation.originate, generate
Packet) to RenameMethod(Workstation.origi-
nate, generatePacket). Our merging algorithm uses
both approaches.
Consider a scenario where Alice renames method m1 in
it operation 1 ) and Bob desires to
superclass A (call
override A.m1 by adding a method m1 in subclass B (call it
operation 1 ). Applying these two operations in either order
produces a valid program. However, only one order
preserves Bob’s intent: Applying the edit
followed by
renaming the method in the superclass preserves the
overriding relationship since the renaming 1 also updates
the edit 1 (renaming a method updates all overriding
methods in a class hierarchy). The other order,
the
renaming 1 followed by the edit 1 would result in a
program that compiles, but B.m1 no longer overrides the
superclass method, violating Bob’s intent. Thus, there is a
dependence 1 P 1 .
Definitions 1-3 are mutually exclusive and cover all the
cases.

4 MERGING ALGORITHM
4.1 High Level Overview
We illustrate the merging algorithm (see the pseudocode in
Fig. 3) using the LAN simulation example presented earlier.
The details of each module are found in the later sections.
The merging algorithm takes as input three versions of
the software: Version V0 is the base version and V1 and V2
are derived from V0 . In addition, the algorithm takes as
input the refactorings that were performed in V1 and in V2 .
These refactoring logs are recorded by Eclipse’s refactoring

engine. The output is the merged version, Vmerged , that
contains edits and refactorings performed in V1 and V2 .
Step #1 detects the changes that happened in V1 and V2
by performing a three-way comparison between V1 , V2 , and
V0 . From these changes and the refactoring logs,
it
categorizes edits and refactorings operations. For example,
in V1 , it detects two added methods, 2 and 3 . In V2 , it
detects no edits but only refactorings.
Step #2 searches for compile and runtime conflicts in API
edits and refactorings. In our example, it detects a conflict
between the add of a new method, 2 in V1 , and the rename
method refactoring, 7
in V2 . This conflict reflects an
accidental method overriding. The conflict is presented to
the user, who resolves it by choosing a different name for
the added method (in this case losePacket instead of
sendPacket). The algorithm also searches for possible
circular dependences between operations performed in V1
and operations in V2 . If any are found, the user deletes one
of the operations involved in the cycle (in our example,
there are no circular dependences). This process of
detecting/solving continues until no more conflicts or
circular dependences remain.
Step #3 inverts each refactoring in V1 and V2 by applying
another refactoring. For instance, it inverts the move method
refactoring 1 by moving method getPacketInfo back to
PrintServer and it inverts the rename class refactoring 8
by renaming Workstation back to theorem. By inverting
refactorings, all of the edits that were referencing the
in place but
refactored program entities are still kept
changed to refer to the old version of these entities. This
 Ref actorings
step produces two software components, V
 Ref actorings
1
and V
, which contain all of the changes in V1 ,
2
respectively V2 , except refactorings.
Step #4 merges textually (using the classic three-way
 Ref actorings
merging [8]) all of the API and code edits from V
1
 Ref actorings
and V
. Since the refactorings were previously
2
inverted, all same-line conflicts that would have been

326

IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 34, NO. 3, MAY/JUNE 2008

caused by refactorings are eliminated. For example, inside
PrintServer.print there are no more same-line con-
flicts. Therefore, textual merging of code edits can proceed
smoothly. This step produces a software component, called
 Refactorings
V
.
merged
 Ref actorings
Step #5 replays on V
the refactorings that
merged
happened in V1 and V2 . Before replaying, the algorithm
reorders all of
the refactorings using the dependence
relations. Replaying the refactorings incorporates their
 Ref actorings
changes into V
, which already contains all of
merged
the edits. For example, replaying a method renaming
refactoring updates all of the call sites to that method,
including the ones introduced by edits.

4.2 Detecting Operations
To detect refactorings, API edits, and code edits,
the
algorithm takes as input the source code of the three
versions V0 , V1 , and V2 , along with their refactoring logs.
Recent extensions to refactoring engines (e.g., [11]) log the
refactorings at the time they were performed. This log of
refactorings is saved in a configuration file and is stored
along with the source code. Since our algorithm is
implemented as an Eclipse plug-in, it has access to this
log of refactorings. Even in cases when such a log of
refactorings is not recorded,
it can be detected using
RefactoringCrawler [12], a tool for inferring refactorings.
To detect the API edits and code edits, the algorithm
employs a three-way textual comparison (a two-way com-
parison cannot distinguish between additions and deletions
[13]). This comparison (line 5 in Fig. 3) detects lines, files,
and folders that were changed. From this low level
information, the algorithm constructs (line 7) the higher
level semantic API edits (e.g., add method) by parsing and
correlating the positions of changed tokens with that of
changed lines.
Even though the scope of our merging is at the API level,
to correctly signal compile or runtime conflicts,
the
algorithm detects a few edit operations that are below the
API level. These include add/delete method call, add/
delete class instantiation, add/delete class inheritance, and
add/delete typecast. From this information, the algorithm is
able to detect conflicts like the one appearing if Alice deletes
the method declaration accept and Bob adds a method call
to accept.
Some of the edit operations overlap with or are the side
effects of refactorings. For example, after renaming class
WorkStation to Workstation, a textual comparison
renders WorkStation as deleted and Workstation as
added. Using the information from the refactoring logs, the
algorithm discards these two edits since they are super-
seded by the higher level refactoring operation.
The output of this step is the list of change operations
(refactorings and edits) that happened in each of V1 and V2 .

4.3 Detecting and Solving Conflicts and Circular
Dependences
Detecting conflicts. Next, MolhadoRef detects conflicts
between operations in V1 and V2 . For this, it uses a conflict
matrix (the companion technical report [14] describes all of
its cells). For any two kinds of operations, the matrix gives a
predicate that responds whether the operations conflict.
This matrix includes refactorings, API edits, and the code

Fig. 4. The RenameMethod/RenameMethod cell in the conflict matrix.

edits that are currently handled. MolhadoRef instantiates
the conflict matrix for the concrete operations detected in
the previous step and signals any conflicts between these
operations.
in
the content of one single cell
Next, we present
case when i
the
conflict matrix, namely the
is
RenameMethodðm1 ; m2 Þ and j is RenameMethodðm3 ; m4 Þ.
These two renamings result in a conflict if 1) the source of
both refactorings is the same program element
(e.g.,
m1 ¼ m3 ) but
their new names would be different or
2) the sources of both refactorings are different program
elements but the destination of both refactorings is the same
(e.g., m2 ¼ m4 ).
In addition, due to
program element
polymorphic overriding, we must also consider the case
when two methods are not the same program element, but
one method overrides the other.
When the sources of both refactorings are the same
(item 1), if methods m1 and m3 are in the same class, there
would be a compile-time conflict since the users want to
rename the same method differently. If the methods m1 and
m3 are overriding each other, renaming them differently
results in a runtime conflict because the initial overriding
relationship would be broken. When the destination of the
two refactorings is the same (item 2), if methods m1 and m3
are in the same class, renaming them to the same name
results in a compile-time error (two methods having the
same signature and name). If methods m1 and m3 are not in
the same class and do not initially override each other,
renaming them to the same name results in a runtime
conflict because of accidental method overriding.
More formally, using first-order predicate logic, Fig. 4
describes the content of
the RenameMethod/Rename-
Method cell
in the conflict matrix. Similar formulas
describing the remaining cells in the matrix are in a
companion technical report [14]. The predicates in each
cell are computed “by hand,” but they are carefully revised.
Although the matrix and its predicates describe operations
independent of a particular program, in this step, MolhadoR-
ef instantiates it for the program under analysis and its
concrete operations detected in Step #1. For example,
MolhadoRef detects the accidental method overriding con-
flict between 2 and 7 in the motivating example. This conflict
is presented to the user who can decide how to solve it.
Detecting circular dependences. In this step, the merge
algorithm also creates the dependence graph (line 13 in
Fig. 3) between operations performed in the two versions to
be merged. Initially, there is a total (i.e., linear) order of the
change operations in each version, given by the time
sequence in which these operations were applied. However,
when merging, the operations can be replayed in any order
unless there is a dependence between them. Thus, the total
order can be ignored in favor of a partial order, induced by
the P relation.
To create this partial order, we represent each operation
as a node in a directed graph, called the dependence graph.
When i P j , the algorithm adds a directed edge from i

DIG ET AL.: EFFECTIVE SOFTWARE MERGING IN THE PRESENCE OF OBJECT-ORIENTED REFACTORINGS

327

require user intervention. To break circular dependences,
the user must select operations to be discarded and
removed from the sequence of operations that are replayed
during merging. Discarding refactorings has no effect on
the semantics of the merged program because refactorings
are transformations that do not change the semantics.
Discarding edits can potentially affect the semantics of the
merged program. However, this solution would be used
only in extreme cases (we have never run into such a
scenario during evaluation). Alternatively, most circular
dependences (including the one in Fig. 5) can be solved
automatically by MolhadoRef by inverting the refactorings
(see Section 4.4).
To solve the syntactic or semantic conflicts caused by name
collision, the user must select a different name for one of the
program elements involved in the conflict. In our LAN
motivating example (Fig. 1), Alice renames method send to
sendPacket and Bob adds a new method declaration
sendPacket such that the two methods accidentally over-
ride each other. This conflict is brought to Bob’s attention,
who can either choose a different name for his newly
introduced method or can pick a new name to supersede
the name chosen by Alice. In the motivation example, Bob
chose to rename his newly introduced method sendPacket
to losePacket. Once Bob chooses the new name, Molha-
doRef automatically performs this rename.
The process of finding and solving conflicts and circular
dependences is repeated until there are no more conflicts or
circular dependences (line 15 in Fig. 3). The algorithm
always converges to a fixed point because it starts with a
finite number of operations and the user deletes some in
each iteration.

4.4 Inverting Refactorings
Step #3 makes a version of V1 and V2 without any
refactorings by inverting all refactorings.
Inverting a
refactoring 1 involves creating and applying an inverse
1 ð1 ðP ÞÞ ¼ P for all
refactoring.  
1 is an inverse of 1 if  
programs P that meet the precondition of 1 . For example,
the inverse of the refactoring that renames class A to B is
another refactoring that renames B to A, the inverse of a
move method is another move method that restores the
original method, the inverse of the extract method is the
inline method, the inverse of pull-up member in a class
hierarchy is push-down member. In fact, many of the
refactorings described in Fowler et al.’s refactoring catalog
[2] come in pairs: a refactoring along with its opposite
(inverse) refactoring.
Given any refactoring, there exists another refactoring
that inverts (undoes) the first refactoring (although such an
inverse refactoring cannot be always applied because of
later edits). There is an important distinction between what
we mean by inverting a refactoring and how the popular
refactoring engines (like Smalltalk RefactoringBrowser,
Eclipse, or IntelliJ IDEA) undo a refactoring. To decrease
memory usage and avoid recomputations of preconditions,
the refactoring engines save the location of all source code
that was changed by the refactoring. When undoing a
refactoring, the engines undo the source changes of these
locations.
Although efficient, this approach has a drawback: The
only way to undo a refactoring that was followed by edits is
to first undo all of the edits that come after it. This approach

Fig. 5. Circular dependence between operations from two users. Arrows
represent the direction of the dependences (e.g., add method C.m1
must be applied before renaming method A.m1). The left-hand side
shows operations from Bob, right-hand side shows operations from
Alice. The figure depicts the dependence graph as it is created in Step
#2 of the algorithm.
to j . To find out the P dependences, the algorithm uses a
dependence matrix, which describes dependence relations
between all kinds of operations (similar to how the conflict
matrix describes conflicts). MolhadoRef
instantiates the
dependence matrix for the concrete operations in the
versions to be merged. MolhadoRef places all of
the
concrete operations in the dependence graph and adds
dependence edges using the information from the depen-
dence matrix.
Next, the algorithm searches for cyclic dependences in
the dependence graph. There can only be cycles between
operations from different users, not between operations
from the same user, because, for each user, it was initially
possible to play all of the operations. Fig. 5 shows a scenario
where a cycle appears between operations from two users.
Initially, the base version contains one class A with one
method A.m1. The operations on the left-hand side are
performed by Bob and the ones on the right-hand side are
performed by Alice. Bob renames class A to B, then adds a
subclass C of B. Next, in class C, Bob adds a method with
name m1 which overrides the method in the superclass B. In
parallel with Bob, Alice renames method A.m1 to m2.
The arrows on Bob’s side indicate the original order in
which the operations took place. The arrow from Alice’s
rename method to Bob’s renaming the class points to a
dependence caused by the current refactoring engines. The
refactoring engines use the fully qualified names to identify
the program elements to be refactored; therefore, renaming
the method A.m1 must be performed before renaming its
class declaration A; otherwise, the refactoring engine can no
longer find the element A.m1. The arrow from Bob’s adding
method C.m1 to Alice’s renaming the superclass method
A.m1 points to another dependence. The subclass method
must be added before the renaming of the superclass
method A.m1 such that, when replaying the Rename-
Method(A.m1, m2), it also renames C.m1 (playing them
in a different order would cause the two methods to no
longer override each other).
After it finds all cycles, MolhadoRef presents them to the
user, who must choose how to eliminate cycles (see the next
section). Assuming that
there are no more cycles, all
operations are in a directed acyclic graph.
User-assisted conflict and dependence resolution.
Circular dependences and compile and runtime conflicts

328

IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 34, NO. 3, MAY/JUNE 2008

is not suitable for MolhadoRef. MolhadoRef must be able to
undo a refactoring without undoing later operations. Thus,
MolhadoRef inverts refactorings by creating and executing
an inverse refactor ing operation (wh ich is another
refactoring).
To create the inverse refactoring, MolhadoRef uses the
information provided in the refactoring logs of Eclipse.
Each refactoring recorded by Eclipse is represented by a
refactoring descriptor which contains enough textual in-
formation to be able to recreate and replay a refactoring.
Among others, the descriptor contains information such as
what kind of refactoring is created, what the program
element on which it operates is, and what other parameters
have been provided by the user through the UI (e.g., the
new name in case of a rename refactoring or the default
value of an argument in case of refactoring that changes a
method signature by adding an argument). Out of this
information, MolhadoRef creates another refactoring de-
scriptor that represents the inverse refactoring. For exam-
ple, the inverse of the move method refactoring descriptor
representing 1 in our LAN example is another move
method descriptor representing a refactoring that moves
method Packet.getPacketInfo back to PrintServer.
From the inverse refactoring descriptor, MolhadoRef
creates and initializes an Eclipse refactoring object. Once the
refactoring object is properly initialized, the refactoring is
executed using Eclipse’s refactoring engine.
Inverting a refactoring and executing the inverse
refactoring also changes the edits. Recall the motivation
example where Bob renames method getPacketInfo to
getPacketInformation. Later, he adds a new method
call to getPacketInformation. By inverting the rename
method refactoring with the inverse refactoring (renaming
getPacketInformation to getPacketInfo), the new
call site to getPacketInformation is also updated while
keeping the call site in the same place. Deleting the call site
altogether would have introduced a different behavior,
while leaving the call site untouched would have produced
a compilation error.
Probably, the most notable aspect of inverting refactor-
ings is that it inverts the dependences between edits and
refactorings, allowing refactorings to come after edits; thus,
it changes a ref actoring P edit dependence into edit P
ref actoring dependence. This has two advantages. First,
when replaying refactorings in Step #5,
the fact
that
refactorings come after edits ensures that all changes
caused by refactorings are incorporated into edits. Second,
inverting refactorings automatically breaks most of the
circular dependences between operations. Recalling the
example from Fig. 5 with circular dependence, Fig. 6 shows
the dependence graph after inverting the rename class
refactoring. Notice that the edits now refer to class A instead
of B and there are no more circular dependences.
Just as refactorings have preconditions,
inverting a
refactoring also has preconditions and, if those precondi-
tions are not met, then a refactoring cannot be inverted.
Edits in V1 and V2 that were applied after refactorings could
break the preconditions of inverse refactorings. To handle
such cases, we have three heuristics: adding program
transformations, storing additional
information before
inverting a refactoring, or a fallback heuristic in case the
others fail.

Fig. 6. Resolved example of circular dependence from Fig. 5. This figure
shows the dependence graph after Step #3 of the algorithm. Applying
1 Þ effectively pushes 1 after the edits, thus
the inverse refactoring ð 
breaking the circular dependence.

Heuristic #1: Renaming a program element. This
heuristic renames a program element to a unique name
when name collisions prevent inverting a refactoring. For
example, if Bob renames PrintServer.getPacketInfo
to getPacketInformation ð6 Þ and later adds a new
method getPacketInfo in the same class, inverting the
rename refactoring in Step #3 is not possible because the name
getPacketInfo is already in use (by the lately added
method). MolhadoRef searches for potential name collisions
before inverting the refactoring and executes another renam-
ing to avoid the collision. In this case, before inverting the
refactoring, the algorithm renames the newly introduced
method getPacketInfo to a unique name, say getPacket
InfoABC123, and tags this rename refactoring. Now that
there are no more name collisions, renaming 6 can be
inverted. Later, in Step #5, after all of the regular refactorings
have been replayed, the algorithm inverts all refactorings
marked with tags. Thus,
it renames the new method
getPacketInfoABC123 back to getPacketInfo. At this
stage, there are no more name collisions because 6 would
have executed.
Heuristic #2: Storing additional information. This heur-
istic stores additional information before inverting a refactor-
ing since some information can get lost when inverting
refactorings. Consider the case when Bob changes the
signature of a method sendPacket by adding an extra
argument of type integer with the default value 0 to be used in
method calls. Later, he adds a call site where he passes the
value 7 for the extra argument. Inverting the refactoring and
replaying it naively would lose the value 7 and replace it with
value 0. Before inverting the refactoring, MolhadoRef saves
the location of
the new call sites and the values of
parameters so that it can restore the same values later
when replaying the refactoring in Step #5.
Heuristic #3: Fallback—treating refactorings as edits.
When no heuristic for inverting a refactoring is found, the
algorithm treats the refactoring as a classic textual edit,
namely, the refactoring is not inverted and replayed, but its
code changes are incorpora ted by tex tua l merg ing .
Although the advantages of incorporating the semantics
of the refactoring are lost, the algorithm can always make
progress and, in the worst case, it is as good as classic
textual merging.
The first two heuristics are sufficient to invert all of the
refactorings in the evaluations we have done. Nevertheless,

DIG ET AL.: EFFECTIVE SOFTWARE MERGING IN THE PRESENCE OF OBJECT-ORIENTED REFACTORINGS

329

further evaluations might require developing new heur-
istics to handle other types of refactorings or force us to use
the fallback heuristic (heuristic #3). An analysis of all
refactorings currently supported in Eclipse shows that all of
these refactorings could be inverted by first renaming
conflicting program elements (heuristic #1) or storing
additional
information before inverting the refactoring
(heuristic #2).

4.5 Textual Merging
Once refactorings are inverted, all of the edits in V1 and V2
that referred to the refactored APIs now refer to the APIs
present in version V0 . The algorithm merges textually all
files that were changed by edits using the three-way
merging [8] that most text-based SCMs use.
All code changes inserted by refactorings that would
have caused same-line or same-block conflicts are elimi-
nated due to the fact that refactorings were previously
inverted.
In our LAN example, although both users
changed the declaration of getPacketInfo (1 and 6 ),
after inverting the refactorings, the call to method get-
PacketInfo inside PrintServer.print no longer
causes same-line conflict.
Still, if two users change the same lines by code edits (not
refactorings), this can generate a same-line conflict requiring
user intervention, although MolhadoRef can automatically
merge a few more edits than textual-based merging. For
example, if Alice and Bob each add a new method declaration
at the same position in a source file, MolhadoRef merges this
automatically using the semantics of API edits. In contrast,
textual-based merging would signal a same-line conflict.
However, it is when multiple refactorings affect the same
lines that MolhadoRef shines over text-based merging.

4.6 Replaying Refactorings
Current refactoring engines identify program entities with
fully qualified names. Within a stream of operations from a
single version, names will always be consistent because
each refactoring works with the current names of program
elements. However, when refactorings are merged from
two different streams, renamings can interfere with each
other in two ways.
The first is where the refactorings refer to two different
entities, but one of them has a name that includes the other.
For example, the fully qualified name of a method includes
the name of its class. If one refactoring renames a class and
the other changes a method in that class, it is important that
the right method gets changed. MolhadoRef solves this
problem by making sure that the refactorings of a method
are performed before the refactorings that rename its class.
More precisely, MolhadoRef uses a topological sort algo-
rithm [15] to reorder the nodes in the refactorings DAG
created in Step #2.
The second is where two refactorings refer to the same
entity. Sometimes, this is a conflict that must be resolved by
the user, such as when the two refactorings change the
name of the same entity. This case would have been
resolved by Step #2. So, the only remaining cases are when
the two refactorings change the same entity, but in different
ways. For example, one refactoring could rename a method
and the other could move it to a new class (e.g., 6 and 1 ).
Changing either the method name or the class name will
invalidate the other refactoring. MolhadoRef solves this

problem by modifying refactorings. If a refactoring from
one version is replayed after a rename or a “move method”
refactoring from the other version, second refactoring is
changed to use the new name. This lets a name-based
system like Eclipse emulate an ID-based system.
To handle multiple refactorings to the same element, we
extended the definition and semantics of a refactoring. In
addition to source code, a refactoring changes subsequent
refactorings in a chain of refactorings. An enhanced refactor-
ing is a transformation from source code and a chain of
refactorings to another source code and another chain of
refactorings. Conceptually, our enhanced refactoring,
Enhanced , is the pair of a classic refactoring transformation,
, with another transformation, , that changes subsequent
refactorings in a chain:
 : Ref actorings ! Ref actorings
Enhanced ¼< ;  > :

ð2Þ

Enhanced
i

Composing an enhanced refactoring with another re-
factoring changes the second refactoring:
; j ¼< i ; i > j ¼ i ; ði ðj ÞÞ:
Each  transformation is dependent upon the type of
enhanced refactoring from which it is a part. For instance, a
Ren transformation applied on a move refactoring changes
the parameters of the move refactoring:
(cid:2)
if i ¼ M ovðm ! pÞ
Renðm!kÞ ði Þ ¼ M ovðk ! pÞ
if i ¼ M ovðz ! pÞ:
M ovðz ! pÞ
Applying Ren on an empty chain of refactorings is
equivalent to applying an identity function:
Þ ¼ Ren :
ð½ Þ ¼ Ren ; Ren ð½ Þ
ð
Enhanced
Ren
Given a chain C ¼ ½i ; iþ1 ; . . . ; k , applying a  trans-
formation on the whole chain C incorporates the effect of
the renaming into the whole chain:
Þ ¼
Ren ½i ; iþ1 ; . . . ; k 
ð
Þ; . . . ; ðRen k Þ
Ren ði ÞÞ; ðRen ðiþ1 Þ
ð
ð
Þ:
The presence of  transformations elegantly solves cases
when multiple refactorings affect the same program element.
Revisiting our motivating example, consider the composition
of two enhanced refactorings, a rename ð6 Þ and a move
method ð1 Þ, that change the same program element,
PrintServer.getPacketInfo. Each enhanced refactor-
ing is decomposed into the classic refactoring and its
 transformation. Suppose that the rename method is applied
first. The enhanced rename method refactoring changes the
arguments of the subsequent move method so that the move
method refactoring operates upon the new name of the
method, PrintServer.getPacketInformation.

5 CONTROLLED EXPERIMENT

We want to evaluate the effectiveness of MolhadoRef in
merging compared to the well-known text-based CVS. For
this, we need to analyze source code developed in parallel
that contains both edits and refactorings. Software devel-
opers know about the gap between existing SCM reposi-
tories and refactorings tools. Since developers know what to

330

IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 34, NO. 3, MAY/JUNE 2008

TABLE 1
Demographics of the Participants

avoid, notes asking others to check in before refactorings
are performed are quite common. Therefore, it is unlikely
that we will find such data in source code repositories. As a
consequence, we designed a controlled experiment.

5.1 Hypotheses
Operation-based merging has intuitive advantages over
text-based merging since it is aware of the semantics of
change operations. We hypothesize that operation-based
merging is more effective than text-based merging. Namely,
MolhadoRef:

. H1 automatically solves more merge conflicts,
. H2 produces code with fewer compile-time errors,
. H3 produces code with fewer runtime errors,
. H4 requires less time to merge
than CVS.

5.2 Experiment’s Design
We wanted to recreate an environment, similar to the
regular program maintenance, where developers add new
features, run regression test suites, and make changes in the
code base in parallel. However, we wanted an environment
where software developers did not know and worry about
other people working on the same code base. We randomly
split 10 software developers into two groups, G1 and G2,
each group containing five developers. Each developer in
group G1 was asked to implement feature ACK, while each
developer in group G2 implemented feature MAX_HOPS.
All developers were given the same starting code base. At
the end, we took their code, stored it in both CVS and
MolhadoRef, and merged their changes using Eclipse’s CVS
client and MolhadoRef.

5.2.1 Demographics
We asked 10 graduate students at UIUC to volunteer in a
software engineering controlled experiment. We were speci-
fically looking for students who 1) had extensive program-
ming experience, 2) had extensive Java programming
experience, and 3) were familiar with the Eclipse develop-
ment environment. Table 1 shows the distribution of our
sub ject population. Most sub jects had some previous
industry experience, two of them were active Eclipse
committers, another one was a long-time industry consultant.
We asked the subjects not to work for more than 1 hour.
For participating in the study, the subjects were rewarded
with a free lunch. During the study, the subjects did not
know who the other participants were or what we were
going to do with their code. We told them to implement the
task as if this was their regular development job. When we
got back their solutions, their implementations were not at
all similar.

5.2.2 Tasks
Each subject received the initial implementation of the LAN
simulation used in our motivating example, along with a
passing JUnit test case that demonstrated how to instantiate
the system. The system was packaged as an Eclipse project;
therefore, the subjects had to use the Eclipse development
environment. Along with the system, the subjects received a
one-page document describing the current state of the
system and the new feature they had to implement. We
asked them to write another JUnit test case that exercises
the feature they just implemented. We also gave them the
freedom to change the current design if they did not like it
by using the automated refactorings supported in Eclipse.
However, only the feature and adding a test case were
mandatory; refactoring was optional.
Task ACK required the subject to change the LAN
simulation so that when a destination node received a
packet, it sends an Acknowledgement packet back to the
sender. The Acknowledgement packet should have its
contents set to “ACK.”
Task MAX_HOPS required the subject to fix a problem.
In the current implementation, the Packet may keep on
traveling forever if the destination node does not exist. To
solve the problem, if a Packet has been traveling around
long enough without being consumed by any Node, then it
gets dumped/eaten up. “Long enough” represents the
maximum number of nodes that a Packet is allowed to
visit and this needs to be specified by the user.

5.2.3 Variables
Controlled variables. All subjects used Eclipse and Java.
Sub jects started from the same version and had to
implement one of the two tasks. All mergings were done
by users expert in CVS and MolhadoRef.
Independent variables. Merging with MolhadoRef and
merging with CVS.
Dependent variables. Time spent to perform the mer-
ging,
the number of conflicts that cannot be solved
automatically, the number of compile and runtime errors
after merging.

5.3 Experimental Treatment
Now that we had real data about code developed in
parallel, we wanted to merge implementations of ACK and
MAX_HOPS into a code base that would contain both
features. We used CVS text-based merging as the control
group to test whether operation-based merging (with
MolhadoRef) is more effective.
After we gathered all of the solutions implemented by
the subjects, we created pairs as the cross product among
the two groups of tasks (five solutions for task ACK, five
solutions for task MAX_HOPS, resulting in 25 pairs). Each
pair along with the base version of the LAN simulation
forms a triplet. For each such triplet, we committed the
source code in both CVS (using the Eclipse CVS client) and
MolhadoRef. We first committed the base version, then
checked it out in two different Eclipse projects, replaced the
code in the checked out versions with the code for the
MAX_HOPS and ACK tasks,
then we committed the
version containing the MAX_HOPS task (no merging was
needed here), followed by committing the version contain-
ing the ACK task (merging was needed here).

DIG ET AL.: EFFECTIVE SOFTWARE MERGING IN THE PRESENCE OF OBJECT-ORIENTED REFACTORINGS

331

TABLE 2
Effectiveness of Merging with CVS versus MolhadoRef

By not asking the subjects to do the merging, we
prevented them from knowing the goal of our study so
that they would not make subjective changes that could
sabotage the outcome of merging. At the same time, we
eliminated one of the independent variables that could
affect the outcome of merging, namely their experience on
merging with CVS or MolhadoRef. Instead, the first and
second authors (who were both experts with CVS and
MolhadoRef) did all of the mergings. To eliminate the
memory effect, we randomized the order in which pairs
were merged.
Table 2 shows the results of merging with Eclipse’s CVS
client versus MolhadoRef.

5.4 Statistical Results
After applying analysis of variance (ANOVA) using the
Paired Student’s t-test and Fisher’s test, we were able to reject
the null hypotheses and accept H1 (MolhadoRef automati-
cally solves more conflicts), H2 (MolhadoRef produces fewer
compile errors), and H4 (it takes less time to merge with
MolhadoRef), at a significance level of  ¼ 1%. We were not
able to reject the null hypothesis for H3 (MolhadoRef
produces fewer runtime errors) at  ¼ 1% level.

5.5 Threats to Validity
Construct validity. One could argue why we chose number
of merge errors and time to merge as the indicators for the
quality of merging. We believe that a software tool should
increase the quality of the software and the productivity of
the programmer. Compile and runtime errors both measure
the quality of the merged code. The number of conflicting
blocks indirectly measures how much of the tedious job is
taken care of by the tool, while the time to merge directly
measures the productivity of the programmer.
One could also ask why we did all of the merging
ourselves instead of using the subjects. We wanted to avoid
confusing the effect of the tool with the experience of the
person operating the tool. We were experts with both CVS
and MolhadoRef, whereas our subjects would not have any
experience with MolhadoRef. In addition, the subjects did
not know that their solutions would be merged. This way,
we simulated an environment where the kinds of changes
are not limited by whether or not they can be easily merged,
but where programmers have absolute freedom to improve
their designs.
Internal validity. One could ask whether the design of
the experiment and the results truly represent a cause-and-
effect relationship. For instance, since we were the only
ones who merged subjects’ solutions,
the repetition of

experiments could have influenced the results. To eliminate
the memory effect, we randomized the order in which we
merged pairs of solutions. In addition, we split the merging
tasks into several clusters, separated by several days.
Another question is whether the person who merged with
MolhadoRef was better at merging than the person who
merged with CVS. Before doing the merging experiment,
we tried a few cold-run merging experiments and both
persons involved in merging (the first and second authors)
had the same productivity.
External validity. One could ask whether our results are
applicable and generalizable to a wider range of software
projects. We only used one single application and the input
code developed in parallel was produced using Eclipse and
Java. Maybe by using IDEs that do not feature refactorings,
the programmers will make fewer refactorings. Although
the presence of refactorings conveniently integrated within
an IDE can affect the amount of refactoring, we noticed
cases when subjects refactored manually. In addition, Java
is a popular programming language and Eclipse is widely
used to develop Java programs.
The subjects of our experiment were all graduate
students. On one hand, this is an advantage because the
subject demographics are relatively homogeneous. On the
other hand, use of students limits our ability to generalize
the results to professional developers. However, a careful
look at Table 1 shows that the subjects had reasonable
experience, most of them had worked in industry before
coming to graduate school. Notably, two of them had
several years of professional consulting and programming
experience.
Reliability. The initial base version along with the
students’ solutions can be found online [17], so our results
can be replicated.

6 CASE STUDY

We also conducted a case study to further evaluate the
effectiveness of MolhadoRef. We used MolhadoRef to merge
its own source code. Most of the development of MolhadoRef
was done by two programmers in a pair-programming
fashion (two people at the same console). However, during
the last three weeks, the two programmers ceased working on
the same console. Instead, they worked in parallel; they
refactored and edited the source code as before. When
merging the changes with CVS, there were many same-line
conflicts. It turned out that a large number of them were
caused by two refactorings: One renamed a central API class
LightRefactoring to Operation, while the other moved
the API class LightRefactoring to a package that
contained similar abstractions.
When merging the same changes using MolhadoRef, far
fewer conflicts occur. Table 3 presents the effectiveness of
merging with CVS versus MolhadoRef. Column “conflicts”
shows how many of the changes could not be automatically
merged and require human intervention. For CVS, these are
changes to the same line or block of text. For MolhadoRef,
these are operations that cannot be automatically incorpo-
rated in the merged version because they would have
caused compile or runtime errors. The next columns show
how many compile-time and runtime errors are introduced
by each SCM.

332

IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 34, NO. 3, MAY/JUNE 2008

TABLE 3
Effectiveness of Merging with CVS versus MolhadoRef

The f irst
rows show how many conf l icts cou ld not be so lved
automatically and required user intervention. The next rows show the
number of compile and runtime errors after merging with each system.
The last rows present the total time (including human and machine time)
required to merge and then fix the merge errors.

Table 3 shows that MolhadoRef was able to automati-
cally merge all 36 same-line conflicts reported by CVS.
MolhadoRef asked for user assistance only once, namely
when both developers introduced method getID() in the
same class. MolhadoRef did not introduce any compile-time
or runtime errors, while CVS had 48 such errors after
“successful” merge. In addition, it took 105 minutes for the
two developers to produce the final correct version using
CVS, while it takes less than 2 minutes to merge with
MolhadoRef.

7 DISCUSSION

Our approach relies on the existence of logs of refactoring
operations. However,
logs are not always available. To
exploit the full potential of record and replay of refactor-
ings, we developed RefactoringCrawler [12] to automati-
cally detect the refactorings used to create a new version.
These inferred refactorings can be fed into MolhadoRef
when recorded refactorings are not available.
Although one might expect that circular dependences
would require a lot of manual editing, in practice such
dependences are rare. Circular dependences can be elimi-
nated manually by deleting some of the operations in the
cycle or automatically by inverting refactorings (as seen in
Fig. 6) or by the enhanced refactorings (Step #5). The
enhanced refactorings eliminate dependences between
refactorings that change the same program elements since
these refactorings can be replayed in any order.
Our merging algorithm discriminates between refactor-
ings and API edits. Although both of these operations have
semantics that can be easily inferred by tools, MolhadoRef
inverts and replays refactorings only, not API edits (although
API edits’ semantics are taken into account during conflict
detection). Conceptually, API edits can be treated the same
way in which MolhadoRef currently treats refactorings.
There are two reasons why MolhadoRef treats them
differently. First, API edits are harder to invert than
refactorings since API edits are not behavior-preserving.
Inverting an AddAPIMethod by removing the method would
invalidate all of the edits that refer to the new method (e.g.,
method call sites). To fix this would require also inverting the
code edits (e.g., removing the call sites that refer to new
method). Second, API edits do not have the same global effect

as the API refactorings because only one user (e.g., the one
who introduced the new method) would be aware of the new
API, leading to fewer cases of same-line conflicts than when
refactorings are involved. Since there are far fewer benefits
from inverting and replaying API edits, we decided to treat
them like code edits.
MolhadoRef is built on top of the Molhado object-oriented
SCM infrastructure [7], which was developed for creating
SCM tools. Molhado is a database that keeps track of history.
MolhadoRef translates Java source code (all Java 1.4 syntax is
supported) into Molhado structures. At the time of check-in,
MolhadoRef parses to the level of method and field
declaration and creates a Molhado counterpart for each
program element. The method/field bodies are stored as
attributes of the corresponding declarations. For each entity,
Molhado gives a unique identifier. When refactorings change
different properties of the entities (e.g., names, method
arguments), MolhadoRef updates the corresponding Molha-
do entries. Nevertheless, the identity of program entities
remains intact even after refactoring operations (for a detailed
description on implementation, see [14] and [10]).
Can such a refactoring-aware SCM system be imple-
mented on top of a traditional SCM that lacks unique
identifiers? We believe that, with enough engineering, the
features of MolhadoRef can be retrofitted on a system like
CVS. To retrieve the history of refactored elements, it is
important to keep a record of unique identifiers associated
with program elements. Identifier-to-name maps can be
saved in metadata files and stored in the repository along
with the other artifacts. At each check-out operation, the
MolhadoRef CVS client needs to load these metadata files
into memory so that they can be updated as the result of
refactoring operations. At each check-in operation, these
files are stored back into the repository.
Limitations of MolhadoRef. One obvious limitation is
that our approach requires that the SCM be language-
specific. However, we do not see this as a limitation but as a
trade-off: We are intentionally giving up generality for
gaining more power. This is no different from other tools
used in software engineering,
for example,
IDEs are
language-specific (along with all of the tools that make up
an IDE, e.g., compilers, debuggers, and so forth), refactoring
tools are all language-specific.
Second, adding support in MolhadoRef for a new kind of
refactoring entails adding several cells in the conflict and
dependence matrices, describing all combinations between
the new operation and all existing operations. This can be a
time-consuming task. We discovered that new cells tend to
reuse predicates from earlier cells, which makes them easy
to implement. Cells requiring new predicates are still time-
consuming to implement. Third, the correctness of the
system depends on the correctness of formulas in the
conflict and dependence matrices. However, we carefully
revisited those formulas. In addition, multiple experiments
and more experience using our system can help empirically
test the correctness of those formulas.
An alternative to the manual derivation of predicates is
the analytical approach, like the one proposed by Kniesel
and Koch [16]. However, this requires a formal model of
refactoring preconditions. Since the current refactoring
engines (including Eclipse’s)
lack such formalism,
this
entails implementing a whole new refactoring engine. We

DIG ET AL.: EFFECTIVE SOFTWARE MERGING IN THE PRESENCE OF OBJECT-ORIENTED REFACTORINGS

333

chose instead to build upon a mature and thoroughly tested
engine like Eclipse’s.

8 RELATED WORK

SCM systems have a long history [18], [19]. Early SCM
systems (e.g., CVS [20]) provided versioning support for
individual files and directories. In addition to version
control, advanced SCM systems also provide more power-
ful configuration management services. Subversion [21]
provides more powerful features such as versioning for
metadata, properties of files, renamed or copied files/
directories, and cheaper version branching. Similarly,
commercial SCM tools still focus on files [19]. Advanced
SCM systems also provide fine-grained versioning support
not only for programs but also for other types of software
artifacts. Examples include COOP/Orm [22], Coven [23],
POEM [24], Westfechtel’s system [25], Unified Extensional
Versioning Model [26], Ohst et al.’s fine-grained SCM
model [27], and so forth. However, none of them handle
refactorings as MolhadoRef does.
Software merging. According to Mens [13], software
merging techniques can be distinguished based on how
software artifacts are represented. Text-based merge tools
consider software artifacts merely as text (or binary) files. In
RCS and CVS [20], lines of text are taken as indivisible units.
Despite its popularity, this approach cannot handle two
parallel modifications to the same line well. Only one of the
two modifications can be selected, but they cannot be
combined. Darcs [28] is a system rising in popularity, based
on a unique algebra of patches. Darcs does not associate any
semantics to a patch: A patch is just a series of textual
changes. Darcs can only find out that two patches depend
on each other if they affect the same portions of text.
However, due to inheritance and method overriding in OO
code, patches can affect each other, even when they are not
lexically near each other.
Syntactical merging is more powerful
than textual
merging because it takes the syntax of software artifacts
into account. Unimportant conflicts such as code comment
or line breaks can be ignored by syntactic merger. Some
syntactic merge tools focus on parse trees or abstract syntax
tree [29], [30], [31]. Others are based on graphs [32], [33].
However, they cannot detect conflicts when the merged
program is syntactically correct but semantically invalid. To
deal with this, semantic-based merge algorithms were
developed. In Wesfetchtel’s context-sensitive merge tool
[25], an AST is augmented by the bindings of identifiers to
their declarations. More advanced semantic-based merge
algorithms [34], [35], [36] detect behavioral conflicts using
dependency graphs, program slicing, and denotational
semantics.
Operation-based merging. The operation-based ap-
proach has been used in software merging [5], [32], [37],
[38], [39]. It is a particular flavor of semantic-based merging
that models changes between versions as explicit operations
or transformations. The operation-based merge approach
can improve conflict detection and allows better conflict
solving [13]. Lippe and van Oosterom [5] describe a
theoretical framework for conflict detection with respect
to general transformations. No concrete application for
refactorings was presented. Edwards’ operation-based
framework detects and resolves semantic conflicts from

application-supplied semantics of operations [37]. GINA
[40] used a redo mechanism to apply one developer’s
changes to the other developer’s version. The approach has
problems with long command histories and finer granular-
ity of operations. The departure point of MolhadoRef from
existing approaches is its ability to handle the merging of
changes that involve both refactoring and textual editing .
Similarly to MolhadoRef, Ekman and Asklund [41]
present a refactoring-aware versioning system. Their
approach keeps the program elements and their IDs in
volatile memory, thus allowing for a short-lived history of
refactored program entities. In our approach, program
elements and their IDs are modeled in the SCM and stored
throughout the life cycle of the project, allowing for a global
history tracking of refactored entities. In addition, their
system does not support merging.
As described, fine-grained and ID-based versioning have
been proposed before by others. However, the novelty of
this work is the combination of semantic-based fine-grained
ID-based SCM to handle refactorings and high-level edit
operations. To the best of our knowledge, we are presenting
the first algorithm to merge refactorings and edits. The
algorithm is implemented and the first experiences are
demonstrated.

9 CONCLUSIONS AND FUTURE WORK

Refactoring tools have become popular because they allow
programmers to safely make changes that can affect all
parts of a system. However, such changes create problems
for the current SCM tools that operate at the file level:
Refactorings create more merge conflicts, the history of the
refactored program elements is lost, and understanding of
program evolution is harder.
We have presented a novel SCM system, MolhadoRef,
that
is aware of program entities and the refactoring
operations that change them. MolhadoRef uses the opera-
tion-based approach to record (or detect) and replay
changes. By intelligently treating the dependences between
different operations, it merges edit and refactoring opera-
tions effectively. In addition, because MolhadoRef is aware
of the semantics of change operations, a successful merge
does not produce compile or runtime errors.
This research is part of our larger goal to upgrade
component-based applications to use the latest version of a
component by replaying the component refactorings [4],
[12]. The upgrading tool needs to handle refactorings and
edits not only on the component side but also on the
application side. This is a special case of the more general
merging case presented in this paper and, therefore, we will
apply the same merge algorithm.
We believe that the availability of such semantics-aware
refactoring-tolerant SCM tools will encourage programmers
to be even bolder when refactoring. Without the fear that
refactorings are causing conflicts with others’ changes,
software developers will have the freedom to make their
designs easier to understand and reuse.
The reader can f ind screenshots and down load
MolhadoRef from its Web page [17].

334

IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 34, NO. 3, MAY/JUNE 2008

ACKNOWLEDGMENTS
The authors would like to thank Darko Marinov, Don
Batory, Frank Tip, John Brant, Jeff Overbey, Brett Daniel,
Nicholas Chen, Mathieu Verbaere, Steve Berczuk, and the
anonymous reviewers for their insightful comments on
different drafts of this paper. D. Dig would also like to
thank IBM for an Eclipse Innovation Grant and the
University of Illinois Urbana-Champaign Computer Science
Department for an Outstanding Mentoring Fellowship. This
paper is an extended version of a conference paper [1].

[9]

[3]

REFERENCES
[1] D. Dig, K. Manzoor, R. Johnson, and T.N. Nguyen, “Refactoring-
Aware Configuration Management
for Object-Oriented Pro-
grams,” Proc. 29th Int ’l Conf. Software Eng., pp. 427-436, 2007.
[2] M. Fowler, K. Beck,
J. Brant, W. Opdyke, and D. Roberts,
Refactoring: Improving the Design of Existing Code. Adison-Wesley,
1999.
S. Berczuk, Software Configuration Management Patterns: Effective
Teamwork, Practical Integration, private conversations with SCM
consultant, Steve Berczuk, author, Addison-Wesley, 2002.
[4] D. Dig and R. Johnson, “How Do APIs Evolve? A Story of
Refactoring,” J. Software Maintenance and Evolution, vol. 18, no. 2,
pp. 87-103, 2006.
[5] E. Lippe and N. van Oosterom, “Operation-Based Merging,” Proc.
Fifth Symp. Software Development Environments, pp. 78-87, 1992.
[6] Eclipse Foundation, http://eclipse.org, 2008.
[7] T.N. Nguyen, E.V. Munson, J.T. Boyland, and C. Thao, “An
Infrastructure for Development of Object-Oriented, Multi-Level
Configuration Management Services,” Proc. 27th Int’l Conf. Soft-
ware Eng., pp. 215-224, 2005.
[8] W. Miller and E.W. Myers, “A File Comparison Program,”
Software, Practice and Experience, vol. 15, no. 11, pp. 1025-1040,
1985.
S. Demeyer, F.V. Rysselberghe, T . Gıˆrba,
J. Ratzinger, R.
Marinescu, T. Mens, B.D. Bois, D. Janssens, S. Ducasse, M. Lanza,
M. Rieger, H. Gall, and M. El-Ramly, “The LAN-Simulation: A
Refactoring Teaching Example,” Proc. Int’l Workshop Principles of
Software Evolution, pp. 123-134, 2005.
[10] D. Dig, T. Nguyen, and R. Johnson, “Refactoring-Aware Software
Configuration Management,” Technical Report UIUCDCS-R-2006-
2710, Univ. of Illinois Urbana-Champaign, Apr. 2006.
[11] What’s New in Eclipse 3.2 (JDT), http://help.eclipse.org/help32/
index.jsp?topic=/org.eclipse.jdt.doc.user/whatsNew/jdt_whats
new.html, 2008.
[12] D. Dig, C. Comertoglu, D. Marinov, and R. Johnson, “Automatic
Detection of Refactorings in Evolving Components,” Proc. 20th
European Conf. Object-Oriented Programming, pp. 404-428, netfiles.
uiuc.edu/dig/RefactoringCrawler, 2006.
[13] T. Mens, “A State-of-the-Art Survey on Software Merging,” IEEE
Trans. Software Eng., vol. 28, no. 5, pp. 449-462, May 2002.
[14] D. Dig, K. Manzoor, R. Johnson, and T. Nguyen, “Refactoring-
Aware Configuration Management System for Object-Oriented
Programs,” Technical Report UIUCDCS-R-2006-2770, Univ. of
Illinois Urbana-Champaign, Sept. 2006.
[15] T.H. Cormen, C.E. Leiserson, R.L. Rivest, and C. Stein, Introduction
to Algorithms, second ed., pp. 549-552. MIT Press and McGraw-
Hill Books, 2001.
[16] G. Kniesel and H. Koch, “Static Composition of Refactorings,”
Science of Computer Programming, vol. 52, nos. 1-3, pp. 9-51, 2004.
[17] MolhadoRef Web page, https://netfiles.uiuc.edu/dig/Molhado
Ref, 2004.
[18] R. Conradi and B. Westfechtel, “Version Models for Software
Configuration Management,” ACM Computing Surveys, vol. 30,
no. 2, pp. 232-282, 1998.
[19] CM Yellow Pages, http://www.cmcrossroads.com/, 2008.
[20] T. Morse, “CVS,” Linux J., vol. 1996, no. 21es, p. 3, 1996.
[21] “Subversion,” http://subversion.tigris.org/, 2008.
[22] B. Magnusson and U. Asklund, “Fine-Grained Revision Control of
Configurations in COOP/Orm,” Proc. Sixth Software Configuration
Management Workshop, pp. 31-48, 1996.

[33]

[30]

[23] M.C. Chu-Carroll,
J. Wright, and D. Shields, “Supporting
Aggregation in Fine Grained Software Configuration Manage-
ment,” Proc. Foundations of Software Eng., pp. 99-108, 2002.
[24] Y.-J. Lin and S.P. Reiss, “Configuration Management with Logical
Structures,” Proc. 18th Int’l Conf. Software Eng., pp. 298-307, 1996.
[25] B. Westfetchtel, “Structure-Oriented Merging of Revisions of
Software Documents,” Proc. Third Int’l Workshop Software Config-
uration Management, pp. 68-79, 1991.
[26] U. Asklund, L. Bendix, H. Christensen, and B. Magnusson, “The
Unified Extensional Versioning Model,” Proc. Ninth Software
Configuration Management Workshop, pp. 100-122, 1999.
[27] D. Ohst, M. Welle, and U. Kelter, “Differences between Versions
of UML Diagrams,” Proc. Foundations of Software Eng., pp. 227-236,
2003.
[28] “Darcs SCM,” http://darcs.net/, 2008.
[29] U. Asklund, “Identifying Conflicts during Structural Merge,” Proc.
Nordic Workshop Programming Environment Research, pp. 231-242,
1994.
J.E. Grass, “CDIFF: A Syntax Directed Differencer for C++
pp. 181-194, 1992.
Programs,” Proc. Usenix C +
+ Conf.,
[31] W. Yang, “How to Merge Program Texts,” The J. Systems and
Software, vol. 27, no. 2, pp. 129-135, 1994.
[32] T. Mens, “A Formal Foundation for Object-Oriented Software
Evolution,” PhD dissertation, Vrije Univ. Brussels, 1999.
J. Rho and C. Wu, “An Efficient Version Model of Software
Diagrams,” Proc. Fifth Asia Pacific Software Eng. Conf., pp. 236-243,
1998.
[34] V. Berzins, “Software Merge: Semantics of Combining Changes to
Programs,” ACM Trans. Programming Languages and Systems,
vol. 16, no. 6, pp. 1875-1903, 1994.
J.W. Hunt and T.G. Szymanski, “A Fast Algorithm for Computing
Longest Common Subsequences,” Comm. ACM, vol. 20, no. 5,
pp. 350-353, 1977.
[36] W. Yang, S. Horwitz, and T. Reps, “A Program Integration
Algorithm that Accommodates Semantics-Preserving Transforma-
tions,” ACM Trans. Software Eng. Methodology, vol. 1, no. 3, pp. 310-
354, 1992.
[37] W. Edwards, “Flexible Conflict Detection and Management in
Collaborative Applications,” Proc. 10th Ann. ACM Symp. User
Interface Software and Technology, pp. 139-148, 1997.
[38] A. Lie, R. Conradi, T.M. Didriksen, and E.-A. Karlsson, “Change
Oriented Versioning in a Software Engineering Database,” Proc.
Second Int’l Workshop Software Configuration Management, pp. 56-65,
1989.
[39] H. Shen and C. Sun, “A Complete Textual Merging Algorithm for
Software Configuration Management Systems,” Proc. 28th Ann.
Int’l Computer Software and Applications Conf., pp. 293-298, 2004.
[40] T. Berlage and A. Genau, “A Framework for Shared Applications
with a Replicated Architecture,” Proc. Sixth ACM Symp. User
Interface Software and Technology, pp. 249-257, 1993.
[41] T. Ekman and U. Asklund, “Refactoring-Aware Versioning in
Eclipse,” Electronic Notes in Theoretical Computer Science, vol. 107,
pp. 57-69, 2004.

[35]

Danny Dig received the BS and MS degrees in
computer science from the “Politehnica” Uni-
versity of Timisoara, Romania, where he built
JavaRefactor (the first open-source refactoring
engine for Java), and the PhD degree in
computer science from the University of Illinois
at Urbana-Champaign in 2007. He is a post-
doctoral associate at the Massachusetts Insti-
tute of Technology. He is particularly interested
in program transformations, automated refactor-
ing, design and architectural patterns, and broadly interested in software
reuse, software development processes, and software evolution. He is
currently doing research on refactorings that increase the parallelism of
existing sequential code. He served as the program and conference
chair of the First Workshop on Refactoring Tools (2007).

DIG ET AL.: EFFECTIVE SOFTWARE MERGING IN THE PRESENCE OF OBJECT-ORIENTED REFACTORINGS

335

Kashif Manzoor received the BS degree in
computer systems engineering from Ghulam
Ishaq Khan Institute of Engineering Sciences
and Technology, Topi, Pakistan, in 1997 and
the MS degree in computer science from the
University of
Illinois at Urbana-Champaign in
2007. He is currently a director of profes-
sional services at Techlogix. His research
interests include refactoring, design patterns,
process improvement, and software develop-

ment methodologies.

Ralph Johnson received the BA degree from
Knox College in 1977 and the PhD degree in
computer science from Cornell University in
1987. He is a research associate professor at
the University of Illinois at Urbana-Champaign.
the four coauthors of Design
He is one of
Patterns and the leader of
the group that
developed the Smalltalk Refactoring Browser,
the first refactoring tool. He is currently working
on a tool for refactoring Fortran and for helping
programmers tune their Fortran programs for new parallel architectures.
He is a member of the IEEE Computer Society.

Tien N. Nguyen received the PhD degree in
computer science from the University of Wis-
consin in 2005. He is an assistant professor in
the Electrical and Computer Engineering De-
partment at Iowa State University. His software
engineering expertise is in the areas of version
control and configuration management, software
maintenance and evolution, and program analy-
sis. His research work on semantics-based
configuration management and collaborative
supports has produced Molhado, the first object-oriented configuration
management
infrastructure, which has been successfully used in
several projects. He is a member of the IEEE.

. For more information on this or any other computing topic,
please visit our Digital Library at www.computer.org/publications/dlib.

focus
s o f t w a r e   p a t t e r n s
Organizing 
Security Patterns

Lessons  
learned  from  
the  organ iza t ion  
of  secur i ty  pa t terns
can  he lp  peop le
tr y ing  to  organ ize
pa t terns  for  o ther
doma ins .

Munawar Hafiz, Paul Adamczyk, and Ralph E. Johnson, University of Illinois
E arly  software  systems  communicated  in  predefined  ways,  so  they
were  easy  to  secure. However,  the  old  ways  of  ensuring  software
systems’ security and reliability are inadequate on the Internet. Al-
though building secure systems is difficult, retrofitting existing sys-
tems  to  introduce  security  is  even  harder.  For  example,  sendmail,  the  most
popular  mail  transfer  agent,  has  been  plagued  with  security  vulnerabilities
ever  since  the Morris worm  first exploited  it  in 1988.1 Since  then,  sendmail
developers  have  addressed  each  new  vulner-
appropriate category. Good organization also fa-
ability  by  following  the  “penetrate  and  patch”
cilitates  cross-referencing  between  related  pat-
paradigm. But  new  patches  often  open  new  se-
terns,  because  patterns  that  provide  alternative
curity  holes.  Because  attackers  constantly  un-
solutions  to  similar  problems  are  grouped  to-
ravel new security vulnerabilities, security archi-
gether,  letting  users  find  a  pattern  that  solves
tects  find  it  difficult  to  anticipate  new  attacks
their  particular  problem  more  easily.  Good  or-
proactively.
ganization  includes  guidelines  for  finding  re-
Security  patterns  are  one  way  of  collecting
lationships  and  applying  patterns  sequentially.
and  disseminating  security  knowledge.  Pattern
Pattern organization also aims  to help users na-
writers  have  introduced  many  security  pattern
vigate through interrelated patterns.
collections  recently  (see  the  “Related  Work  on
Researchers have  used  several  schemes  for
Security  Patterns”  sidebar).  But  the  sheer  num-
organizing  their  chosen  subset  of  security  pat-
ber  of  existing  security  patterns  makes  it  diffi-
terns,  but  none  of  these  approaches  have  suc-
cult for pattern users to find the most appropri-
ceeded in organizing all such patterns. Here we
ate solution.
explore  various  security  pattern  classification
Proper pattern organization  can benefit both
schemes.  We  analyze  current  approaches  and
pattern writers and pattern users. One aspect of
use  their  shortcomings  to chart a  roadmap  to-
ward  an  alternative  pattern  organization. Our
pattern  organization  is  classification—that  is,
grouping patterns into small, correlated sets. Pat-
approach can also apply to classifying software
tern  writers  can  then  place  new  patterns  in  the
patterns from other domains.

5 2

I E E E   S O F T W A R E Published by the IEEE Computer Society

0 7 4 0 - 7 4 5 9 / 0 7 / $ 2 5 . 0 0   ©   2 0 0 7   I E E E

Related Work on Security Patterns

Joseph Yoder and Jeffrey Barcalow wrote the first article
on security patterns in 1997.1 Others subsequently made se-
curity pattern catalogs either individually2–4 or through for-
mal5 and informal6 collaboration. Recently, the following three
books on security patterns have been published. 
Christopher Steel, Ramesh Nagappan, and Ray Lai’s Core
Security Patterns, published in October 2005, covers archi-
tectural security patterns for Java 2 Enterprise Edition–based
applications, Web services, and identity management.7 Their
book presents the fundamentals of Java application security
and documents 23 security patterns.
Markus Schumacher and his working group published
Security Patterns: Integrating Security and Systems Engineer-
ing in December 2005.8 It  includes 46 security patterns  from
the domains of enterprise security and risk management,
identification and authentication, access control, accounting,
firewall architecture, and secure  Internet applications. 
Microsoft’s Patterns and Practices group published a secu-
rity patterns book to accompany the release of Web Services
Enhancement 3.0 in March 2006.9 This book is a tutorial for
using WSE 3.0 in Web services development. It  lists 18 pat-
terns that address authentication, message protection, trans-
port and message  layer security, resource access, service
boundary protection, and service deployment. It describes all
these patterns from the perspective of Microsoft technology.
The PatternShare Web site was a single repository for de-
scribing all kinds of software patterns. One of PatternShare’s
goals was to develop a uniform vocabulary for practitioners
by combining patterns that differ only by their names into
one pattern. The PatternShare repository of security patterns
summarized the security patterns from various sources and
eliminated overlaps. We were maintaining this repository
while Microsoft managed PatternShare as a whole. Microsoft

transferred the ownership of PatternShare to the Hillside group
in early 2007. At present, the PatternShare Web site is down
for maintenance. However, the comprehensive security pattern
repository is available from https://netfiles/uiuc.edu/mhafiz/
www/ResearchandPublications/Patternshare_Security_Patterns.
htm. Currently,  the repository contains 90 unique security
patterns.
New security vulnerabilities are exposed daily. The prob-
lems uncovered by  these vulnerabilities and  the solutions de-
veloped  to combat  them will add many more security pat-
terns to developers’ arsenal of secure software systems in the
years to come.

References
J. Yoder and J. Barcalow, “Architectural Patterns for Enabling Applica-
1.
tion Security,” Proc. 4th Conf. Pattern Languages of Programs (PLoP
97), 1997, http://jerry.cs.uiuc.edu/plop/plopd4-submissions/P60.doc.
2. S. Romanosky, Security Design Patterns Part 1, 2001; www.cgisecurity.
com/lib/securityDesignPatterns.html.
3. M. Hafiz, “A Collection of Privacy Design Patterns,” Proc. 13th Conf.
Pattern Languages of Programs (PLoP 06), 2006, http://hillside.net/
plop/2006/Papers/Library/PLoP2006_mhafiz0_0.pdf.
4. M. Hafiz, “Security Architecture of Mail Transfer Agents,” master’s
thesis, Univ. of  Illinois at Urbana-Champaign, 2005.
5. B. Blakley and C. Heath, Security Design Patterns Technical Guide—
Version 1, Open Group, 2004; www.opengroup.org/security/gsp.htm.
6. D.M. Kienzle et al., “Security Patterns Repository, Version 1.0,” 2002,
www.modsecurity.org/archive/securitypatterns/dmdj_repository.pdf.
7. C. Steel, R. Nagappan, and R. Lai, Core Security Patterns: Best Prac-
tices and Strategies for J2EE, Web Services, and Identity Manage-
ment, Prentice Hall, 2005.
8. M. Schumacher et al., Security Patterns: Integrating Security and Sys-
tems Engineering, John Wiley & Sons, 2005.
J. Hogg et al., Web Service Security: Scenarios, Patterns, and Imple-
mentation Guidance for Web Services Enhancements (WSE) 3.0, 
Microsoft Press, 2006.

9.

Steps in organizing patterns
Any  organization  effort  must  begin  by  col-
lecting  the  items  to be organized. The “Related
Work” sidebar describes several security pattern
sources.  Currently,  these  patterns  are  indepen-
dent collections with no single classification.
The  second  step  of  pattern  organization  is
eliminating  overlaps  between  pattern  catalogs.
Because  catalogs  are  developed  independently,
many  authors describe  the  same or  similar  con-
cepts  but  give  them  different  names.  Overlaps
between patterns become evident only when you
put the patterns together.
For example, several catalogs have described
authentication  patterns.  In  their  security  pat-
terns book, Markus Schumacher and his work-

ing group list the Authenticator pattern, which
is essentially a policy enforcement point. Sasha
Romanosky  describes  the  same  pattern  under
the  name  Security  Provider.  Darrell  Kienzle
and  Matthew  Elder’s  security  patterns  reposi-
tory lists this pattern as Authenticated Session.
Christopher  Steel  and  his  colleagues  describe
the  same  pattern  from  the  perspective  of  Java
tools;  they  name  the  pattern  Authentication
Enforcer. The Microsoft security patterns book
describes  authentication  in  terms  of  various
strategies  supported  by  the  Web  Services  En-
hancements  3.0  framework.  (See  the  “Related
Work” sidebar for further discussion and refer-
ences to these works.) It describes two patterns:
Direct Authentication and Brokered Authenti-

July/August 2007 I E E E   S O F T W A R E

5 3

Security pattern
Authenticator
Authorization
Checkpointed System

Defense  in Depth
Exception Shielding

Grey Hats

Minefield

Table 1
Summary of security patterns
used in our comparisons
Intent
Verify the subject’s  identity
Define the access policy for resources
Design the system as a state machine that retains the 
state  information
Add security checks  in multiple  layers of the application
Sanitize unsafe exceptions with exceptions that are safe by
design (exceptions that don’t reveal sensitive  information 
such as detailed error code and stack trace)
Have testers plan and execute attacks on the system 
to test  its security
Introduce variations when  implementing well-known 
security aspects of standard components
Centralize management of synchronizing user credentials 
across different application systems via programmatic
interfaces 
Concentrate  identification, authentication, and 
authorization mechanisms at one point
Replicate components to distribute workload
Include the  length  information of the memory buffer 
and check  it before allocation
Run preforked processes for a  limited time
Define a single entry point for the system
Describe attributes of the subject  in a data structure

Password Synchronizer

Policy Enforcement Point

Replicated System
Safe Data Buffer

Secure Preforking
Single Access Point
Subject Descriptor

cation.  The  latter  is  divided  even  further  into
different  authentication  strategies,  described
in  separate  patterns—Brokered  Authentica-
tion:  Kerberos;  Brokered  Authentication:
X509  PKI;  and  Brokered  Authentication:  Se-
curity  Token  Service.  Because  they  all  repre-
sent the same type of solution to a problem in
a  shared  context,  they  should  be  documented
as one pattern.
The  third  step  is  to  define  (or  use  an  exist-
ing) categorization that splits patterns into dis-
joint sets. Initial attempts aimed to organize se-
curity  patterns  within  a  single  catalog.  Most
schemes choose partitions  that are  too general
to be useful. For example, the Open Group cat-
alog  classifies  patterns  into  two  groups  based
on applicability: patterns for protected systems
and patterns for available systems. Kienzle and
his colleagues also use two categories:

■ structural patterns, which describe how to
implement the software; and 

5 4

I E E E   S O F T W A R E www.computer.org/software

■ procedural patterns,  which  describe  how
to improve the development process. 

In  this  scheme,  Grey  Hats  is  a  procedural
pattern because it explains how to set up a test-
ing  environment  that  most  closely  resembles
the conditions of  the system under security at-
tack. However, almost all known  security pat-
terns are structural—for example, 84 of the 90
patterns  from  our  security  pattern  repository
( h t t p s : / / n e t f i l e s . u i u c . e d u / m h a f i z / w w w /
ResearchandPublications/Patternshare_Security_
Patterns.htm)  are  structural.  This  disparity
makes Kienzle  and  colleagues’  classification
scheme infeasible for large pattern collections.
Although these schemes work for their respec-
tive catalogs, they aren’t rich enough to use in
organizing all security patterns.
Ideally,  the  organization  scheme  should  be
as  comprehensive  as  the  biological  taxonomy,
the  efficacy  of  which  comes  from  the  metrics
used  to  create  the partitions. But what  are  the
appropriate  metrics  for  partitioning  the  secu-
rity  patterns?  Some  ideas  come  from  the  defi-
nition of pattern—“a solution  to a problem  in
a  context.”  More  elaborate  pattern  organiza-
tion  schemes  use  these  key  elements—domain
concepts, the context, or the problem solved by
the  pattern—as  the  classification  metric.  We
describe classification schemes on the basis of

■ domain  concepts such  as  confidentiality,
integrity, and availability (the CIA model),
the fundamental concepts of security2; 
■ context,  including  application  context  (the
part of the system where a pattern is applied)
as  well  as stakeholders  and  their  viewpoints
(John Zachman’s tabular classification frame-
work3 and its extensions); and
■ problem domain, or threat model.

To illustrate different organization schemes,
we apply one set of patterns to all the schemes
we discuss. Table 1  shows  the 14  security pat-
terns we chose randomly from our comprehen-
sive security pattern repository. The “Safe Data
Buffer Pattern”  sidebar  shows a complete pat-
tern description.

Using domain concepts: The CIA model
The  simplest  classification  approach  is  to
identify the fundamental concepts in a domain
(the  CIA  model  in  this  case)  and  use  them  to
create the partition.

Safe Data Buffer Pattern

The  following pattern appeared  in Munawar Hafiz’s master’s  thesis, “Security Architecture of
Mail Transfer Agents” (see  the “Related Work” sidebar).

Context
You’re designing a system  in a programming  language  that doesn’t have built-in array
bounds checking.

Problem
Buffer overflow occurs when a process attempts to store data beyond the boundary of a fixed-
length buffer. This problem is caused by bad programming practice. If every buffer-handling routine
checked allocated memory and operated within the memory’s bounds, buffer overflow wouldn’t oc-
cur. In practice, the buffer-handling routines don’t handle these tasks. An attacker exploiting a
buffer overflow can execute arbitrary code and take complete control of the operating system.
How can you design buffers that don’t have this vulnerability?

Forces

■ Programmers often use programming languages that don’t check for buffer bounds (such as C).
■ Programmers  can prevent buf fer over flow by  checking buf fer bounds ever y  time  they
write a buf fer-handling  routine, but  they  instead  call  the  librar y  functions without  check-
ing preconditions.
■ Buffer-handling  library  functions don’t check  for buffer bounds.

Solution
Represent  the buffer with a data structure  that  includes  length and allocated memory  infor-
mation.  In all buffer-handling routines, check  for  length and available memory before updating
the data buffer.

Example
The mail server qmail, which is written in C, has a custom-written string  library. Strings aren’t
null-terminated; instead, they’re encapsulated in a structure named stralloc. This data structure
keeps the string buffer’s  length information. All string-manipulation functions check whether the
input data fits the buffer before attempting to update the buffer.
The  following data structure contains buffer  information  for a string:

typedef struct stralloc {

char *s;          // pointer to the string or 0 if unallocated

unsigned int len;  // length of the buffer, in bytes

unsigned int a;   // count of allocated bytes in the string 

}

Confidentiality,  integrity,  and  availability
have  overlapping  concerns,  so  when  you  par-
tition  security  patterns  using  these  concepts 
as classification parameters, many patterns fall
into  the  overlapping  regions.  Consider  the
Replicated  System  pattern:  it  increases  a  sys-
tem’s  availability  by  replicating  service  (or
data).  The  redundancy  also  improves  data  in-
tegrity. So  this pattern  lies  in  the  region where

integrity and availability overlap.
Table  2  shows  the  classification  based  on
the CIA model. This classification scheme isn’t
concrete  enough—five  patterns  belong  to
more than one category, and three patterns ap-
ply  to  all  categories.  Moreover,  most  of  the
patterns fall into one category: confidentiality.
However, this classification scheme has one
important  advantage—it  uses  widely  known,

July/August 2007 I E E E   S O F T W A R E

5 5

Category
Confidentiality

Table 2
Security pattern classification 
based on the CIA model
Pattern names
No. of patterns in category
Authenticator
7
Authorization
Exception Shielding
Policy Enforcement Point
Secure Preforking
Single Access Point
Subject Descriptor
Safe Data Buffer
Checkpointed System
Password Synchronizer
Replicated System
Defense  in Depth
Minefield
Grey Hats 

1
1
2

3

Integrity
Availability
Integrity and availability

Confidentiality,  integrity,
and availability

Table 3
Security pattern classification 
based on application context
Pattern names
No. of patterns in category
Checkpointed System
6
Exception Shielding
Minefield
Safe Data Buffer
Secure Preforking
Subject Descriptor
Authenticator
Authorization
Policy Enforcement Point
Single Access Point
Password Synchronizer
Replicated System
Defense  in Depth
Grey Hats

4

2

2

Category
Core security

Perimeter security

Exterior security

All

fundamental  security  concepts  to  create  the
partition.  Classification  schemes  should  use
existing terminology whenever available.

Using simple application context
Pattern writers often begin by describing the
context—when  and  where  to  apply  a  pattern.
Pattern  users  are  familiar  with  the  context  in
which they’re applying a pattern. So, anyone in-
terested in patterns typically understands a clas-
sification scheme based on pattern context.

5 6

I E E E   S O F T W A R E www.computer.org/software

We  can  compare  a  system  architecture with
a  secure military  base’s  structure.  In  a military
base,  security  mechanisms  are  installed  at  the
base’s entry point and around its perimeter. An-
other  level  of  security  mechanisms  is  installed
deep  inside  the  base,  where  the  critical  infra-
structure  exists.  Logistics  communication  be-
tween military bases is also secured. Similarly, a
simple  classification  based  on  the  application
context  classifies  the  security  patterns  accord-
ing to the part of the system they’re trying to se-
cure—application  core,  application  perimeter,
or application exterior:

■ Core security  patterns  consider  the  secu-
rity mechanisms inside a system. 
■ Perimeter security  patterns  consider  the  au-
thentication,  authorization,  and  security-
filtering-related issues at system entry points. 
■ Exterior security patterns deal with secure
data  transmission  and  communication
protocols. 

Table  3  summarizes  the  security  patterns
classification based on application context.
With  this  classification  scheme,  users  can
easily  assign  the  concrete  patterns  to  a  single
category. However, they can’t use it to classify
the  more  general  patterns—Defense  in  Depth
and  Grey  Hats,  for  example—because  they
impact all three areas: core, perimeter, and ex-
terior  security.  In  addition,  most  patterns  fall
into  the  core  security  category,  and  this
scheme  prevents  separating  the  patterns  into
smaller, more cohesive subgroups.

Using the Zachman framework for context
The  security  pattern  classification  efforts
we’ve discussed so far rely on a flat partitioning
scheme.  More  complex  classification  schemes
are  based  on  the  Zachman  framework.3 In-
spired  by  the  different  documents  produced
during  different  phases  of  building  develop-
ment, Zachman  identified  five  types  of  specifi-
cations  that  different  stakeholders—the  cus-
tomer, system architect, designer, developer, and
module developer—use during the software de-
velopment process. These five viewpoints com-
prise  five  rows  in  the  tabular Zachman  frame-
work.  The  table’s  columns  represent  the
concerns  in  terms  of  six  interrogatives:  data
(what),  function  (how),  network  (where),  peo-
ple (who), time (when), and motivation (why).
David  Trowbridge  and  his  colleagues  at 

Microsoft  developed  a  tabular  classification
scheme  based  on  the  Zachman  framework  for
all patterns4 (table 4 shows 11 of the 14 patterns
classified according to this scheme). This scheme
retains  the  2D  tabular  space  but  divides  each
row into smaller groups based on the IEEE 1471
architectural  standard  description.5 This  multi-
dimensional classification scheme has more cat-
egories,  allowing  more  specific  classification.
Trowbridge and his  colleagues added a  seventh
column (the “Test” column) to include the soft-
ware debugging concern.
This  classification  scheme  clearly  identifies
each pattern’s context, making pattern naviga-
tion easier. Users can find patterns in the table
using  context  as  the  key.  This  classification
scheme  also  helps  users  identify  missing  pat-
terns.  For  example,  if  a  pattern  is  defined  in
one  context  but  the  user  is  looking  for  that
pattern in a different context, a similar pattern
probably  could  be  documented  for  that  con-
text, and these two patterns are likely related.
Security patterns tend to fit many system de-
velopment  roles  (many  rows  in  the  table)  and
many  interrogatives (many columns). This tab-
ular  approach  is  more  successful  in  classifying
functional  patterns  because  these  patterns  cor-
respond better  to  system development perspec-
tives  and  interrogatives. Hence,  one  cell  in  the
table  can  express  their  scope.  Nonfunctional
quality  attributes  (such  as  security  or  perfor-
mance) are orthogonal to the aspects covered in
the table and can’t be contained in a single cell. 
Patterns  such  as  Minefield  and  Defense  in
Depth can’t be assigned to a single cell. In fact,
Defense in Depth’s broad context places it in all
of  the  table’s  rows  and  columns.  The  Autho-
rization pattern should also be placed in multi-
ple  cells  because  it’s  applicable  to  the  roles  of
both  architect  and  designer  (and  perhaps  even
developer).
Another sign that the tabular scheme is un-
successful in pattern classification is the table’s
skewness—that  is,  patterns  are  concentrated
in particular cells. Our comprehensive security
pattern  repository  lists  90  security  patterns.
Of  these,  63  are  in  the  function  column.
Among  the  14  candidate  patterns  in  our  run-
ning  example,  10  belong  in  the  function  col-
umn  (including Minefield, Authorization, and
Defense  in  Depth—the  three  patterns  not
shown  in table 4). This  is because most of the
software  patterns  provide  a  mechanism  to
achieve some functionality. Any pattern classi-

Table 4
Security pattern classification 
based on Microsoft’s classification scheme*
Function
Stakeholder
Test
Data 
Checkpointed System
Architect
Policy Enforcement 
Point
Replicated System
Secure Preforking
Single Access Point
Authenticator
Password 
Synchronizer

Exception Shielding
Subject Descriptor

Application
architecture

Designer

Developer

Safe Data Buffer

Grey Hats

*Partial view of the table

fication  scheme  that  considers  function  as  a
separate aspect will be skewed.
However,  skewness doesn’t  rule out  a  clas-
sification scheme. After all, the biological clas-
sification  scheme  for  animals  is  heavily
skewed toward the phylum Arthropod, which
includes more than three-fourths of all known
living and  fossil organisms. However,  the ani-
mal  kingdom’s  taxonomy  is  hierarchical  and,
from  phylum  to  species,  provides  fine  granu-
larity  of  classification.  The  organizing  table
doesn’t illustrate this hierarchy.
The  application  of  the  tabular  classification
scheme  to  security  patterns  shows  that  the  pat-
tern’s context isn’t an effective classification met-
ric. It also shows that multidimensional schemes
aren’t necessarily better than flat ones.

Using the problem domain
The  tabular  classification  scheme  based
on  the  Zachman  framework,  like  the  classi-
fication  based  on  domain  concepts,  fails  to
account for general patterns spanning multi-
ple categories. In search of a more appropri-
ate  scheme,  we  tried  classifying  patterns
based  on  the  problems  they  solve. We  parti-
tioned the security pattern problem space us-
ing the threat model. A classification process
based  on  threat  modeling  is  more  intuitive
because it uses the security problems that the
patterns  solve.
Security  architects  use  threat  modeling  to
identify  and  prioritize  a  system’s  security  vul-
nerabilities. This lets them prioritize the mitiga-
tion  effort.  Researchers  have  proposed  several
frameworks for threat modeling—for example,

July/August 2007 I E E E   S O F T W A R E

5 7

Table 5
Security pattern classification 
based on the STRIDE model
Pattern names
No. of patterns in category
Authenticator
3
Password Synchronizer
Subject Descriptor
Checkpointed System
Safe Data Buffer
Single Access Point
Authorization
Exception Shielding
Replicated System
Secure Preforking
Defense  in Depth
Minefield
Policy Enforcement Point
Grey Hats

1
1
4

3

2

Category
Spoofing

Tampering

Information disclosure

Denial of service
Elevation of privilege
All

the  STRIDE model.6 STRIDE is  an  acronym  con-
taining the following concepts:

■ Spoofing is an attempt  to gain access  to a
system using a  forged  identity. A compro-
mised system would give an unauthorized
user access to sensitive data.
■ Tampering is  data  corruption  during  net-
work communication, where the data’s in-
tegrity is threatened.
■ Repudiation is a user’s refusal to acknowl-
edge participation in a transaction.
■ Information disclosure is  the  unwanted
exposure  and  loss  of  private  data’s 
confidentiality. 
■ Denial of service is  an  attack  on  system
availability. 
■ Elevation of privilege is an attempt  to raise
the  privilege  level  by  exploiting  some  vul-
nerability,  where  a  resource’s  confidential-
ity, integrity, and availability are threatened.

Table  5  classifies  the  candidate  security
patterns based on  the  STRIDE model. Not  sur-
prisingly,  this  scheme  also  fails  to  include  all
the patterns.
Four patterns—Defense in Depth, Minefield,
Policy Enforcement Point, and Grey Hats—ap-
ply to all the STRIDE model’s security concepts.
By  now,  it  should  be  obvious  that  regard-
less of the classification scheme, some patterns
will always belong to multiple categories. This
is the distinguishing characteristic of the more

5 8

I E E E   S O F T W A R E www.computer.org/software

abstract patterns that present a guiding princi-
ple  rather  than  a  precise  solution.  These  pat-
terns are refined by more concrete patterns. 
Like the previous schemes, the STRIDE-based
scheme  doesn’t  solve  the  key  classification  is-
sue—how  to  classify  patterns  that  straddle
multiple  categories.  STRIDE-based  classification
is  one-dimensional.  Of  all  the  schemes  we’ve
discussed  so  far,  the  tabular  scheme  has  the
most  unique  categories  because  it’s  multi-
dimensional.  Adding  more  dimensions  to
STRIDE should solve this problem. 
We  combined  STRIDE-based  classification
with another one-dimensional scheme, the sim-
ple  application  context  (from  table  3).  Classi-
fying  patterns  from  both  the  problem  and  the
context  perspectives  creates  a  better  partition.
The  resulting  partition  puts  almost  every  pat-
tern  in  its  own  cell  but  still  fails  to  properly
separate  others.  (Rather  than  showing  the  re-
sulting  table,  we  will  refine  it  further  in  the
next  section.)  Although  we  can  separate  pat-
terns that apply to a single application context,
such as Minefield (application core) and Policy
Enforcement Point (application perimeter), the
most  general  patterns—in  our  example,  De-
fense  in  Depth  and  Grey  Hats—don’t  fit  this
scheme.  These  general  patterns  can’t  fit  any
scheme that treats all patterns equally.

Adding hierarchy to classification
Biologists  solved  the  organization  problem
with  taxonomies.  A  taxonomy  is  a  classifica-
tion  of  things  and  the  principles  underlying
the  classification. The biological  classification
organizes  its  concepts  in  a  hierarchy—that  is,
a  tree  in which  the  root  node  provides  a  gen-
eral concept, which each descendant refines. 
Adding  a  hierarchical  taxonomy  system  to
a  flat  partitioning  scheme  lets  us  place  some
patterns  higher  in  the  hierarchy.  With  a  hier-
archical  scheme,  we  can  partition  patterns
along  several  dimensions,  based  on  context,
problem, and pattern generality.
Figure  1  illustrates  our  proposed  classifica-
tion of the 14 patterns. We ascertain the classi-
fication  tree’s  nodes  on  the  basis  of  domain-
specific  vocabulary.  This  makes  pattern  navi-
gation easier and more meaningful. The classifi-
cation scheme based on the STRIDE model alone
is  limited,  because  patterns  that  address multi-
ple  concepts  can’t  be  classified  using  a  flat
scheme.  With  a  hierarchical  scheme,  the  pat-
terns need not be only at the tree’s leaf. Patterns

Security pattern space {Defense in Depth, Grey Hats}

Core security patterns
{Minefield}

Perimeter security patterns
{Policy Enforcement Point}

Exterior security
patterns

S poofing {Subject Descriptor}

S poofing {Authenticator}

S poofing {Password Synchronizer}

Tampering {Checkpointed System, Safe Data Buffer}

Tampering {Single Access Point}

R epudiation

R epudiation

Tampering

R epudiation

Information disclosure {Exception Shielding}

Information disclosure {Authorization}

Information disclosure

D enial of service, or DoS

D oS

E levation of privilege {Secure Preforking}

E levation of privilege

D oS {Replicated System}

E levation of privilege

Figure 1. Classification of security patterns using a tree.

in  the  internal nodes are at a higher  level  than
those  in  the  leaf;  they  address multiple  threats
of  the  STRIDE model.  For  example,  the  Policy
Enforcement Point pattern addresses spoofing,
tampering,  information  disclosure,  and  denial
of  service.  Patterns  at  the  tree’s  root  apply  to
multiple  contexts  (core,  perimeter,  and  exte-
rior).  General  patterns,  such  as  Defense  in
Depth,  reside  at  the  classification  hierarchy’s
highest level because they apply to all contexts.
Our  classification  scheme  uses  the  STRIDE
model  as  classification  criteria  in  all  the
branches.  This  is  different  from  the  biological
taxonomy, where subgroups are divided differ-
ently.  For  example,  mammals  and  insects  are
classified  using  different  characteristics.  Mam-
mals  are  divided  into  the  canine  family,  feline
family,  primates,  rodents,  and  so  on.  Insects
have neither teeth nor bone and are divided into
families  based  on  wings,  mouth  parts,  anten-
nae, and so on. Our scheme is sufficient for cur-
rent classification, but future research might in-
troduce variation in the hierarchy.

Classification or navigation?
Classification  is  one  aspect  of  organization.
Classification  divides  patterns  into  small
groups. Within each group, patterns aren’t nec-
essarily related, but they share a common prob-
lem  domain  and  application  context.  Another
aspect  of  organization  is  navigation—the  abil-
ity to guide the reader between related patterns.
Well-organized  pattern  collections  describe  in-
terpattern relationships in greater detail. 
No  pattern  is  an  island.  Patterns  form  a
chain  in  which  each  pattern  is  derived  from
more general patterns and depends on the more
specific patterns it contains. One pattern creates
problems  that another  solves. One pattern cre-

Securing the 
access points 

Single
Access Point

Authorization

Protected
System
Enforcing
ingress and
egress policies

Policy
Enforcement
Point

Enforcing access 
control policy 
Enforcing
authentication
policies

Uses data 
for policy decisions 

Subject
Descriptor

Authenticator 

Uses identity 
description 

Distributed 
password 
management 

Password
Synchronizer

Figure 2. A pattern language describing the relationships among six
patterns. Patterns are shown as boxes, and relationships as arrows.
Other related patterns are hidden (indicated by dashes).

ates  the  context  for  another  pattern.  One  pat-
tern  solves  the  high-level  problem  and  another
solves lower-level problems. A pattern language
illustrates  such  relationships  between  patterns7
and helps pattern users apply the patterns.
To illustrate how a pattern language works,
we selected a portion of the 14 randomly cho-
sen candidate patterns. Collectively, they don’t
represent a true pattern language; however, six
of  the  14  patterns  are  associated  with  access
control.  Figure  2  shows  the  relationships  be-
tween them.
Let’s  look  at  some  examples  of  how  this
pattern language guides users. A user might be
interested  in  applying  patterns  to  secure  the
system perimeter. The user would need to min-
imize the access points (using the Single Access
Point pattern) and  then define guards at  these
points  (using  Policy  Enforcement  Point).  The
guards check  the  incoming and outgoing data
traffic based on the system’s ingress and egress
policies. Another user, interested in authoriza-

July/August 2007 I E E E   S O F T W A R E

5 9

About the Authors

Munawar Hafiz is a doctoral  candidate at  the University of  Illinois at Urbana-Cham-
paign. His  research  interests are  software architecture and design,  software patterns, and  se-
curity. He  received his MS  in  computer  science  from  the University of  Illinois at Urbana-
Champaign. Contact him at  the Siebel Center, 201 N. Goodwin Ave., Univ. of  Illinois at
Urbana-Champaign, Urbana,  IL 61801; mhafiz@uiuc.edu.

Paul Adamczyk is a doctoral candidate at the University of Illinois at Urbana-Champaign.
His research interests are software architecture and design, Web technologies, and software pat-
terns. He received his MS in computer science from the Illinois Institute of Technology. Contact him
at the Siebel Center, 201 N. Goodwin Ave., Univ. of Illinois at Urbana-Champaign, Urbana, IL
61801; padamczy@uiuc.edu.

Ralph Johnson is a research associate professor at  the University of  Illinois at Urbana-
Champaign. His research  interests  include object-oriented design, especially design patterns
and  the design of object-oriented frameworks. He and  the other members of  the Gang of
Four wrote Design Patterns: Elements of Reusable Object-Oriented Programming (Addison-
Wesley, 1995). He also helped organize  the original conference on pattern  languages of pro-
grams. He received his PhD  in computer science from Cornell University. He’s a member of
the  IEEE Computer Society and  the ACM. Contact him at  the Siebel Center, 201 N. Goodwin
Ave., Univ. of  Illinois at Urbana-Champaign, Urbana,  IL 61801;  johnson@cs.uiuc.edu.

for everyone is an even more difficult problem
than security pattern classification.
M any issues arise from organizing secu-
rity patterns. How they’re solved pro-
vides the following lessons for people
trying to organize patterns for other domains.
First, patterns should be classified in multi-
ple  dimensions—for  example,  context,  prob-
lem,  and  domain-specific  partitions.  Classifi-
cations based on a single metric can’t partition
the pattern space sufficiently. 
Second, arriving at a good scheme requires
iterative  refinement  of  the  classification.  Dif-
ferent  metrics  must  be  combined  to  find  the
most appropriate combinations.
Third,  related  patterns  often  form  well-
structured  relationships—for  example, hierar-
chies.  The  organization  scheme  should  pre-
serve such relationships between patterns.
Finally,  in  addition  to  classification,  navi-
gation  based  on  relationships  between  pat-
terns helps in better understanding the pattern
space.

tion,  would  find  that  the  definition  and  en-
forcement  of  access  control  policies  perform
the  authorization. These  policies  are  enforced
at the policy enforcement point. 
Yet another user might be  interested  in au-
thentication  only. This  user would  first  create
minimal  access  points  where  the  Authentica-
tor  pattern  will  enforce  authentication  poli-
cies.  The  subject  descriptor  defines  the  data
used to grant the authentication decision. The
Password  Synchronizer  pattern  performs  dis-
tributed  password  management.  Authentica-
tor and Password Synchronizer aren’t directly
related;  users  would  need  to  apply  other  pat-
terns after Authenticator before they could use
Password Synchronizer. The figure only shows
the  six  access  control  patterns  from  our  cho-
sen set of security patterns.
Creating a pattern language for all the secu-
rity patterns  is  a nontrivial  task. The  concepts
defining the relationships between security pat-
terns are selected ad hoc. So, a definition might
be useful for one group of users but completely
useless  for  others.  Finding  the  standard  rela-
tionship between patterns to enable navigation

6 0

I E E E   S O F T W A R E www.computer.org/software

2.

5.

3.

References
1. M.W. Eichin and J.A. Rochlis, “With Microscope and
Tweezers: An Analysis of the Internet Virus of Novem-
ber 1988,” IEEE Symp. Research in Security and Pri-
vacy, IEEE Press, 1989, pp. 326–343.
Information Technology Security Evaluation Criteria,
ver. 1.2, Commission of European Communities, 1991;
www.iwar.org.uk/comsec/resources/standards/itsec.htm.
J.A. Zachman, “A Framework for Information Systems
Architecture,” IBM Systems J., vol. 26, no. 3, 1987, pp.
276(cid:2)292. 
4. D. Trowbridge et al., “Describing the Enterprise Archi-
tectural Space,” MSDN, 2004; http://msdn2.microsoft.
com/en-us/library/ms978655.aspx.
IEEE Std. 1471-2000. IEEE Recommended Practice for
Architectural Description of Software Intensive Sys-
tems, IEEE, 2000.
6. F. Swiderski and W. Snyder, Threat Modeling, Microsoft
Press, 2004.
7. C. Alexander, S. Ishakawa, and M. Silverstein, A Pat-
tern Language, Oxford Univ. Press, 1977.

For more  information on this or any other computing topic, please visit our
Digital Library at www.computer.org/publications/dlib.

Refactoring-aware Conﬁguration Management for Object-Oriented Programs

Kashif Manzoor, Ralph Johnson
Danny Dig,
University of Illinois at Urbana-Champaign
{dig, manzoor2, rjohnson}@uiuc.edu

Tien N. Nguyen
Iowa State University
tien@iastate.edu

Abstract

Current text based Software Conﬁguration Management
(SCM) systems have trouble with refactorings. Refactor-
ings result in global changes and lead to merge conﬂicts.
A refactoring-aware SCM system reduces merge conﬂicts,
preserves program history better and makes it easier to un-
derstand program evolution. This paper describes Mol-
hadoRef, a refactoring-aware SCM system and the merge
algorithm at its core. MolhadoRef records change opera-
tions (refactorings and edits) used to produce one version,
and replays them when merging versions. Since refactor-
ings are change operations with well deﬁned semantics,
MolhadoRef treats them intelligently. A case-study shows
that MolhadoRef solves automatically more merge conﬂicts
than CVS while resulting in fewer merge errors.

1. Introduction

Refactorings are program transformations that improve
the internal design without changing the observable behav
ior [
15]
(e.g., renamings, moving methods between classes,
changing method signatures). Automated refactoring tools
have become very popular because they allow program-
mers to change source code quicker and safer than manu-
ally. However, refactoring tools make particular demands
on text-based SCM systems.
Traditional SCM systems work best with modular sys-
tems. Different programmers tend to work on different
modules and so it is easy to merge changes. But refactorings
cut across module boundaries and cause changes to many
parts of the systems. SCM systems signal a conßict when
two programmers change the same line of code even if each
just changes the name of a different function or variable.
So, SCM systems have trouble merging refactorings.
The state-of-practice process for refactoring on large
projects is for all developers to check in their code before
they leave for the weekend. The senior designer then makes
these global changes (e.g., API changes) and commits the
refactored code. Upon their return, developers check out

the refactored versions. However, this serializes the devel-
opment of code. In addition, by forcing refactorings to be
performed only by a few people at a certain time, opportu-
nities for refactoring are lost.
Although the number of global changes varies from sys-
tem to system, our previous study [9] of Þ
ve widely-used,
mature Java components, showed a signiÞcant number of
global changes. For instance, Struts had 136 API changes
over a period of 14 months. In each system, more than 80%
of the API changes were caused by refactorings. Because of
lack of support from SCM systems, these changes were te-
dious to incorporate manually, although a refactoring-aware
SCM could have incorporated them automatically.
Text-based SCM systems are unreliable. Since they sig-
nal merge conßicts only when two users change the same
line of code, even a successful merge might result in an in-
correct program. This is especially true in object-oriented
programs.
For instance,
if one user renames a virtual
method while another user adds a new method in a subclass,
even though these changes are not lexically near each other,
textual merging could result in accidental method overrid-
ing, thus leading to unexpected runtime behavior.
This paper describes MolhadoRef, a refactoring-aware
SCM that works for Java, and the merge algorithms at its
core. MolhadoRef has several important advantages over a
traditional text-based SCM:

1. Better merging.
MolhadoRef automatically resolves
more conßicts (even changes to the same lines of
code). Because it takes into account the semantics of
refactorings, the merging is also more reliable: there
are no compile errors after merging and the semantics
of the two versions to be merged are preserved with
respect to the refactoring operations.

2. Better preservation of program history. MolhadoRef
tracks the history of refactored program elements even
when they are renamed or moved to different Þles (e.g.,
when moving a method to a different class).

3. Better understanding of program evolution.
Some
refactoring operations (like renaming a popular public

29th International Conference on Software Engineering (ICSE'07)0-7695-2828-7/07 $20.00  © 2007-
method) may cause thousands of changes (e.g., updat-
ing all call sites) scattered throughout the code. By dis-
playing the evolution of code in terms of higher-level
operations (e.g., refactorings)
MolhadoRef hides the
complexity caused by the sheer amount of low-level
changes corresponding to refactorings.

Correct merging of refactorings and manual edits is not
trivial: edits can refer to old program entities as well as to
newly refactored program entities.
MolhadoRef uses the
operation-based approach [20]
, in other words it treats both
refactorings and edits as change operations that are recorded
and replayed. If all edits came before refactorings, it would
be easy to merge the two versions by Þrst doing a three-
way merging then replaying the refactorings. But edits and
refactorings are mixed, so we have to invert refactorings to
commute an edit and a refactoring. Moreover, refactorings
will sometimes have dependences between them.
MolhadoRef uses Eclipse as the front-end for changing
code and customizes Molhado [26]
, a framework for SCM
to store Java programs. Although the merging algorithm
is independent of the Molhado infrastructure and can be
reused with other SCM backends, building on top of an ID-
based SCM like Molhado allows our system to keep track
of the refactored entities. When evaluating MolhadoRef on
three weeks of its own development, we found that Mol-
hadoRef merges more safely and more automatically than
CVS while never losing the history of refactored entities.
MolhadoRef merges edits using the same three-way
merging of text-based SCMs.
It is when MolhadoRef
merges refactorings that it eliminates merge errors and un-
necessary merge conßicts. So the more that refactorings are
used, the more beneÞts MolhadoRef provides.
This paper makes the following contributions:
• without losing any power to merge manual edits, it
converts refactorings from being the weakest link in
an SCM system to being the strongest
• it presents the Þrst algorithm to effectively merge
refactorings and edit operations
• it describes the implementation of the algorithm and
evaluates the effectiveness of a refactoring-aware SCM
system on real world software

2. Motivating Example

To see the limitations of text-based SCM
, consider the
simulation of a Local Area Network (
LAN) used as a refac-
toring teaching example [7] in many european universities
(shown in Figure 1
).
Packet , a su-
Initially,
there are Þ
ve classes:
perclass LANNode and its subclasses PrintServer,

NetworkTester, and Workstation. All LANNode ob-
jects are linked to each other in a token ring network (
via
send or accept
the nextNode variable)
, and they can
PrintServer overrides accept to
a Packet object.
Packet.
A
achieve speciÞc behavior for printing the
Packet object sequentially visits every
LANNode object in
the network until it reaches its addressee.
Two users, Alice and Bob , start from version
V0 and
make changes. Alice is the Þrst to commit her changes,
thus creating version V1 while Bob creates version V2 .
Since method
only
accesses
getPacketInfo
Alice moves method
Packet ,
Þelds
from class
from class nodes.PrintServer
getPacketInfo
Next, she deÞnes a new
to content.Packet (τ 1 ).
sendPacket(Packet),
in class Network-
method,
( τ2 ).
The implementation of
this method is
Tester
empty because this method simulates a broken net-
work that loses packets.
In the same class, she also
deÞnes a test method, testLosePacket (τ 3 ) and im-
plements it to call method sendPacket (τ 4 ).
Lastly,
Alice
renames
WorkStation.originate(Packet)
to generatePacket(Packet) (τ 5 ). Alice Þnishes her
coding session and commits her changes to the repository.
In
parallel with Alice,
Bob
renames method
to
PrintServer.getPacketInfo(Packet)
getPacketInformation(Packet) (τ 6 ).
He also
renames the polymorphic method LANNode.send()
to sendPacket (τ 7 ).
Lastly,
Bob renames class
WorkStation to Workstation (different capitaliza-
tion τ8 ).
Before Bob can commit his changes, he must
merge his changes with AliceÕs.
A text-based SCM system signals conßicts only when
two users change the same line. For instance, because Alice
moved the declaration of method (τ 1 ) while Bob altered the
declaration location of the same method through renaming
(τ 6 )
, a textual merging could not successfully merge these
changes. This is an unnecessary merge conßict because
a tool that understood the semantics of the changes could
merge them.
In addition, because a text-based merging does not know
anything about the syntax and semantics of the program-
ming language, even a ÒsuccessfulÓ merge (e.g., when
there are no changes to the same lines of code) can re-
sult in a merge error. Sometimes errors can be detected
at compile-time. For instance, after textual merging, the
code in method testLosePacket does not compile be-
cause it calls methodsend whose declaration was replaced
by sendPacket through a rename ( τ7 ). Though tedious to
Þx, such an error is easy to catch.
Other errors result in programs that compile but have
unintended changes to their behavior. For instance, be-
cause Alice introduced a new methodsendPacket in sub-
class NetworkTester and Bob renames the polymorphic

29th International Conference on Software Engineering (ICSE'07)0-7695-2828-7/07 $20.00  © 2007,
,
Print Server. java

package nodes ;
import content.Packet ;

VERSION 

v0: A LAN Simulation Program
L A
Node. java

public class Print Server extends L A
public void print(Packet p) {
String packetInfo = getPacketInfo(p);
System.out.println(packetInfo);

Node {

}
public String getPacketInfo (Packet p) {

String packetInfo = p.originator + ": " +
  p.addressee+ "[" + p.contents + "]";

return packetInfo;

}
public void accept (Packet p) {
if (p.addressee == this) this.print(p);
else super.accept(p);

}

}
Network Tester. java

package nodes ;
import content.Packet ;

public class Network Tester extends L A
public void testSendToSelf() {
Packet packet = new Packet ();
packet.addressee = this;

Node {

packet.originator = this;
send (packet);

}
public void accept (Packet p) {
if (p.originator == this)
System.out.println("network works OK");
else super.accept(p);

}

}

VERSION 

v1 (Alice) 

Print Server. java

...
public class Print Server extends L A
public void print(Packet p) {
String packetInfo= p.getPacketInfo();
...
}
...

Node {

}
Network Tester. java
...
public class Network Tester extends L A
...
protected void sendPacket(Packet p){}

Node {

τ2

τ3

void test LosePacket(boolean losePacket) {
Packet packet = new Packet ();
packet.addressee = new L A
Node ();
packet.originator = this;
if (losePacket) sendPacket(packet);
τ4
else send(packet);

}

}
L A

Node. java
...
Work Station. java

...
public class Work Station extends L A
Node {
...
public void generatePacket (Packet p) { }
...
τ5

}
Packet. java
...
import nodes.Print Server ;

public class Packet {
...
public String getPacketInfo()
{

τ1

String packetInfo = originator + ": " +

  addressee + "[" + contents + "]";

return packetInfo;

}

}

package nodes ;
import content.Packet ;

public class L A
Node {
public String name;

public L A
Node nextNode;
public void accept (Packet p) {
this.send(p);

}
protected void send (Packet p) {
System.out.println(name + nextNode.name);
this.nextNode.accept(p);

}

}

Work Station. java

package nodes ;
import content.Packet ;
public class Work Station extends L A

Node {

public void originate (Packet p) {

p.originator = this;
this.send(p);

}

public void accept(Packet p) {

if (p.originator == this)

System.err.println("no destination");

else super.accept(p);

}

}

Packet. java

package content ;
import nodes.L A
Node ;

public class Packet {
public String contents;
public L A
Node originator;
public L A
Node addressee;

}

VERSION 

v2 (Bob)

Print Server. java

package nodes ;
import content.Packet ;

public class Print Server extends L A
public void print(Packet p) {
String packetInfo =
getPacketInformation(p);

Node {

System.out.println(packetInfo);

τ6
}
public String getPacketInformation(Packet p){

String packetInfo = p.originator + ": " +
  p.addressee+ "[" + p.contents + "]";

return packetInfo;

}
Network Tester. java
...
public class Network Tester extends L A
public void testSendToSelf() {
...
sendPacket(packet);

}

}

Node {

}
L A
Node. java
...
τ7
public class L A
Node {
...
protected void sendPacket(Packet p) {
System.out.println(name + nextNode.name);
this.nextNode.accept(p);

}

}
τ8
Workstation. java
...
public class Workstation extends L A
...

Node {

}
Packet. java
...

Figure 1. Motivating Example. Boxes show the changes in each version.

29th International Conference on Software Engineering (ICSE'07)0-7695-2828-7/07 $20.00  © 2007N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
method send to sendPacket, a textual merge results in
accidental method overriding. Therefore, the call inside
testSendToSelf to sendPacket uses the empty imple-
mentation provided by Alice( τ2 ) to simulate loss of packets,
while originally this method call used the implementation of
LANNode.send. Since this type of conßict is not reported
during compilation, the merged program contains bugs that
require many hours to Þnd.
Current SCM systems lose the history of refactored pro-
gram entities. For instance, once Alice moved method
getPacketInfo(Packet) from class PrintServer to
Packet , the history of the getPacketInfo is effectively
lost since a Þle-based SCM repository maintains the method
as if it is a newly deÞned method in the classPacket. Thus,
a Þle-based SCM tool could not help a developer understand
code evolution when program entities are refactored. .
Because there were so many refactorings in version V1
and V2 , it is hard for another developer who only saw ver-
sion V0 to understand the evolution of the code. A Þle-
based SCM is of less use in program understanding because
it ßoods the developer with all the low level changes that
happened betweenV0 and V2 .

3. Background and Terminology

Our approach to refactorings-tolerant SCM systems is
based on a different paradigm, calledoperation-based [20 ].
In the operation-based approach, an SCM tool records the
operations that were performed to transform one version
into another and replays them when updating to that ver-
sion. An operation-based system treats a version as the se-
quence of operations used to create it.
Our goal is to provide merging at the API level, that
is, our merging algorithm aims for a correct usage of all
the APIs. For this reason, we distinguish between oper-
ations that affect the APIs and those that do not.
Mol-
hadoRef treats a version as composed of the following three
operations: API refactorings, API edits, and code edits.
MolhadoRef handles the following API refactorings: re-
name package, rename class, rename method, move class,
move method, and changing the method signature (these
were among the most popular refactorings found in previ-
ous studies [9]
).
MolhadoRef handles the following
API
edits: added package, deleted package, added class, deleted
class, added method declaration, deleted method declara-
tion, added Þeld declaration, deleted Þeld declaration. Any
other types of edits are categorized ascode edits.
Code edits do not have well deÞned semantics, making
it difÞcult to merge them correctly. API edits have better
deÞned semantics. But refactorings are the operations with
the most well deÞned semantics, so the ones that can beneÞt
the most. Therefore,
MolhadoRef merges code edits textu-
ally and since it is aware of the semantics of refactorings

and API edits, it merges them semantically.
Any operation can be regarded as a function from pro-
grams to programs, more precisely, a source-to-source pro-
gram transformation: τ : P rogram− > P rogram
When necessary, we make the distinction between refac-
torings, represented with ρ and edits, represented withσ .
Refactorings are transformations that preserve the seman-
tics, while edits usually change the semantics of programs.
Operations usually have preconditions. Adding a method
to a class requires that the class exists and does not already
deÞne another method with the same name and signature,
while changing the name of a method requires the new name
inappropriately to a
is not in use. Applying an operationτi
program P results in an invalid program, represented by ⊥.
The result of applying an operation to⊥ is ⊥.
·

τ i

( P )

if preconditions ofτ i hold
P (cid:1)
⊥ if preconditions ofτ i do not hold

The application of two operations is modeled by the
function composition, denoted by “
; also models the
”.
; τj means Þrst apply τ i and then apply τ j on
precedence:τ i
the result:τ i
; τj
( P )
( τi
( P )
τj

Deﬁnition 1: Two operations commute on a program P if
applying them in any order produces the same valid pro-
gram PÓ:
(cid:1) ∧ P (cid:1)
= ⊥
P (cid:1)
; τi
( P )
τj

( P )

; τj

τi

Deﬁnition 2: Two operations conﬂict with each other if
applying them in any order produces an invalid program:
= ⊥ ∧ τi
= ⊥
; τi
( P )
; τj
( P )
τj

For instance, adding two methods with the same name
and signature in the same class results in a conßict.
DeÞnition 2 describes conßicts that produce compile er-
rors. MolhadoRef also catches some conßicts that produce
run-time errors. These conßicts always involve method
overriding, such as the accidental method overriding be-
tween τ2 and τ7 .
When two operations do not commute for a program P,
we say that there is anordering dependence between them.
We denote this ordering dependence with the≺ P
symbol.
( τ i ≺P

Deﬁnition 3: τj depends on τ i
τ i do not commute:
τ i ≺P
= ⊥ ∧( τi
iff τ i
; τj
( P )
τ j
The ≺ P
dependence isstrict partial order, that is, it is
irreßexive, antisymmetric and transitive.
An example of dependence is the renaming of method
WorkStation.originate to generatePacket() done
by Alice ( τ5 ) and the renaming of class WorkStation to

) if τj and

( P )

; τi

τ j

; τj

( P )

τj

29th International Conference on Software Engineering (ICSE'07)0-7695-2828-7/07 $20.00  © 2007=
(
1
)
;
=
)
=
=
(cid:1)
(cid:3)
(cid:3)
(cid:3)
=
)
Workstation done by Bob (
τ8 ). If τ8 is played Þrst, the
replaying of τ5 is not possible because at this time the fully
WorkStation.originate no longer ex-
qualiÞed name
ists, thus τ5 ≺P
τ8 .
This dependence betweenτ5 and τ8 exists because cur-
rent refactoring engines are based on the names of the pro-
gram entities, and classWorkStation no longer exists af-
ter replaying τ8 . If the refactoring engine used the IDs of
the program elements, scenarios in which the names of pro-
gram entities change would never pose a problem [
10]. To
make name-based refactoring engines be ID-based requires
rewriting the whole engine. This is unfeasible, so the next
best solution is toemulate ID-based engines.
To make the current name-based refactoring engines em-
ulate ID-based ones, there are at least two approaches.
The Þrst is to reorder the refactorings (e.g.,
rename
method WorkStation.originate() before rename class
WorkStation).
The second is to modify the refactor-
ing engine so that in addition to changing source code, it
also changes subsequent refactorings (e.g., during the re-
play of renaming class WorkStation to Workstation,
the refactoring engine changes the representation of rename
(WorkStation.originate, Work-
method refactoring RenM
Station.generatePacket)
to RenM
(Workstation.originate,
Workstation.generatePacket)
). Our merging algorithm uses
both approaches.

4. Merging Algorithm

4.1. High level overview

We illustrate the merging algorithm (see Fig. 2) using the
LAN simulation example presented earlier. The merging al-
gorithm takes as input three versions of the software: ver-
sion V0 is the base version and V1 and V2 are derived from
V0 . In addition, the algorithm takes as input the refactorings
that were performed inV1 and in V2 . These refactoring logs
are recorded by EclipseÕs refactoring engine.
Step #
1 detects the API and code edits through 3-way
differencing betweenV1 , V2 and V0 . In V1 it detects two
added methods, τ2 and τ3 , inV 2 it detects none.
Step #2 searches for compile and run-time conßicts in
API edits and refactorings. It detects a conßict betweenτ2
and the rename method refactoring,τ7 . This conßict reßects
an accidental method overriding. The conßict is presented
to the user who resolves it by choosing a different name
for the added method (in this case he choseslosePacket
instead of sendPacket). The algorithm also searches for
possible circular dependences between refactorings. If any
are found, the user deletes one of the refactorings involved
in cycle (in this example no circular dependence exist). This
process of detecting/solving continues until no more con-
ßicts or circular dependences remain.

INPUT = {V_2, V_1, V_0, refLog_2, refLog_1}
Operations refs= refLog_1 + refLog_2
Operations edits= detectEdits(V_2,V_1,V_0,refs) #1
repeat{
#2
{edits, refs}= userSolvesConflicts({edits, refs})
Graph refsDAG = createRefDependenceGraph(refs)
{refs, refsDAG} =
userEliminatesCircularDependences(refs, refsDAG)
} until noConflicsOrCircDependences(edits, refsDAG)
Version V_1_minusRef= invertRefactorings(V_1, refs) #3
Version V_2_minusRef= invertRefactorings(V_2, refs)
Version V_merged_minusRef=
#4
3-wayTextualMerge(V_2_minusRef, V_1_minusRef, V_0)
orderedRefs= topologicalSort(refsDAG)
#5
Version V_merged=
replayRefactorings(V_merged_minusRef, orderedRefs);
OUTPUT = {V_merged}

Figure 2. Overview of the merging algorithm

Step #3 inverts each refactoring in V1 and V2 by ap-
plying another refactoring. For instance, it inverts τ1 by
moving method getPacketInfo back to PrintServer,
and it inverts τ8 by renaming Workstation back to
WorkStation.
By inverting refactorings, all the edits
that were referencing the refactored program entities are
changed to refer to the old version of the entities. This
step produces two software components that contain all the
changes inV1 , respectively V2 , except refactorings.
Step #4 merges textually (using a modiÞed version of
the three-way merging [24]
) all the API and code edits
. Since the refactorings were pre-
and V (cid:21) Re f
from V (cid:21) Re f
1
2
viously inverted, all same-line conßicts that would have
been caused by refactorings are eliminated. For instance,
inside PrintServer.print there are no more same-line
conßicts. Therefore, textual merging of code edits can pro-
ceed smoothly. This step produces a software component,
.
called V (cid:21) Re f
merged
the refactorings that hap-
Step #5 replays on V (cid:21) Re f
merged
pened in V1 and V2 .
Before replaying, the algorithm re-
orders all the refactorings using the dependence relations.
Replaying the refactorings incorporates their changes into
which already contains all the edits. For in-
the V (cid:21) Re f
merged
stance, replaying a method renaming updates all the call
sites to that method that were introduced as edits.

4.2. Detecting Operations

Refactorings in versions V2 and V1 are recorded at the
time when they were performed by EclipseÕs [
12] new
refactoring engine.
If Eclipse did not have this record
feature,
refactorings could be inferred using Refactor-
ingCrawler [8].
To detect the API edits and code edits, the algorithm em-
ploys a three-way textual differencer (since two -way dif -
ferencer cannot distinguish between additions and dele-

29th International Conference on Software Engineering (ICSE'07)0-7695-2828-7/07 $20.00  © 2007tions [23]
Þles, and folders
). This differencer detects lines,
that were changed. From this low level information, the al-
gorithm constructs the higher level, API edits. Out of these
edits, the algorithm removes those created by refactorings.
Even though the scope of our merging is at the API level,
to correctly signal compile- or run-time conßicts, the algo-
rithm detects a few code edits that are below the API level.
These include add and delete method calls. For instance, if
Alice deletes the method declarationaccept and Bob adds
a method call toaccept , this results in a compile conßict.

4.3. Detection and Solving of Conﬂicts and
Circular Dependences

MolhadoRef detects conßicts between operations by us-
ing a matrix of predicates. For any two kinds of operations,
the matrix gives a predicate that indicates whether the oper-
ations conßict. This matrix includes refactorings, API edits,
and the code edits that are tracked.
For example, suppose τ i is RenameMethod(m 1 , m2 ) and
is RenameMethod(m 3 , m4 ). These two renamings result
τ j
in a conßict if (i) the source of both refactorings is the same
(e.g., m1 = m3 )
, or (ii) the destination of both refactoring is
the same (e.g., m2 = m4 ). Due to polymorphic overriding,
we must also consider the case when the source methods are
not in the same class, but one overrides the other.
When the source of both refactorings are the same (i)
if methods m1 and m3 are in the same class, there would
be a compile-time conßict since the users want to rename
the same method differently. If the methodsm1 and m3 are
overriding each other, renaming them differently results in a
run-time conßict because the initial overriding relationship
would be broken. When the destination of the two refac-
, if methods m1 and m3 are in the
torings is the same (ii)
same class, renaming them to the same name results in a
compile-time error (two methods having the same signature
and name). If methods m1 and m3 are not in the same class
and do not initially override each other, renaming them to
the same name results in a run-time conßict because of ac-
cidental method overriding.
FOPL formulae describing all possible combinations of
operations (both refactorings and edits) detected in step #
are in a companion tech report [
].
Circular Dependences. When there is an ordering de-
pendence between two operations, the algorithm choses the
correct order in which to replay the operations.
Initially,
there is a total order (or linear order) of the change opera-
tions in each version, given by the time sequence in which
these operations were applied. However, operations can be
replayed in any order, unless there is a dependence between
them, so that the total order can be ignored in favor of a
partial order, induced by the ≺P
relation.
To create this partial order, we represent each operation

as a node in a directed graph. Whenτ i ≺P
, the algo-
τ j
to τj . Next, the algo-
rithm adds a directed edge fromτ i
rithm searches for cyclic dependences. There can only be
cycles between operations from two users, not between op-
erations from the same user because for each user it was
initially possible to play all the operations. After it Þnds all
cycles, it presents them to the user who must choose how to
eliminate cycles. Although one expects that circular depen-
dences would require the user to do a lot of manual editing,
in practice such dependences occur very seldom. Assuming
that there are no more cycles, all operations are in a directed
acyclic graph (DAG
).
Circular depen-
User-assisted Conﬂict Resolution.
dences and compile and run-time conßicts require user in-
tervention. To break circular dependences, the user must
select operations to be discarded and removed from the se-
quence of operations that are replayed during merging. To
solve the conßicts caused by name collision, the user must
select a different name.
Once the users solves the conßicts,
the algorithm
searches again for conßicts. This sequence of Þnding con-
ßicts and solving conßicts is repeated until there are no
more conßicts. The algorithm always converges to a Þxed
point. Informally, this happens because during manual con-
ßict resolution the user keeps deleting conßicting opera-
tions, thus the total number of change operations keeps de-
creasing (in the worst case he can keep deleting change op-
erations until there are no more operations).

4.4. Inverting Refactorings

Step #3 makes a version of V1 and V2 without any refac-
torings by inverting all refactorings. Inverting a refactoring
ρ1 involves creating and applying an inverse refactoring. ρŠ
1
is an inverse of ρ1 if ρŠ
= P for all programs P that
1 ( ρ1 ( P )
meet the precondition ofρ1 .
There is an important distinction between what we mean
by inverting a refactoring and how the popular refactoring
engines (like Smalltalk RefactoringBrowser, Eclipse or In-
tellijIdea) undo a refactoring. To decrease memory usage
and avoid recomputations, the refactoring engines save the
location of all source code that was changed by the refac-
toring. When undoing a refactoring, the engines undo the
source changes of these locations.
This approach is not suitable for MolhadoRef. The only
way to undo a refactoring is to Þrst undo all the operations
that come after it.
MolhadoRef must be able to undo a
refactoring without undoing later operations. Thus Mol-
hadoRef inverts refactorings by creating and executing an
inverse refactoring operation (which is another refactoring).
Besides overcoming the drawbacks discussed above,
another important beneÞt is that inverting a refactor-
ing also changes the edits.
Recall the motivation ex-

29th International Conference on Software Engineering (ICSE’07)0-7695-2828-7/07 $20.00  © 2007,
1
1
1
)
ample where Bob renamed method getPacketInfo to
getPacketInformation and later he added a new
method call togetPacketInformation. By inverting the
rename method refactoring with the inverse refactoring (re-
naming getPacketInformation to getPacketInfo)
the new call site togetPacketInformation is updated
too, while keeping the call site in the same place. Deleting
the call site altogether would have introduced a different
behavior, while leaving the call site untouched would have
produced a compilation error.
Just as refactorings have preconditions,
inverting a
refactoring has preconditions too, and if those precon-
ditions are not met then a refactoring cannot be in-
verted.
We have some heuristics that handle such
cases by adding program transformations or storing addi-
tional information before inverting a refactoring. For in-
stance, if Bob renames PrintServer.getPacketInfo to
getPacketInformation and then adds a new method in
the same class calledgetPacketInfo, inverting the re-
name refactoring is not possible because of the newly intro-
duced method. The algorithm searches for potential name
collisions before inverting the refactoring, and executes an-
other refactoring to avoid the collision.
In this case, the
algorithm gives the newly introduced getPacketInfo a
unique name, and tags this rename refactoring. In step #5,
after all the regular refactorings have been replayed, the al-
gorithm inverts all refactorings marked with tags.
Consider the case when Bob changes the signature of a
method sendPacket by adding an extra argument of type
integer with a default value 0 to be used in method calls,
and later he adds a method call where he passes value 7.
Inverting the refactoring and redoing it naively would lose
the value 7 and replace it with value 0.
Before inverting
the refactoring, the merge algorithm saves the location of
the new call sites and the values of parameters so that it can
restore the same values later when replaying the refactoring.
When no heuristic for inverting a refactoring is found,
the algorithm treats the refactoring as a textual edit: the
refactoring is not inverted and replayed, but its code
changes are incorporated by textual merging. Although the
advantages of incorporating the semantics of the refactoring
are lost, the algorithm can proceed and in the worst case it is
as good as classic textual merging. The heuristics are good
enough to invert all the refactorings in the case studies.

4.5. Textual Merging

Once refactorings are inverted, all the edits in V1 and V2
that referred to the refactored APIs now refer to the APIs
present in version V0 . The algorithm merges textually all
Þles that were changed by edits using the three-way merg-
ing [24] that most text-based SCMs use.
All code changes inserted by refactorings that would

have caused same-line or same-block conßicts are elimi-
nated due to the fact that refactorings were previously in-
verted. For instance, although both users changed the dec-
laration of getPacketInfo, the call to this method inside
PrintServer.print no longer causes same-line conßict.
Still, if two users change the same lines by code ed-
its, this generates a same-line conßict.
If Alice and Bob
change the same lines in a Þle by API edits (e.g., each adds
a new method declaration)
MolhadoRef merges this auto-
matically using the semantics of API edits. In general, when
same lines are changed by edits, our algorithm is slightly
better than traditional text-based merging.
However, it is
when multiple refactorings affect the same lines that Mol-
hadoRef shines over text-based merging.

4.6. Replaying Refactorings

Current refactoring engines identify program entities
with fully qualiÞed names. Within a stream of operations
from a single version, names will always be consistent be-
cause a refactoring cannot use a name unless it is cur-
rent. But when refactorings are merged from two different
streams, there are two ways that renaming can interfere.
The Þrst is where the refactorings refer to two different
entities, but one of them has a name that includes the other.
For example, the fully qualiÞed name of a method includes
the name of its class. If one refactoring renames a class,
and the other changes a method in that class, it is important
that the right method gets changed. MolhadoRef solves this
problem by making sure that the refactorings to a method
are performed before the refactorings that rename its class.
More precisely,
MolhadoRef uses a topological sort algo-
rithm [6] to reorder the nodes in the refactorings DAG.
The second is where the refactorings refer to the same
entity. Sometimes this is a conßict that must be resolved
by the user, such as when the two refactorings change the
name of the same entity. This case will be resolved by step
#2. So, the only remaining cases are when the two refac-
torings change the same entity, but in different ways. For
example, one refactoring could rename a method, and the
other could move it to a new class (τ 6 , τ1 ). Changing either
the method name or the class name will invalidate the other
refactoring. Mohaldoref solves this problem by modifying
refactorings. If a refactoring from one version is replayed
after a rename or a Ómove methodÓ refactoring from the
other version, second refactoring is changed to use the new
name. This lets a name-based system like Eclipse emulate
an ID based system.

5. Implementation

Programming tools are more likely to be used when
they are conveniently incorporated in an Integrated Devel-

29th International Conference on Software Engineering (ICSE’07)0-7695-2828-7/07 $20.00  © 2007,
,
opment Environment (IDE) such as Eclipse. We imple-
mented an operation-based SCM as an Eclipse plugin,
Mol-
hadoRef. MolhadoRef uses the Eclipse Java programming
editor as the front end, and customizes Molhado frame-
work [26] to store Java programs. Molhado is an object-
oriented SCM infrastructure, which was developed for cre-
ating SCM tools. Essentially,
Molhado is a database that
keeps track of history.
MolhadoRef translates Java source code (all Java 1.4
syntax is supported) into Molhado structure. At the time
of check-in, it parses to the level of method and Þeld decla-
ration and creates a Molhado counterpart for each program
element that it parses. The method/
Þeld bodies are stored
as attributes of the corresponding declarations. For each
entity,
Molhado gives a unique identiÞer. When refactor-
ings change different properties of the entities (e.g., names,
method arguments)
MolhadoRef updates the correspond-
ing Molhado entries. Nevertheless, the identity of program
entities remains intact even after refactoring operations.
After code is checked in for the Þrst time, subsequent
Ôcheck-inÕs need to store only the changes from last check-
in.
In a pure operation-based SCM
, all the changes are
recorded when they happen and are stored as operations in
the SCM system. These operations are then replayed on the
source code of a user who wants to update to the latest ver-
sion. This operation-based approach can be very accurate in
recording the exact type of change, but uses a large number
of change operations and so recording and replaying can be
slow. In contrast, the state-based approach computes deltas
just before the user commits the code by comparing the two
versions. This is more efÞcient (since the changes are com-
puted only once per programming session) but it cannot re-
cover the semantics of the changes (it detects all changes in
a large pile of seemingly unrelated changes). For instance,
a method rename can result in a lot of changes: changing
the declaration of the method, updating the method callers
as well as the transitive closure of all declarations and call
sites of overridden methods.
MolhadoRef uses a mixture of both paradigms to maxi-
mize efÞciency and accuracy. MolhadoRef uses the Eclipse
compare engine to learn the individual deltas (e.g., changes
within a method body or addition/removal of classes, meth-
ods, and Þelds) and it captures the refactorings performed
by the Eclipse refactoring engine to record the semantics of
refactoring operations.
Eclipse refactorings are based on a processor-participant
architecture. We implemented participants for all the refac-
torings in Section 3. Our participants change the subsequent
refactorings in a chain. More precisely, our participants up-
date the fully qualiÞed names of program elements that ap-
pear in the descriptors of subsequent refactorings.
Can MolhadoRef be implemented on top of a traditional
SCM that lacks unique identiÞers? We believe that the

qualities of MolhadoRef can be retroÞtted on a system like
CVS. For the purpose of being able to retrieve history of
refactored elements, it is important to keep a record of their
unique identiÞers. IdentiÞer-to-name maps can be saved in
metadata Þles and stored in the repository. At each check-
out operation, the MolhadoRef CVS client needs to load
these metadata Þles into memory so that they can be up-
dated during refactoring. At each check-in operation, these
Þles are stored back into the repository.
Although MolhadoRef currently handles a subset of the
refactorings described in refactorings catalogs (e.g.,
15]
a glance over the remaining refactorings in [
15] shows that
MolhadoRef can be further extended to support other refac-
torings. The key property we require of refactorings is the
ability to invert refactorings.

6. Case study

We want to evaluate the effectiveness of MolhadoRef in
merging compared to the well known text-based CVS. For
this, we need to analyze source code developed in parallel
that contains both edits and refactorings. Software devel-
opers know about the gap between existing SCM reposito-
ries and refactorings tools. Since developers know what to
avoid, notes asking others to check in before refactorings
are performed are quite common. Therefore, it is unlikely
that we will Þnd such data in source code repositories. As a
consequence, we analyze the parallel development of Mol-
hadoRef itself.
Most of the development of MolhadoRef was done by
two programmers in a pair-programming fashion (two peo-
ple at the same console).
However, during the last three
weeks, the two programmers ceased working on the same
console. Instead, they worked in parallel; they refactored
and edited the source code as before. When merging
the changes with CVS, there were many same-line con-
ßicts.
It turned out that a large number of them were
caused by two refactorings: one renamed a central API
class LightRefactoring to Operation, while the other
moved the API class LightRefactoring to a package that
contained similar abstractions.
When merging the same changes using MolhadoRef,
much fewer conßicts occur. Table 1 presents the effec-
tiveness of merging with CVS versus MolhadoRef. Col-
umn ÔconßictsÕ shows how many of the changes could not
be automatically merged and require human intervention.
For CVS these are changes to the same line or block of
text. For MolhadoRef these are operations that cannot be
automatically incorporated in the merged version because
they would have caused compile or run-time errors. Next
columns show how many compile-time and run-time errors
are introduced by each SCM.
Table 1 shows that MolhadoRef was able to automat-

29th International Conference on Software Engineering (ICSE’07)0-7695-2828-7/07 $20.00  © 2007,
[
)
,
CaseStudy
MolhadoRef code
MotivatingExample

Conßicts
36
3

CVS
CompileErrs
41

RuntimeErrs
7

Conßicts

MolhadoRef
CompileErrs
0
0

RuntimeErrs
0
0

Table 1. Effectiveness of merging with CVS versus MolhadoRef

ically merge all 36 same-line conßicts reported by CVS.
MolhadoRef asked for user assistance only once, namely
when both developers introduced method getID() in the
same class.
MolhadoRef did not introduce any compile-
time or run-time errors while CVS had 48 such errors after
ÒsuccessfulÓ merge. In addition, it took 105 minutes for the
two developers to produce the Þnal, correct version using
CVS, while it takes less than one minute for MolhadoRef.
Second,
MolhadoRef helps in program understanding by
reducing the complexity of all the low level textual changes.
MolhadoRef raises the granularity level of changes from
textual changes to structural changes. During the last 12
weeks of MolhadoRef development, there were 67 refac-
torings which correspond to 1267 changed lines in Mol-
hadoRef and its accompanying JUnit test suite. Undoubt-
edly, it is easier to read and understand 67 changes than
1267 (a reduction of 1 : 19).
Third, being an ID-based SCM
MolhadoRef can retrieve
the history of refactored program entities. For the three
weeks of MolhadoRef development that we analyzed, CVS
lost the history of two core Þles containing 73 API methods.

7. Related Work

SCM systems have a long history [5, 34]. Traditional
systems (e.g. CVS [25]
) provided versioning support for
individual Þles and directories. In addition to version con-
trol, advanced SCM systems also provide more powerful
conÞguration management services. Subversion [30] pro-
vides more powerful features such as versioning for meta-
data, properties of Þles, renamed or copied Þles/directories.
Similarly, commercial SCM tools still focus on
ﬁles [34 ].
Advanced SCM systems provide
ﬁne-grained versioning
support not only for programs but also for other types
of software artifacts. Examples include COOP/Orm [21
Coven [4]
, POEM
19]
, WestfechtelÕs system [31
, and
OhstÕs Þne-grained SCM model [27].
However, none of
them handle refactorings as MolhadoRef does.
Software Merging. According to Mens [23]
, software
merging techniques can be distinguished based on how soft-
ware artifacts are represented.Text-based merge tools con-
sider software artifacts merely as text (or binary)
Þles. In
RCS and CVS [25]
, lines of text are taken as indivisible
units. Despite its popularity, this approach cannot handle
well two parallel modiÞcations to the same line. Only one

of the two modiÞcations can be selected, but they cannot be
combined. Syntactical merging is more powerful than tex-
tual merging because it takes the syntax of software artifacts
into account. Unimportant conßicts such as code comment
or line breaks can be ignored by syntactic merger. Some
syntactic merge tools focus on parse-trees or abstract syn-
tax tree [
16, 32]. Other are based on graphs [22, 28].
However, they cannot detect conßicts when the merged pro-
gram is syntactically correct but semantically invalid. To
deal with this, semantic-based merge algorithms were de-
veloped. In WesfetchtelÕs context-sensitive merge tool [31
an AST is augmented by the bindings of identiÞers to their
declarations. More advanced semantic-based merge algo-
rithms [3,
17, 33] detect behavioral conßicts using depen-
dency graphs, program slicing, and denotational semantics.
Operation-based Merging. The operation-based ap-
proach has been used in software merging [
13,
18, 20,
22, 29].
It is a particular ßavor of semantic-based merg-
ing that models changes between versions as explicit op-
erations. Operation-based merge approach can improve
conßict detection and allows better conßict solving [23].
Lippe et al. [20] describes a theoretical framework for con-
ßict detection with respect to general transformations. No
concrete application for refactorings was presented. Ed-
wardsÕ operation-based framework detects and resolves se-
mantic conßicts from application-supplied semantics of op-
erations [
13]. GINA [2] used a
redo mechanism to apply
one developerÕs changes to otherÕs version. The approach
cannot handle well long command histories and the Þne
granularity. The departure point of MolhadoRef from exist-
ing approaches is its ability to mergerefactorings and edits.
Similar
to MolhadoRef, Ekman and Asklund [
14]
present a refactoring-aware versioning system. Their ap-
proach keeps the program elements and their IDs in volatile
memory, thus allowing for a short-lived history of refac-
tored program entities. In our approach, program elements
and their IDs are stored throughout the lifecycle of the
project, allowing for a global history tracking of refactored
entities. Also, they do not describe any merging algorithm.
Fine-grained and ID-based versioning have been pro-
posed before by others. However, the novelty of this work is
the combination of operation-based,
Þne-grained, ID-based
SCM to handle refactorings and high-level edit operations.
To the best of our knowledge, we are presenting the Þrst al-
gorithm to merge refactorings and edits. The algorithm is
implemented and the Þrst experiences are demonstrated.

29th International Conference on Software Engineering (ICSE’07)0-7695-2828-7/07 $20.00  © 20071
1
1
1
,
]
,
[
]
1
,
]
,
8. Conclusions and Future Work

Refactoring tools have become popular because they al-
low programmers to safely make changes that can affect
all parts of a system. However, such changes create prob-
lems for the current SCM tools that operate at the Þle level:
refactorings create more merge conßicts, the history of the
refactored program elements is lost, and understanding of
program evolution is harder.
We present a novel SCM system,
MolhadoRef, that is
aware of program entities and the refactoring operations
that change them.
MolhadoRef uses the operation-based
approach to record (or detect) and replay changes. By in-
telligently treating the dependences between different oper-
ations, it merges edit and refactoring operations effectively.
In addition, because MolhadoRef is aware of the seman-
tics of change operations, a successful merge does not pro-
duce compile or runtime errors. Storing the IDs of program
entities across versions tracks the history better, while ex-
plicit representation of refactorings reduces the load of un-
derstanding the program evolution.
Because MolhadoRef is integrated with a popular devel-
opment environment like Eclipse, we expect to have a large
customer base. Future work will evaluate empirically the
productivity of a group that uses MolhadoRef.
This research is part of our larger goal to upgrade
component-based applications to use the latest version of
component by replaying the componentÕ refactorings [9, 8 ].
The upgrading tool needs to handle refactorings and edits
not only on the component side, but on the application side
too. This is a special case of the more general merging case
presented in this paper, and therefore we will apply the same
merge algorithm.
We believe that the availability of such refactoring-
tolerant SCM tools will encourage programmers to be even
bolder when refactoring. Without the fear that refactorings
are causing conßicts with othersÕ changes, software devel-
opers will have the freedom to make their designs easier to
understand and reuse.
The reader can Þnd screen shots and download Mol-
hadoRef at: http:/
/netÞles.uiuc.edu/dig/
MolhadoRef

References

] U. Asklund. Identifying conßicts during structural merge. In
Pro-
ceedings of Nordic Workshop on Programming Environment Re-
search, pages 23 1
Ð242 ,
1994.
[2] T. Berlage and A. Genau. A framework for shared applications with
a replicated architecture. InUIST ’93, pages 249Ð257. ACM Press,
1993.
V. Berzins. Software merge: semantics of combining changes to
programs. ACM Trans. Program. Lang. Syst.,
1903 ,
16 (6 ): 1875 Ð
1994.
M. C. Chu-Carroll ,
J. Wright, and D. Shields. Supporting aggrega-
tion in Þne grained software conÞguration management. In FSE’02,
pages 99 Ð
108. AC M Press , 2002.

[3]

[4]

19]

[21

In

15]

16]

17]

[5] R. Conradi and B. Westfechtel. Version models for software conÞg-
uration management.ACM Computing Surveys (CSUR), 30 (2 ):232 Ð
282 ,
1998.
[6 ] T. H. Cormen , C. E. Leiserson , R. L. Rivest , and C. Stein.
Introduc-
tion to Algorithms, Second Edition, pages 549 Ð552. The MIT Press
and Mc Graw -
Hill Book Company, 200 1.
J. Ratzinger, R. Marinescu,
[7] S. Demeyer, F. Rysselberghe, T. G
õrba,
T. Mens,
M. Lanza,
M. Rieger,
B. D. Bois, D. Janssens, S. Ducasse,
H. Gall, and M. El-Ramly. The LAN-simulation: A Refactoring
Teaching Example. In IWPSE’05, pages 123 Ð
134 , 2005.
[8] D. Dig, C. Comertoglu, D. Marinov
, and R. Johnson. Automatic
detection of refactorings in evolving components. In ECOOP’06,
pages 404 Ð428 , 2006.
[9] D. Dig and R. Johnson. How do APIs evolve? A story of refactoring.
Journal of Soft. Maintenance and Evolution ,
18:87 Ð
103 , 2006.
10] D. Dig, T.N. Nguyen, and R. Johnson. Refactoring-aware software
conÞguration management. Technical Report UIUCDCS-R-2006-
27 10 , UIUC , April 2006.
] D. Dig,
K. Manzoor,R. Johnson, and T.N. Nguyen. Refactoring-
aware ConÞguration Management System for Object-Oriented Pro-
grams. Tech. Report UIUCDCS -R -2006 -2770 , UIUC , Sept 2006.
/ help. eclipse. org/
12] WhatÕs new in Eclipse 3.2 (
JDT).http:/
help32/index.jsp
?topic=
org.eclipse.jdt.
doc.user/ what-
jdt whatsnew.html.
sNew/
13] W. Edwards. Flexible Conßict Detection and Management in Col -
laborative Applications. In Proceedings of UIST,
1997.
14] T. Ekman and U. Asklund. Refactoring-aware versioning in eclipse.
Electr. Notes Theor. Comput. Sci. ,
107:57 Ð69 , 2004.
M. Fowler,
K. Beck,
J. Brant, W. Opdyke, and D. Roberts.
Refac-
toring: Improving the Design of Existing Code. Adison-Wesley
+ Programs. In
J. Grass. A Syntax Directed Differencer for C+
Proceedings of the Usenix C++ Conference ,
1992.
J. W. Hunt and T. G. Szymanski. A fast algorithm for computing
longest common subsequences. Commun. ACM, 20 (5 ):350 Ð353 ,
1977.
18] A. Lie, R. Conradi, T. M. Didriksen, and E.-A. Karlsson. Change
oriented versioning in a software engineering database. InSCM-2,
pages 56 Ð65. AC M Press ,
1989.
Y. Lin and S. Reiss. ConÞguration management with logical struc-
tures. In ICSE’96, pages 298 Ð307 ,
1996.
[20] E. Lippe and N. van Oosterom. Operation-based merging. In
5, pages 78 Ð87. AC M Press ,
1992.
B. Magnusson and U. Asklund. Fine-grained revision control of
ConÞgurations in COOP/Orm. In
1996.
SCM-6. Springer Verlag ,
[22] T. Mens.
A Formal Foundation for Object-Oriented Software Evo-
lution. PhD thesis,
Vrije Universiteit Brussel,
1999.
[23] T. Mens. A state-of-the-art survey on software merging.
Trans. on Software Engineering, 28 (5 ):449 Ð462 , 2002.
[24] W. Miller and E. W. Myers. A Þle comparison program.
): 1025 Ð
Pract. Exper.,
1985.
1040 ,
15 (
Linux Journal,
[25] T. Morse. CVS.
1996.
1996 (2 1es ):3 ,
[26] T. N. Nguyen, E. V. Munson,
J. T. Boyland, and C. Thao. An Infras-
tructure for Development of Multi-level, Object-oriented ConÞgu-
ration Management Services.
In
ICSE’05, pages 2 15 Ð224. AC M
Press, 2005.
M. Welle, and U. Kelter. Differences between versions of
[27] D. Ohst,
UM
L diagrams. In
FSE’03, pages 227 Ð236 , 2003.
J. Rho and C. Wu. An efÞcient version model of software diagrams.
In APSEC’98, page 236 ,
1998.
H. Shen and C. Sun. A complete textual merging algorithm for soft-
ware conÞguration management systems. Proceedings of COMP-
SAC’04, 0 1:293 Ð298 , 2004.
[30] Subversion.tigris.org. http:/
/subversion.tigris.org/.
B. Westfetchtel. Structure-oriented Merging of Revisions of Soft-
[31
ware Documents. In SCM-3, pages 68 Ð79. Springer Verlag ,
199 1.
[32] W. Yang. How to merge program texts.
The Journal of Systems and
, November 1994.
Software, 27 (2 )
[33] W. Yang, S. Horwitz
, and T. Reps. A program integration algorithm
that accommodates semantics -preserving transformations. ACM
Trans. Softw. Eng. Methodol.,
(3 ):3 10 Ð354 ,
1992.
Yellow Pages. http:/
/www.cmcrossroads.com/.

Softw.,

[34] CM

SDE-

IEEE

[28]

[29]

29th International Conference on Software Engineering (ICSE’07)0-7695-2828-7/07 $20.00  © 2007[
1
ö
[
[
1
1
[
/
[
[
[
[
[
[
[
]
1
1
]
1
978-1-4673-1067-3/12/$31.00

c(cid:13) 2012 I

233

ICS

E 2012, Z

uri

h, S

tzerl

Use,Disuse,andMisuseofAutomatedRefactoringsMohsenVakilian,NicholasChen,StasNegara,BalajiAmbreshRajkumar,BrianP.Bailey,RalphE.JohnsonUniversityofIllinoisatUrbana-ChampaignUrbana,IL61801,USA{mvakili2,nchen,snegara2,rajkuma1,bpbailey,rjohnson}@illinois.eduAbstract—Thoughrefactoringtoolshavebeenavailableformorethanadecade,researchhasshownthatprogrammersunderutilizesuchtools.However,littleisknownaboutwhyprogrammersdonottakeadvantageofthesetools.Wehaveconducteda(cid:2)eldstudyonprogrammersintheirnaturalsettingsworkingontheircode.Asaresult,wecollectedasetofinteractiondatafromabout1268hoursofprogrammingusingourminimallyintrusivedatacollectors.Ourquantitativedatashowthatprogrammerspreferlightweightmethodsofinvokingrefactorings,usuallyperformsmallchangesusingtherefactoringtool,proceedwithanautomatedrefactoringevenwhenitmaychangethebehavioroftheprogram,andrarelypreviewtheautomatedrefactorings.Wealsointerviewednineofourparticipantstoprovidedeeperinsightaboutthepatternsthatweobservedinthebehavioraldata.Wefoundthatprogrammersusepredictableautomatedrefactoringseveniftheyhaverarebugsorchangethebehavioroftheprogram.Thispaperreportssomeofthefactorsthataffecttheuseofautomatedrefactoringssuchasinvocationmethod,awareness,naming,trust,andpredictabilityandthemajormismatchesbetweenprogrammers'expectationsandautomatedrefactor-ings.Theresultsofthisworkcontributetoproducingmoreeffectivetoolsforrefactoringcomplexsoftware.Keywords-Softwareengineering;Softwaremaintenance;Pro-grammingenvironments;Humanfactors;Userinterfaces;HumancomputerinteractionI.INTRODUCTIONRefactoringisdeρnedaschangingthedesignofsoft-warewithoutaffectingitsobservablebehavior[1].Refactor-ingsrename,move,split,andjoinprogramelementssuchasρelds,methods,packages,andclasses.AgilesoftwareprocessessuchaseXtremeProgramming(XP)prescriberefactoring[2],becauseitenablesevolutionarysoftwaredesignandisthekeytomodiρableandreadablecode[3].Programmersrefactortheircodefrequently[4],[5].Somerefactoringsaretediousanderror-pronetoperformmanually.Thus,automatedrefactoringswereinventedmorethanadecadeagotomaketheprocessofrefactoringmoreefρcientandreliable[6].Today,modernIntegratedDevelopmentEnvironments(IDEs),suchasEclipse[7],NetBeans[8],IntelliJIDEA[9],Xcode[10],andReSharper[11],supportmanyautomatedrefactorings.Recently,therehasbeenmuchinterestinimprovingthereliabilityofexistingautomatedrefactoringsandbuildingnewonestoautomatesophisticatedprogramtransforma-tions[12](cid:150)[16].Thisisnotsurprising,giventhetediumanderror-pronenessofsomerefactoringsandtheperceivedbeneρtsoftheirautomation.Inspiteofthegrowinginterestinimprovingtheusabilityofautomatedrefactorings[17](cid:150)[19],thisaspectofrefactoringhasnotreceivedenoughattention.Forexample,theuserinterfacesofrefactoringtoolshavechangedlittlesincetheywereρrstintroduced,andrecentstudiessuggestthatprogrammersgreatlyunderutilizetheexistingrefactoringtools[5].Weneedtounderstandtheproblemsprogrammershavewithtoday’srefactoringtoolstodesignfuturegenerationsofthesetoolsthatρtprogrammers’needs.Weconductedastudyconsistingofbothquantitativeandqualitativedatacollection.Westudied26developersworkingintheirnaturalsettingsontheircodeforatotalof1268programminghoursoverthreemonths,andcollecteddataabouttheirinteractionswithautomatedrefactorings.Weobservedpatternsofinteractioninourquantitativedataandinterviewednineofourparticipantstotakeamoredetailedqualitativelookatourbehavioraldata.Then,weadaptedageneralframeworkofhuman-automationinter-action[20]toframetheuse,disuse,andmisuseofau-tomatedrefactorings.Useofautomatedrefactoringsreferstoprogrammersapplyingautomatedrefactoringstoperformcodechangestheymightotherwisedomanually.Disuseofautomatedrefactoringsisprogrammers’neglectorunderuseofautomatedrefactorings.Misuseofautomatedrefactoringsreferstoprogrammers’useofthesetoolsinwaysnotrecommendedbythedesigners.Ourempiricalstudyshedslightonhowusersinteractwithautomatedrefactorings.First,wehavefoundthatasinglecontext-awareandlightweightmethodofinvokingrefactoringsaccountsforasigniρcantnumberofrefactoringinvocations(SeeSectionIII).Second,wehavefoundsev-eralfactorsthatleadtotheunderutilizationofautomatedrefactoringssuchasneed,awareness,naming,trust,pre-dictability,andconρguration(SeeSectionIV).Third,wehavefoundthatprogrammersusuallycontinueanautomatedrefactoringthathasreportedsomeerrororwarning.Thisρndingcastsdoubtonthemainpropertyofautomatedrefactorings,namely,behavior-preservation.Inaddition,wehaveobservedsomeunjustiρedusesoftherefactoringtool(SeeSectionV).Finally,wehaveproposedalternativewaysofdesigningrefactoringtoolsbasedontheρndingsofourstudy(SeeSubsectionsIII-B,IV-G,andV-C).E
E
E
c
w
i
a
n
d
234

II.RESEARCHMETHODOLOGYTounderstandwhyexistingautomatedrefactoringsareunderused,weanalyzedalargecorpusofinteractiondatagatheredfrom26programmersoverthreemonths.Inaddi-tion,weconductedasetofninesemi-structuredinterviewswithdeveloperstounderstandtherationalesoftheirrefac-toringpractices.A.ParticipantsWerecruited16programmersworkingonresearchprojectsattheUniversityofIllinoisatUrbana-Champaign.ElevenoftheseinternalprogrammerswereenrolledinComputerSciencegraduateprograms,andtheremainingρvewereresearchinterns.Wealsorecruited10externalprogrammersbysendingmorethan25individualemailsandpostingrecruitmentmessagestothemailinglistsandIRCchannelsofover40open-sourceJavaprojects.Weaskedeveryparticipanttoρlloutabriefsurveythatcollectedsomedemographicinformationincludingtheiryearsofprogrammingexperienceandprojects.Wereceivedthesurveyresultsof24participants.Basedonthesurvey,2,4,11,and7ofourparticipantshad1(cid:150)2,2(cid:150)5,5(cid:150)10,andmorethan10yearsofprogrammingexperience,respectively.Ourparticipantsreportedthattheyhadbeenworkingonadiverserangeofprojectssuchasbanking,businessprocessmanagement,marketing,databasemanagement,andprojectsofsixresearchlabsattheuniversity.B.DataCollectionWegatheredtheinteractiondatausingourtwominimallyintrusivedatacollectorsfortheEclipseIDE:CodingSpec-tatorandCodingTracker[21].Ourparticipantsusedthesetoolsforabout1268hours(mean=49,sd=46).Ourdatacollectorsweredevelopedtocapturedatare-gardingthefailureofautomatedrefactorings,contextofthefailure,conρgurationoverhead,andinvocationmethods.CodingSpectatorcapturesdataabouttheuseofautomatedrefactoringswhileCodingTrackercollectsallmanualedits.CodingSpectatorcollectsthreekindsofevents:canceled,performed,andunavailable.Canceledeventsaretriggeredwhentheprogrammercancelsanautomatedrefactoring.Performedeventsoccurwhentheprogrammerappliesanautomatedrefactoring,andunavailableeventsaretriggeredwhentheprogrammertriestoinvokeaninapplicableauto-matedrefactoringandEclipsereportsanerror.EclipsecreatesrefactoringdescriptorobjectsforsomeinvocationsofautomatedrefactoringsandstorestheminanXMLformat.CodingTrackercapturesthedescriptorsofallrefactoringscreatedbyEclipse,andCodingSpectatorcreatesrefactoringdescriptorsofitsown,whichcapturemoredatathanthoseofEclipse.CodingSpectatorsupported23ofthe33automatedrefactoringssupportedbyEclipseduringthestudy.CodingSpectatorrecordsthefollowinginformationinitsrefactoringdescriptors:1)thetimeofoccurrenceofeveryrefactoringevent2)theidentiρeroftheautomatedrefactoring3)conρgurations,e.g.inputelements,project,andset-tingsthataffecttheresultofthetool4)informationabouttheselectionusedtoinvoketheautomatedrefactoringanditscontext5)whethertherefactoringtoolwasinvokedusingQuickAssist6)theproblemsreportedbyeachinvocationofanauto-matedrefactoring7)thetimespentoneachpageoftherefactoringwizardsFigure1illustratestherefactoringdescriptorthatCod-ingSpectatorcapturesforanapplicationoftheExtractMethodrefactoring.Duetoprivacyissues,weuseourownexamplesinsteadofourparticipants’data.    <refactoring     stamp="1317326947775"    id="org.eclipse.jdt.ui.extract.method"    comment="Extract method 'private void     printDetails(double amount)' from 'Printer.printInfo()'     to 'Printer'" exceptions="false" input="/src<{Printer.java"    name="printDetails"    code-snippet="    void printInfo(double amount) {      printBanner();      System.out.println("Amount: " + amount);    }"    selection-text="    System.out.println("Amount: " + amount);"    invoked-by-quickassist="false"    status="<OK>"    navigation-history="    {[ExtractMethod,BEGIN_REFACTORING,1317326935617],    [ExtractMethodInputPage,Preview>,1317326940477],    [PreviewPage,OK,1317326947379],}"    />    !"#$%&'9/29/11 5:53 PMPage 1 of 1file:///Users/vazexqi/Desktop/sample.html    void printInfo(double amount) {      printBanner();      System.out.println("Amount: " + amount);    }Figure1.ThedescriptorcapturedbyCodingSpectatorforanExtractMethodrefactoringinvokedonthehighlightedstatementsofmethodprintInfo()inthetopbox.SeethenumberedlistofitemsinSubsectionII-Bforadescriptionofeachgroupofattributes.CodingTrackerrecordstheeditsmadeinsidetheJavaeditorsofEclipsesopreciselythatitcanlaterreplaythemtoshowthecodeevolutioninaction.Wereplayedsomeofthecodeeditstoobtainmorecontextaboutsomeoftherefactoringeventsandestimatethenumberoflinesandρlesaffectedbyeachautomatedrefactoring.WealsousedCod-ingTrackertoestimatethenumberofprogramminghoursofeachparticipants.Wecomputedthenumberofprogramminghoursbyaddingupthetimeintervalsbetweenconsecutive235

CodingTrackereventsthatwereatmosthalfanhourlong.BothCodingSpectatorandCodingTrackerareopensourceandavailableathttp://codingspectator.cs.illinois.edu.Theanalysisoftheinteractiondatawascomplementedbyconductingsemi-structuredinterviewswithnineofourinternalparticipants.Eachinterviewlastedaboutanhour.Duringtheinterviews,weaskedquestionsaboutpartic-ipants’awarenessanduseofautomatedrefactorings.Inaddition,wepromptedtheparticipantswiththedetaileddatathatourdatacollectorshadcapturedandaskedthemquestionsabouttheirspeciρcusagepatternssuchastherefactoringstheyhadperformedorcanceled,thepiecesofcodetheyhadrefactored,theselectionsandmethodstheyhadusedtoinvoketherefactorings,andtherefactoringproblemstheyhadreceivedfromthetools.Theinterviewscriptisinanaccompanyingtechnicalreport[22].Inthispaper,werefertothei-thintervieweeasIi.C.DataAnalysisWeusedtheoreticalsampling[23]todecidewhatdatatocollectandwhomtointerview.Forinstance,basedontheresultsofourpilotstudyon14undergraduatestudentsattheuniversity,wedecidedtostudymoreexperiencedpro-grammersforalongerperiodoftime.Weusedaninductiveapproachforanalyzingthequalitativedatatoreliablydecidewhethertwointervieweeshadprovidedequivalentresponses.Theρrstauthorcodedtheinterviewscriptstoderivethecommonthemesoftheinterviewresponses.Helistedallresponsesbelongingtoeachcode,andconstantlycomparedandrevisedthecodesuntiltheysaturated.SectionsIII,IV,andVpresentthecorecategoriesofourdata,namely,use,disuse,andmisuse,andtheirrelatedcategoriesinsubsections.III.USEOFAUTOMATEDREFACTORINGTOOLSDecisionsabouttheuseofautomatedtoolsdependonacomplexinteractionofavarietyoffactorsandaresubjecttopersonaldifferences.Thehuman-automationinteractionliteraturehasstudiedtherolesofpersonalattitudes,mentalworkload,cognitiveoverhead,trust,conρdence,risk,andotherfactorsonhumanuseofautomation[20].Thissectiondiscussestheimpactofinvocationmethodontheuseofautomatedrefactorings.A.InvocationMethodEclipsesupportsseveralwaysofinvokingrefactorings.Theprogrammercouldgotothe(cid:147)Refactor(cid:148)menu,rightclick,oruseshortcutkeystoinvokerefactorings.Alterna-tively,theprogrammermayuseQuickFixorQuickAssist(CTRL+1)toinvokesomeoftheautomatedrefactorings.QuickFixassistsprogrammersinresolvingcompilationproblems.EclipseshowsasmalliconclosetothelocationofeachcompilationproblemifaQuickFixisavailablefortheproblem.QuickFixsometimesoffersarefactoringtoresolvecompilationwarnings.Ontheotherhand,QuickAssistisnottiedintocompilationproblems,andprogrammerscanuseittoperformsomecommonchangessuchasRenameandExtractMethod(SeeFigure2foranexampleofQuickAssist).Figure2.QuickAssistproposessomeofthetransformationsthatareapplicabletotheselectedcontext.Theusercansingleclickoneachproposeditemtopreviewitseffectonthecode.Ourresultssuggestthatprogrammersprefertoquicklyapplyanautomatedrefactoringandtweakitsoutcomelaterratherthanspendtimeconρguringthetoolupfront.BasedonthedatainTableI,ourparticipantsusedQuickAssisttoperformtherefactoringsthatitsupports35%ofthetime.OurparticipantsreliedonQuickAssisttoperformtheRenamerefactoringlessthanotherrefactoringsperhapsbecauseRenameissofrequentthattheyhadlearneditsshortcutkey.IfweexcludetheRenamerefactorings,ourparticipantsusedQuickAssisttoinvoke65%oftherefac-torings.ThispaperreportstheρrstquantitativeresultsontheuseofQuickAssistforperformingrefactorings.OfthesixintervieweeswhowereawareofQuickAs-sist,ρveuseditastheirprimarymethodofinvokingtherefactoringssupportedbyit.QuickAssistisapopularmethodofinvokingautomatedrefactoringsbecauseitcanbequicklyinvokedviakeyboard,narrowsthedecisionspacebyproposingonlyahandfuloftransformationsthatareapplicabletotheselectedcontext,andmakesiteasiertoconρgurerefactoringsbyusingsomedefaultsettingsandnotopeningadialog.However,wenoticedthatatleasttwoofourintervieweeswerenotawarethatQuickAssisthadusedsomenon-defaultsettingsfromthelastconρgurationoftherefactoring.AllofourintervieweeswereawareofQuickFix(SeeSubsectionIII-A).ThisawarenesscouldbearesultofthevisualelementthatindicatestheavailabilityofQuickFix.ThreeofourintervieweesdidnotknowabouttheQuickAssistfeature.Nevertheless,thosewhowereawareofitheavilyreliedonittobothdiscoverandinvokeautomatedrefactorings.I1toldus:Mostofthem[theautomatedrefactorings]IknowaboutbyusingQuickAssist.Iveryseldomgointothe236

TableIDATAABOUTTHEUSAGEOFAUTOMATEDREFACTORINGSFROM26PROGRAMMERSFORABOUT1268HOURSOVERTHREEMONTHS.THECSSUBSCRIPTINDICATESTHEDATACAPTUREDUSINGCODINGSPECTATOR,ANDTHECTSUBSCRIPTINDICATESTHEDATACAPTUREDUSINGCODINGTRACKER.INTHECOMPLEXITYCOLUMN,S=SIMPLE,M=MODERATE,ANDC=COMPLEX.CONFIGCSISTHEAVERAGECONFIGURATIONTIME(SECONDS)OF788REFACTORINGS.LINESCTANDFILESCTARETHEAVERAGENUMBERSOFAFFECTEDLINESANDFILESCOMPUTEDUSINGTHEDATAAVAILABLEFOR93%OFTHEPERFORMEDREFACTORINGSCAPTUREDBYCODINGTRACKER.PR(P|W)CS=PR(PERFORMED|WARNING)ANDPR(P|E)CS=PR(PERFORMED|ERROR).THESYMBOL(cid:147)-(cid:148)INDICATESANUNKNOWNORUNDEFINEDVALUE.PERFORMEDCSISLESSTHANPERFORMEDCTFORCHANGEMETHODSIGNATUREBECAUSECODINGSPECTATORDIDNOTSUPPORTTHISREFACTORINGFROMTHEBEGINNINGOFTHESTUDY.AutomatedRefactoringComplexityPerformedCSPerformedCTCanceledCSWarningCSErrorCSFatalErrorCSQuickAssistCSPreviewCSCon(cid:2)gCS(sec)LinesCTFilesCTPr(P|W)CSPr(P|E)CSChangeMethodSignatureC45498190-08.17.482.311.001.00ConvertAnonymousClasstoNestedS-3-------35.001.00--ConvertLocalVariabletoFieldS979710018305.63.651.00--EncapsulateFieldM-225-------10.441.10--ExtractClassC-15-------120.752.25--ExtractConstantS292900102606.93.721.00-1.00ExtractInterfaceM224200-125.636.001.500.00-ExtractLocalVariableS6066061468047503.32.551.001.000.75ExtractMethodM18618630013062512.221.211.00-0.54ExtractSuperclassC003100-03.0--0.00-GeneralizeDeclaredTypeM-0-----------InferGenericTypeArgumentsC-7-------1.290.57--InlineConstantS38380000-00.51.001.00--InlineLocalVariableS18218210007300.43.261.00--InlineMethodS63638031-01.59.971.13-0.67IntroduceFactoryM-0-----------IntroduceIndirectionM-2-------20.504.50--IntroduceParameterC-46-------4.741.52--IntroduceParameterObjectC-0-----------MoveC1471478033-105.512.012.19-1.00MoveMethodC0010300-316.5--0.00-MoveStaticMemberM661100-013.045.203.201.00-MoveTypetoNewFileS-7-------54.501.00--PullUpC990500-18.911.782.891.00-PushDownC883230-939.032.2512.750.500.33RenameClassM27627637411652058.912.133.060.930.62RenameEnumerationConstantS33020030-6.004.001.00-RenameFieldM12512591636622.84.521.470.940.67RenameLocalVariableS4654651441662002.33.371.000.500.62RenameMethodM26026017331691507.43.452.200.940.69RenamePackageM12120400006.84.672.751.00-RenameTypeParameterS66000000-2.171.00--UseSupertypeWherePossibleC007000-15.6----256528741751219131783376.306.711.470.880.68TotalCountsWeightedAveragesOverallPrrefactoringmenuandonlywhenthereisarefactoringthatIcannotreachthroughQuickAssistandIdon’tknowabout[...].QuickAssistwilltellmeiftheyareapplicableinacertaincontext.[...].Italwaysannoysmewhenthey[automatedrefactorings]arenotavailablethroughQuickAssistlikeChangeMethodSignature.[...]IreallylikeQuickAssist.Asanotherexample,whenweintroducedI2totheIntro-duceParameterrefactoring,hecommented:That’s[theIntroduceParameterrefactoring]actuallyprettycool.Ineverknewabouttheexistenceofthis.I’vedonethisafewtimesmanually,andIalwayswonderedifit’spossibletodothisautomatically.Yeah,I’llprobablytryit.DoesthisshowupinQuickAssist?B.ImplicationsWehavefoundthatprogrammerspreferlightweightmeth-odsofinvokingrefactoringslikeQuickAssist.Therefore,wesuggestthatotherIDEssuchasIntelliJIDEA[9]andNetBeans[8]supportrefactoringinvocationmethodssimilartoQuickAssist.WenoticedthatQuickAssistwasasomewhathiddenfea-tureofEclipse.Someprogrammerswillnotknowaboutthisfeatureuntiltheysomehowlearnaboutthemagicshortcutkey.MoreprogrammersknowaboutQuickFixbecauseithasavisualrepresentation.ThisobservationsuggeststhatrecommendingrefactoringssimilartothewayQuickFixrecommendsρxesforcompilationproblemsmightpromote237

theuseofautomatedrefactorings.WhileQuickFixremovescompilationproblems,automatedrefactoringsremovecodesmells.Codesmellsarecommondeρcienciesofcodethatmakeitlessreadableandreusable[3,p.75].Severaltoolshavebeenproposedfordetectingcodesmells[24](cid:150)[27].Ifacodesmelldetectorhasalowrateoffalsealarmandsuggestsautomatedrefactoringsthatremovethecodesmells[20],[28],itmayencourageprogrammerstousetherefactoringtoolmoreoften.However,metricsfordetectingcodesmellsdonotrivalinformedhumanintuitioninpractice[3,p.75].Perhapsweneedsystemsthatfacilitateprogrammers’col-laborationondetectingcodesmells.IV.DISUSEOFAUTOMATEDREFACTORINGTOOLSInthehuman-automationinteractionliterature,disusereferstounderutilizationofautomation[20].DisuseofautomatedrefactoringsoccurswhenaprogrammerperformsarefactoringmanuallyeventhoughtheIDEsupportsit.Murphy-Hilletal.inspectedasampleoftheversioncontrolandrefactoringhistoriesofEclipsedevelopersandfoundthatthedevelopershadperformedabout90%oftheirrefactoringsmanuallyinsteadofusingtherefactoringtool[5].Ourinterviewsprovidedqualitativeevidencefordisuseofautomatedrefactorings.Foreachofthefollowing15refactorings,morethanhalfofourintervieweessometimesperformedtherefactoringmanually:ExtractMethod,Ex-tractClass,ExtractSuperClass,ExtractInterface,ExtractConstant,ChangeMethodSignature,InferGenericTypeAr-guments,GeneralizeDeclaredType,UseSupertypeWherePossible,EncapsulateField,IntroduceFactory,IntroduceParameter,MoveInstanceMethod,MoveStaticMember,andPullUp.Intherestofthissection,wewilldiscussthefactorsthatwehavefoundtoinσuencethedisuseofautomatedrefactorings.A.NeedSomeautomatedrefactoringsareunderusedjustbecauseprogrammersrarelyneedthem.Forinstance,TableIshowsthatExtractandPullUpareperformedmorethanInlineandPushDown.Fiveofourintervieweestoldusthatthiswasbecausetheyusuallystartedwithasimpledesignandgraduallymadeitmoregeneralandreusable.Twointervieweessaidthatitwasnotworthlearningsomeautomatedrefactoringsbecausetheyrarelyperformedtherefactorings.Forexample,I3said:Iknowthattherearemanyrefactorings.But,manytimesIthinkthatit’seasiertojustdosomethingmanuallythantrytolearnaveryparticularrefactoringthatdoessomethingthatIdon’tdoveryoften.B.AwarenessProgrammersmustbeawareofanautomatedrefactoringtouseit.Priorsurveystudieshavereportedtheroleofawarenessintheuseofrefactoringtools[5].OurinterviewsshowedthatevenexperiencedprogrammersdonotknowaboutmanyoftheautomatedrefactoringssupportedbyEclipse.WeaskedourintervieweesthefollowingthreequestionsabouteachautomatedrefactoringofEclipse.(cid:15)DidyouknowthatEclipsesupportedthisrefactoring?(cid:15)Doyouknowwhatthisautomatedrefactoringdoes?(cid:15)Doyoueverperformthisrefactoringmanually?Why?Onaverage,ourintervieweeswereunawareoftheexis-tenceofmorethannineautomatedrefactoringsofEclipse.Foreachofthefollowingrefactorings,morethanhalfofourintervieweesdidnotknowthatEclipsehadautomatedsupportfortherefactoring:GeneralizeDeclaredType,UseSupertypeWherePossible,IntroduceFactory,IntroduceIn-direction,IntroduceParameter,IntroduceParameterObject,MoveTypetoNewFile,MoveInstanceMethod,andMoveStaticMember.WeaskedourparticipantshowtheylearnedtheautomatedrefactoringsinEclipseandwhytheyknewonlyasubsetoftherefactoringsinEclipse.Ourintervieweestoldusthattheylearnedautomatedrefactoringsbyseeingotherprogrammersusingthem,readingarticles,orexploringtheIDE.Ourρndingscorroboratetheresultsofpriorstudiesthatidentiρedpeerinteractionasamechanismofdiscoveringnewtools[29],[30].Wefoundthatourintervieweesdidnotalwaysusealltheautomatedrefactoringsthattheyknewabout.ForeachoneofExtractMethod,ExtractClass,ChangeMethodSignature,InferGenericTypeArguments,andPullUp,atleastρveofourintervieweessaidthattheysometimesperformedtherefactoringmanuallyeventhoughtheywereawareofitsautomatedsupportintheIDE.Intherestofthissection,wewilldiscussotherreasonsofdisuse.C.NamingIthasbeenassumedthatrecallingthenamesofautomatedrefactoringsisabarriertousingrefactoringtools[19].Ourstudyprovidedmoreevidencethatautomatedrefactoringswhosenamesarehardtounderstand,tootechnical,orconfusingaremorelikelytogetunderused.I4toldus:Generally,Idon’ttrythemifIdon’tknowwhattheydo.ImightoccasionallytrythemifIcankindofguesswhattheydoeventhoughI’mnotsure,butIdon’tdothatveryoften.Ourintervieweesdidnotknowthegoalsofmorethaneightautomatedrefactoringsonaverage.Thatis,ourin-tervieweesdidnotknowwhateachoftheseautomatedrefactoringsdidandwerenotabletocorrectlyguesswhatthetoolwassupposedtodobasedonitsname.Foreachofthefollowingsevenrefactorings,morethanhalfofourintervieweescouldnotdescribethetransformationauto-matedbytherefactoring:ExtractClass,GeneralizeDeclaredType,IntroduceFactory,IntroduceIndirection,Introduce238

Parameter,IntroduceParameterObject,andMoveInstanceMethod.Inparticular,themajorityofourintervieweesconfusedthethreeautomatedrefactorings:InferGenericTypeArgu-ments,GeneralizeDeclaredType,andUseSupertypeWherePossible.D.TrustTrustinσuencestheuseofautomation,andreliabilityisafactorinthedevelopmentoftrust.Iftheautomationisnotreliable,theoperatorsaremorelikelytolosetheirtrustintheautomationandstopusingit,especiallywhentheautomationfailstoperformsimpletasks.However,iftheautomationishighlyreliable,operatorsseemtotolerateitsoccasionalfailuresandcontinuetouseit[20],[31],[32].Wefoundusabilitytobeamoreimportantfactorthanreliabilityonusers’trustinamaturerefactoringtoollikethatofEclipse.EventhoughothershavefoundsubtleerrorsintherefactoringtoolsofmainstreamIDEs[12],[13],andtherearemanyopenissuesabouttherefactoringtoolsinthebugtrackingsystems,noneofourintervieweesmentionedtheexistenceofbugsinautomatedrefactoringsasareasonfornotusingthesetools.Nonetheless,I2saidthathewouldbemorecautiouswhilechangingcriticalcode:Mostofthetime,Idon’tdo[anautomated]refactoringifitinvolvesverycriticalcodes.I’dratherdoitmanually.Onlythingsthataresoeasythattheycannotpossiblybreak,Iwouldnotexpectthemtobreak.Ontheotherhand,fourofourintervieweesdidnotusesomeoftheautomatedrefactoringsbecauseoftheirusabilityproblems.I3said:Thereisalsoanotionofnottrustingthe[refactoring]tool.Iftheinterfaceofthetoolisnotgoodenough,howdoIknowthattheimplementationisnotsketchy?Ourintervieweesdidnotuseautomatedrefactoringsthattheyhadfoundtohavecomplexuserinterfacesandunclearbeneρts.Ingeneral,ifthebeneρtsofautomationarenotreadilyapparent,humansarelesslikelytousetheautoma-tionbecauseofthecognitiveoverheadinvolvedinevaluatingandusingtheautomation[20].E.PredictabilityWehavefoundthatthepredictabilityofoutcomeisanimportantfactorintheuseofautomatedrefactorings.Threeintervieweesdidnotusesomeautomatedrefactoringsbecauseoftheirunpredictability.Forexample,I3said:[...]IfitaffectsonlyoneρlethenIkindofknowexactlywhattherefactoringdoesandIcanlookattheresultinstantlyafterwards.So,Idon’tlikerefactoringsthatareambiguousenoughthatIamnotabletoguesstheρnalresult.[...]IfIcannotguess,Idon’tusetherefactoring.Iconsideritnotworththetrouble.[...]Ifthethingthatthe[refactoring]tooldoesissocomplicatedthatitisn’teasytoρgureoutthingsarealright,I’mkindofdiscouragedtousethetool.Inthefollowing,wediscusshowthecomplexityandpreviewofarefactoringaffectitspredictability.1)Complexity:Itwasachallengetodeterminethecomplexitylevelsofrefactorings.Therefore,weusedtwoapproachestoestimatethecomplexitiesofrefactorings.Intheρrstapproach,eachoftheρrstthreeauthorsindividu-allyassessedthecomplexitiesofmanuallyperformingtheEclipserefactoringsintheIDE.Then,theycomparedtheirresultsandworkedtogethertoresolvethedisagreementsbetweenassignments.Finally,theycategorizedtherefactor-ingsassimple,moderate,andcomplex.TableIillustratesthecomplexitylevelofeachrefactoring.Wehavefoundthatourparticipantstendedtoperformsimplerrefactoringsmorefrequently(SeeFigure3).NumberofPerformedRefactoringsComplexitySimpleModerateComplex2819.78%109438.07%149952.16%400600800100012001400Figure3.Thisgraphshowsthecountsandpercentagesofperformedrefactoringsineachcategory:simple,moderate,andcomplex.Thecountsofperformedrefactoringsineachcategoryarebasedonthedataincolumns(cid:147)Complexity(cid:148)and(cid:147)PerformedCT(cid:148)ofTableI.Oursecondapproachforstudyingtheeffectofcomplexityontheuseofautomatedrefactoringswasquantitative.Weusedthenumberofρlesandlinesaffectedbyanautomatedrefactoringasanindicatorofitscomplexity.Bigrefactoringscanpotentiallyaltermanylinesofcodeacrossmanyρles.Suchbigrefactoringsaretediousanderror-pronetodomanually.Therefore,onemightexpectprogrammerstouseautomatedrefactoringsforperformingbiggerchanges.How-ever,ourdatashowthat82%oftheautomatedrefactoringsthatourparticipantsperformedaffectedatmostsixlinesand84%oftheperformedautomatedrefactoringsaffectedonlyoneρle.Therecouldbevariousreasonsforthelowuseofautomatedrefactoringsthatmakecomplexchanges.First,theremightjustbelessopportunityforperforminglargerefactorings(SeeSubsectionIV-A).Second,wefoundthatthecurrentdesignofrefactoringtoolsarenotsuitableforautomatingbigrefactorings.Twoofourintervieweesmentionedtheproblemwithlargerefactorings.I1said:Ifitdoestoomuch,thenitwilloverwhelmme.Iwillgettoomanychangesatonce.Idon’tlikelookingatdiffsifIdon’thaveto.And,ifitdoestoomuchforme,IfeellikeI’mpushedoutoftheloop.Suddenly,itchangesmyprograminalotofways.Iwillhavetogo239

andreadthesethingswhileIpreferittodoalittleforme.Sincethetoolsforsmallrefactoringsaffectanarrowpieceofthecode,itiseasiertounderstandthechangesandverifytheircorrectness.Incontrast,programmersmayworrythatthetoolsforperformingbigchangesmaytransformtheircodeinunpredictableways.Disuseofautomatedsupportforcomplexrefactoringsisconsistentwithρndingsfromthehuman-automationinteractionliteraturethatimplyhumansprefertotakeownershipofcomplextasksanddelegatesimpleonestothemachine[20].Morestudiesarerequiredtounderstandthevariablesthataffectthetrendinprogram-mers’useofcomplexrefactorings.2)Preview:Eclipseautomatedrefactoringsallowtheprogrammertopreviewthechangesbeforeapplyingthem.QuickAssisthighlightsthechangesinitspreviewwindow(SeeFigure2),andrefactoringwizardsshowthecodebeforeandafterthechangesidebyside.Othersidentiρedausabilityproblemofpreviewwindowsbasedonasur-vey[5].CodingSpectator’sdataprovidesmoreevidencefortheunderutilizationofpreviewwindows.Ourinterviewsandquantitativeresults(SeeTableI)showthatourparticipantsrarelypreviewedtheirautomatedrefactorings.WeaskedρveofourintervieweeswhohadusedQuickAssistwhethertheyhadpreviewedtherefactoringsintheQuickAssistmenu.AllofthemtoldusthattheyhadnotpreviewedthechangesusingQuickAssist.I5toldus:Thescopeofthepreviewisquitesmallandthereisalsonohighlightingorindentation.So,ifthecodeisabitmorecomplex,itcangetquitedifρculttounderstand.I1gavethefollowingreasonfornotpreviewingrefactor-ings.[...]quickassistactionsareveryquicktoexecuteandIcanjustlookattheminthebrowser[...].IadmitIdon’treallyenjoylookingatdiffsandIprefertogetasenseofthechange(ifitislocal)byundoing/redoing,oftenseveraltimes.Ourintervieweesmentionedseveralreasonsfornotpre-viewingrefactorings.First,sincetheyusuallyusedtherefactoringtooltoperformsmallchangesthatwerelocalizedtoasinglemethodorclass(SeeSubsectionIV-E1),theydidnotneedtopreviewthechange.Second,oneintervieweesaidthatthepreviewwindowwasnotveryusefulbecauseitalwaysshowedasmallportionofthecode.Third,theoverheadofinspectingthebigchangespresentedinthepreviewsishigh.Finally,twooftheintervieweessaidthattheycouldbetterreviewandevaluatetheirrefactoringsastheyperformedthemmanually.Forinstance,I6said:Doingit[arefactoring]manuallygivesmeasenseofhowthingshavechangedasadesignreviewsothatIcanseethedifferentoptionsandreevaluatemychoices.F.ConﬁgurationEclipseletstheprogrammerperformslightvariationsofeveryrefactoringbyprovidingafewoptions.Forexample,theExtractMethodrefactoringinEclipse3.7letsthepro-grammercontroltheaccessmodiρerordeclaredexceptionsoftheextractedmethod.CodingSpectatorrecordedthetimeofopeningandclosingeveryrefactoringwizard(SeeSubsectionII-B).Weusetheamountoftimearefactoringwizardisopentoestimatethetimeneededforconρguringanautomatedrefactoring.Basedonthedata,ourparticipantsconρguredtherefactoringtoolinatmosteightsecondsin82%ofthetime.Threeofourintervieweescomplainedaboutthecomplex-ityofrefactoringwizards.I4said:Tome,wheneveryougointotheserefactoringsyouhavesomedialogsandyouhavetoρgureoutwhatit’sdoingandifthere’soneortwocallsites,youcanstilldoitsimplymanuallyIthink.Conρgurationdialogsbreaktheprogrammingworkσowandimposeanoverheadbyrequiringtheprogrammertounderstandtheoptions.Moreconρgurationoptionsmaymaketheautomatedrefactoringmorepowerfulbutalsomorecomplexandhardertounderstand.Ourresultsprovidemoreevidenceforthedisruptivenessofrefactoringtoolsthatothersidentiρedinasurvey[5].G.ImplicationsBettertrainingonrefactoringsandtheirtoolsmayper-suadeprogrammerstouseautomatedrefactoringsmore.However,thereareotherobstaclestotheadoptionofexist-ingautomatedrefactorings.Forinstance,designersshouldchoosemoreintuitiveandconsistentnamesforautomatedrefactorings.Toolsthatfacilitatetheexchangeofknowledgebetweenprogrammerscanraiseawarenessofrefactoringtools.Forexample,atoolthatusessocialindicatorstonotifymem-bersofasoftwaredevelopmentteamabouttherefactoringactivitiesofothermembersmightencourageprogrammerstolearnmoretoolsfromeachother[33].Amainmotivationofautomatedrefactoringsistoreducethehumanburdenanderrorinmakingcomplexchangestothesourcecode.Researchershavebeenproposingauto-matedsupportforcomplexrefactorings[14],[15],[34](cid:150)[36].However,ourresultssuggestthatprogrammersarereluctanttouseautomatedrefactoringswhoseoutcomesaredifρculttoforesee.Onemayexpectpreviewstohelpprogrammerspredicttheresultsofautomatedrefactorings.Incontrast,wehaveshownthatthecurrentpreviewsofrefactoringsarenoteffective.Perhapsmoreradicalwaysofreviewingrefactoringsareneeded.Thechallengewouldbetopresentthechangesdistributedacrossthecodebaseinaconciseandprecisemanner.Analternativewayofreviewingthechangesofrefactoringsistoprovidefacilitiestoinspectthechangesaftertheyareperformedratherthanbefore.Onewaytopresentthechangesaftertheyareperformedistomarkupthechangesintheeditor.Itmightalsobeusefultohelptheprogrammernavigatethrougheachpartofthecodethat240

isaffectedbytherefactoringtool.Alternatively,agraphicalrepresentationofarefactoringmaybemoreeffectiveforunderstandingtheimpactoftherefactoring.Highcostofconρgurationdiminishesthevalueofau-tomatedrefactorings.Therefore,thedesignersshouldmaketheconρgurationofrefactoringsseamless.V.MISUSEOFAUTOMATEDREFACTORINGTOOLSParasuramanandRileydeρnedmisuseofautomationasuser’soverrelianceonautomation.Accordingtotheirdeρni-tion,misuseofautomationoccurswhentheuserreliesontheautomationeventhoughitwouldhavebeenbettertoperformthetaskmanually[20].Wesometimesfounditchallengingtojudgewhetherauseofanautomatedrefactoringwasanoveruseorcleveruse.Therefore,wequalifythedeρnitionofmisusetobetterexplainthephenomenoninthecontextofrefactoringtools.Wedeρnethemisuseofanautomatedrefactoringasuseoftheautomatedrefactoringinwaysnotrecommendedbythedesigners.Refactoringtoolsaredesignedtopreservethebehavioroftheprogramasmuchaspossibleexceptwhencertainfeaturesofthelanguagesuchasreσectionornativecodeareinvolved.TheEclipserefactoringtoolchecksafewpreconditionstoensurethatitwillnotintroducecompilationproblemsorchangethebehavioroftheprogram.Ifapreconditionfails,therefactoringtoolreportsaproblemwithaseveritylevelofinformation,warning,error,orfatalerror.Warningsofautomatedrefactoringsattempttopredictcompilationwarnings.Errorsofautomatedrefactor-ingspredictcompilationerrorsandnon-behavior-preservingchanges.Thus,Eclipsedoesnotrecommendperformingarefactoringwitherrors[37].Fatalerrorsindicatethattherefactoringtoolisunabletocarryoutthetransformationandpreventtheprogrammerfromcontinuingtherefactoring.Therestofthissectiondiscussessomeofthepossiblemisusesofautomatedrefactoringsthatwehaveidentiρed.A.UnsafeRefactoringsWhenanautomatedrefactoringreportsaproblem,itisnolongerguaranteedtobebehavior-preserving.Therefore,wecallsucharefactoringanunsaferefactoring.Traditionally,therehasbeenanemphasisonthebehavior-preservationpropertyofrefactorings[1],[3].Ourstudyprovidestheρrstquantitativeandqualitativeresultsaboutprogrammers’useofunsaferefactorings.Aprogrammercanhandleanunsaferefactoringintwoways.First,theprogrammermightcanceltherefactoring,ρxthecodetosatisfythepreconditions,andtrythetoolagain.Second,theusercouldperformtherefactoringandρxtheproblemsafterwards.Theformerapproachprovidesstrongerbehavior-preservationguarantees.However,wehavefoundthelattertobetheprevalentapproachindealingwithunsaferefactoring.AccordingtothedatacollectedbyCod-ingSpectator,ourparticipantsperformed79%ofautomatedpublicintgetNextNumber(){if(newRandom().nextBoolean())return0;return1;}Figure4.IftheExtractMethodrefactoringtoolisinvokedonthehighlightedpieceofcode,thetoolwillreporttheerror(cid:147)Selectedstatementscontainareturnstatementbutnotallpossibleexecutionσowsendinareturn.Semanticsmaynotbepreservedifyouproceed.(cid:148)publicclassC{staticinti=0;publicstaticvoidmain(String[]args){System.out.print(1);System.out.print(i);}}Figure5.IftheprogrammerusestheExtractLocalVariablerefactoringtooltoextractthehighlightedexpressiontoalocalvariablenamedi,thetoolwillreportthewarning(cid:147)Avariablewithname‘i’isalreadydeρnedinvisiblescope.(cid:148)Iftheusercontinuestherefactoring,thecompilerwillnotreportanyproblems,but,theoutputoftheprogramwillchangefrom10to11.refactoringsthathadreportedsomeerrororwarning.TableIillustratestheprobabilityofourparticipantsperformingeachkindofrefactoringinspiteofareportedproblem.Ourparticipantsreceivedatotalof70differentmessagesfromtheEclipserefactoringtool.Thefollowingarefourofthe15mostfrequentproblemsthattherefactoringtoolreportedtoourparticipants:1)WARNING:Codemodiρcationmaynotbeaccu-rateasaffectedresource‘resourcename’hascompileerrors.2)ERROR:Foundpotentialmatches.Pleasereviewchangesonthepreviewpage.3)ERROR:Selectedstatementscontainareturnstatementbutnotallpossibleexecutionσowsendinareturn.Semanticsmaynotbepreservedifyouproceed.4)WARNING:Avariablewithname‘variablename’isalreadydeρnedinvisiblescope.Thirteenparticipantsreceivedtheρrstmessageforatotalof89timesandperformedtherefactoring94%ofthetime.Twelveparticipantsreceivedthesecondmessageforatotalof31timesandperformedtherefactoring77%ofthetime.Figure4illustrateshowtoreproduceanerrormessagethattheExtractMethodrefactoringreportedtofourofourparticipantsforatotalof13times.In54%ofthecases,ourparticipantschosetocontinuetherefactoringandmanuallyadjustthecompilationproblemsoftheresultingcode.Figure5illustratesanexamplewheretheExtractLocalVariablerefactoringwarnstheprogrammeraboutnameshadowing.Twoparticipantsreceivedthiswarningforatotalofsixtimesandperformedtheunsaferefactoringρvetimes.Onemightarguethatprogrammersperformunsaferefac-toringbecauseitiseasiertointerpretandresolvecompi-lationproblemsthanunfamiliarrefactoringones[38].We241

askedourintervieweestoexplaintherefactoringproblemsthattheyhadreceivedfromthetool.Ourintervieweeshadunderstoodalmostalloftheerrormessagesofautomatedrefactorings.Onlyoneintervieweeconfusedtwoerrormes-sagesoftheExtractMethodrefactoring,andatleasttwoofourparticipantsstruggledwithastrangeerrormessageofExtractMethod.Ineverycase,theywereabletounderstandandresolvetheproblemeventually.Ourintervieweesmentionedthattheyreliedonthecompiler,visualinspection,andsometimesrunningtheirprogramsandteststoidentifythepossibleproblemsofrefactorings.However,visualinspection,compilerchecks,runsofprogramsandtests,andcodereviewsmaynotcatchthesubtleerrorsofrefactorings[3,p.391](SeeFigure5).Theintervieweesgaveusseveralreasonsforperformingunsaferefactorings.First,thereisanoverheadassociatedwithcancelingtherefactoringtoolandreconρguringit.Second,thechanceofintroducinganerrorwhenthetoolreportsawarningislow.Third,ourintervieweesclaimedthattheywerewellawareofthelimitationsoftherefactoringtoolandcouldeasilydetectandρxtheerrorsintroducedbythetool.Fourth,ourparticipantsignorednon-descriptivemessages.Forexample,noneofourintervieweesknewwhat(cid:147)potentialmatches(cid:148)meantintheaforementionederrormessage.Fiveintervieweessaidthattheysometimesmanuallyperformedafewstepsofarefactoringandintentionallyintroducedsomecompilationproblemstoρndallotherplacesthatneededtogetupdated.Eventhoughthiswayofperformingarefactoringisslowerthanusingtherefactoringtool,itismoreinteractiveandgivesmorecontroltotheprogrammer.B.UnjustiﬁedUsesWesuspectthatatleasttwoofourparticipantsoverusedtherefactoringtoolbecausetheytoldusthattheyalwaysusedanautomatedrefactoringifonewasavailablefortheirdesiredtask.However,itisnotalwaysoptimaltousetheautomatedrefactorings.Forexample,oneofourparticipantsusedtheChangeMethodSignaturerefactoringtochangethevisibilityofamethod.Visibilitychangescouldleadtosubtlechangesofaprogram’sbehavior.Nevertheless,Eclipsedoesnotcurrentlyperformthenecessarycheckstoguaranteethebehavior-preservationofsuchrefactorings[39].Thus,theuseoftheEclipserefactoringtooltochangethevisibilityofamethod,especiallyinsimplecases,isquestionable.Whenweaskedtheparticipantaboutthisparticularuseofthetool,hedidnothaveanyjustiρcations.Acombinationofexcessivetrustintherefactoringtoolandlowconρdenceinone’scodingabilitiesmightleadtothemisuseofthetool.Forexample,anintervieweetoldusthathealwaysusedthetooltoperformrefactoringsbecausehewasafraidofmakingmistakesinperformingtherefactoringmanually.Whileitiserror-pronetoperformsomerefactoringsmanually,programmerscanperformtheresteasily.C.ImplicationsWesuggestafewtechniquesfordesignersofrefactoringtoolstoavoidmisuse.Ahighrateoffalsealarmsmayleadtomistrustofthewarnings[20].Thus,reducingthenumberoffalsepositivesmightmitigatethemisuseofautomatedrefactoringswhentheyreportwarnings.Althoughitisvaluabletocommunicatetheerrormessagesbetter[18],ourparticipantsperformedunsaferefactoringseventhoughtheyhadunderstoodthemessages.Onewaytomitigatetheriskofunsaferefactoringsistoprovidespecial-izedtoolsthatverifytheresultsandassisttheprogrammersincompletingthetransformation.Ourparticipants’useofunsaferefactoringsandrelianceontheincrementalcompilertoperformarefactoringinsmallstepssuggestthatpredictabilityandinteractivitymaybemoreimportantfactorsinthedesignofrefactoringtoolsthanbehavior-preservation.Ifautomatedrefactoringspresentsomeoftheirintermediateresults,becomemoreinteractive,andgivemorecontroltotheprogrammer,theywillbecomemoretransparentandpredictable.Asaresult,programmerswillgainabetterunderstandingofthelimitationsoftheautomatedrefactoringsandusethemappropriately.Anothertechniquetoreducethemisuseofautomatedrefactoringsistomakethetoolsmoreσexible.Suchaσexibletoolwillattempttochangethecodetosatisfythepreconditionsorproposepossibleρxestotheprogrammerinsteadofjustreportingtheproblem[13].Also,wesuggestthattrainerswarnprogrammersaboutthepossibleexcessivetrustandmisusesofrefactoringtools.Trainerscouldmakeprogrammersawareoftheirexcessivetrustincertainautomatedrefactoringsandshowthemhowtoavoidormitigatetheconsequencesoftheirmisuses.VI.LIMITATIONSEventhoughastudysuchasourscapturesauthenticdata,itraisesprivacyissuesandmakesrecruitmentchallenging.Asaresult,themajorityofourparticipantsandallofourintervieweeswereattheuniversity(SeeSectionII).Theconρdentialityissuesmighthavealsoaffectedtheprojectsourparticipantshaveenabledourdatacollectorson.Becauseoftheuncontrollednatureofourstudy,thenumbersofprogramminghoursofourparticipantsvaryalot(SeeSectionII),andthenumberofopportunitiestoperformrefactoringsontheprojectsmighthavebeendifferent.CodingSpectatordidnotcapturedataabouttenautomatedrefactoringsinEclipse.Weprioritizedwhichautomatedrefactoringstostudybasedontheusagestatisticsreportedbyothers[5],[40].WeρxedsomeofthebugsofourdatacollectorsduringthestudyandwediscoveredsomebugsinEclipsethat242

mayhaveaffectedourdata.However,tothebestofourknowledgethesebugsintroducenegligiblenoiseinourdata.WecollecteddataonlyfromJavaprogrammerswhousedEclipse.However,wewereabletogeneralizeandsuggestimprovementstootherIDEsbasedonourresults.VII.RELATEDWORKParasuramanandRileydiscussedhumans’use,misuse,disuse,andabuseofautomation[20].Ourworkadaptedtheirframeworkinthreewaystoautomationofrefactorings.First,theydeρnedabuseasenforcingautomationbydesignersandmanagerswithoutconsideringtheconsequencesontheusers.Sincewedidnotρndanevidenceofabuseinthecontextofrefactorings,weexcludeditfromourframework.Second,weusedaslightlydifferentdeρnitionofmisuse.Theydeρnedmisuseasoverrelianceonautomation.Weconsideredusesofautomatedrefactoringsinwaysnotrecommendedbydesignersasmisuse.Finally,wehaveidentiρedthefactorsthatpertaintouse,misuse,anddisuseofautomatedrefactoringsspeciρcallyandnotautomationingeneral.Murphyetal.’sstudyof41developersusingtheJavatoolsinEclipsestimulatedresearchinthisarea[40].Theirstudycollectedfrequencydataontheinvokedperspectives,views,andcommands(refactoringsbeingasubset).TheirdataprovidedaholisticviewofhowoftenvariousfeaturesofEclipsewereusedandraisedquestionsabouthowuserswereusingthefeaturesoftheIDEs.Ourinteractiondatacollectionmethodsaresimilarbecausewebothcollectdatafromprogrammersintheirnaturalsettings.However,thefocusofourworkwasonrefactoringsandwesupplementedourquantitativedatabyqualitativeones.Murphy-Hilletal.analyzedapoolofexistingdataaboutrefactoringsfromMurphyetal.[40],theEclipsefoundation[41],andtherefactoringhistoriesof12Eclipsedevelopers.Inaddition,theysurveyedρveEclipsedevel-opers.Theyweretheρrsttoshowsomeevidencefortheunderuseofautomatedrefactorings,andconcludedthatfurtherstudiesarerequiredtounderstandwhydeveloperssometimeschoosenottousetherefactoringtools.Ourstudybuildsupontheirsanddiscussestheimpactofmanyfactorsontheunderuseofautomatedrefactorings.Forexample,ourresultssuggestthattrustinthestate-of-the-artrefactoringtoolsisinσuencedmorebyusabilitythanreliability.Inanotherstudy,Murphy-Hilletal.examinedbarrierstousingtheExtractMethodrefactoring[18].TheyinstructedtheirparticipantstoapplytheExtractMethodrefactoringonafewopen-sourceprojects.Theyobservedthatusersfrequentlymademistakesinselectingthecodesnippettoextractandthattheerrormessagesfromthetoolswerehardtounderstand.Basedonthisobservation,theypro-posedvisualrepresentationsoftheerrormessages.Wealsoobservedthatselectionproblemswerecommon:tenofourparticipantsencounteredsuchproblems.However,ourintervieweesinformedusthattheywereabletointerpretthemessages.Thisdifferenceinresultsmaybeduetothedifferencesofthestudiedpopulationsintheirlevelsofexpertiseorfamiliaritywiththecodeunderrefactoring.Whilesomeoftheresultsofthetwostudiesoverlap,thefocusofourworkwasidentifyingthefactorsthatdeterredprogrammersfromusingautomatedrefactoringsratherthanresolvingaspeciρcusabilityissue,i.e.badmessages,oftheExtractMethodrefactoring.Mealyetal.listed38guidelinesforrefactoringtoolsbyanalyzingtheliteraturesofindustrialusabilitystandardsandhumanfactors[17].Ourapproachesarecomplementarybecauseweproposedimprovementstothedesignofrefac-toringtoolsbasedontheactualusabilityproblemsthatourparticipantshadencountered.VIII.CONCLUSIONSOurquantitativedataandinterviewsrevealedmanyfac-torsthataffecttheappropriateandinappropriateusesofautomatedrefactorings.Wefoundthatprogrammersdonotusesomeautomatedrefactoringsbecausetheyareunawareofthem,theoverheadoflearningandconρguringsomeautomatedrefactoringsdoesnotjustifythefewopportunitiestousethem,thenamesofsomeautomatedrefactoringsareconfusing,andprogrammerscannotpredicttheoutcomesofcomplextools.Ontheotherhand,programmersappreciatethetoolsthatproposeapplicablerefactorings,andarewillingtouseautomatedrefactoringsevenwhentheymaychangetheprogram’sbehavior.Ourstudyshowsthatthemajorbarriertotheadoptionofrefactoringtoolsistheirusabilityproblemsnottheirrarebugs.Theseresultssuggestthatdesignersshouldaimforσexible,predictable,andtrulyinteractiveautomatedrefactoringsinthedesignofnextgenerationsofrefactoringtools.ACKNOWLEDGMENTWethankChrisAniszczyk,DeepakAzad,DannyDig,Mi-losGligoric,NathanielHirtz,DarkoMarinov,andRoshanakZilouchianMoghaddamfortheirassistanceandourpar-ticipantsfortakingpartinthestudy.Thisworkispar-tiallysupportedbyNSFCCF11-17960,DOEDE-FC02-06ER25752,theInstituteforAdvancedComputingApplica-tionsandTechnologies(IACAT),andtheUniversalParallelComputingResearchCenter(UPCRC)attheUniversityofIllinois.REFERENCES[1]W.F.Opdyke,(cid:147)RefactoringObject-OrientedFrameworks,(cid:148)Ph.D.dissertation,Univ.ofIllinoisatUrbana-Champaign,1992.[2]K.Beck,ExtremeProgrammingExplained.Addison-Wesley,2010.[3]M.Fowler,Refactoring:ImprovingtheDesignofExistingCode.Addison-Wesley,1999.243

[4]Z.XingandE.Stroulia,(cid:147)RefactoringPractice:HowitisandHowitShouldbeSupported(cid:150)AnEclipseCaseStudy,(cid:148)inICSM,2006.[5]E.Murphy-Hill,C.Parnin,andA.P.Black,(cid:147)HowWeRefactor,andHowWeKnowIt,(cid:148)IEEETrans.SoftwareEng.,2011.[6]D.Roberts,J.Brant,andR.Johnson,(cid:147)ARefactoringToolforSmalltalk,(cid:148)Theor.Pract.ObjectSyst.,1997.[7](cid:147)Eclipse,(cid:148)http://www.eclipse.org/.[8](cid:147)NetBeans,(cid:148)http://netbeans.org/.[9](cid:147)IntelliJIDEA,(cid:148)http://www.jetbrains.com/idea/.[10](cid:147)Xcode,(cid:148)http://developer.apple.com/xcode/.[11](cid:147)ReSharper,(cid:148)http://www.jetbrains.com/resharper/.[12]B.Daniel,D.Dig,K.Garcia,andD.Marinov,(cid:147)AutomatedTestingofRefactoringEngines,(cid:148)inESEC-FSE,2007.[13]M.Sch¤afer,T.Ekman,andO.deMoor,(cid:147)SoundandExten-sibleRenamingforJava,(cid:148)inOOPSLA,2008.[14]J.Wloka,M.Sridharan,andF.Tip,(cid:147)RefactoringforReen-trancy,(cid:148)inESEC/FSE,2009.[15]F.Kjolstad,D.Dig,G.Acevedo,andM.Snir,(cid:147)Transforma-tionforClassImmutability,(cid:148)inICSE,2011.[16]J.L.OverbeyandR.E.Johnson,(cid:147)DifferentialPreconditionChecking:ALightweight,ReusableAnalysisforRefactoringTools,(cid:148)inASE,2011.[17]E.Mealy,D.Carrington,P.Strooper,andP.Wyeth,(cid:147)Im-provingUsabilityofSoftwareRefactoringTools,(cid:148)inASWEC,2007.[18]E.Murphy-HillandA.P.Black,(cid:147)BreakingtheBarrierstoSuccessfulRefactoring:ObservationsandToolsforExtractMethod,(cid:148)inICSE,2008.[19]E.Murphy-Hill,M.Ayazifar,N.Carolina,andA.P.Black,(cid:147)RestructuringSoftwarewithGestures,(cid:148)inVL/HCC,2011.[20]R.ParasuramanandV.Riley,(cid:147)HumansandAutomation:Use,Misuse,Disuse,Abuse,(cid:148)J.HumanFactorsandErgonomicsSoc.,1997.[21]M.Vakilian,N.Chen,S.Negara,B.A.Rajkumar,R.Zilouch-ianMoghaddam,andR.E.Johnson,(cid:147)TheNeedforRicherRefactoringUsageData,(cid:148)inPLATEAU,2011.[22]M.Vakilian,N.Chen,S.Negara,B.A.Rajkumar,B.P.Bailey,andR.E.Johnson,(cid:147)Use,Disuse,andMisuseofAu-tomatedRefactorings(ExtendedVersion),(cid:148)http://hdl.handle.net/2142/27730,Univ.ofIllinoisatUrbana-Champaign,Tech.Rep.,2012.[23]J.M.CorbinandA.L.Strauss,BasicsofQualitativeRe-search:TechniquesandProceduresforDevelopingGroundedTheory.SagePublications,2008.[24]N.Tsantalis,(cid:147)EvaluationandImprovementofSoftwareArchitecture:IdentiρcationofDesignProblemsinObject-OrientedSystemsandResolutionthroughRefactorings,(cid:148)Ph.D.dissertation,Univ.ofMacedonia,2010.[25]R.Marinescu,(cid:147)DetectionStrategies:Metrics-BasedRulesforDetectingDesignFlaws,(cid:148)inICSM,2004.[26]E.Murphy-HillandA.P.Black,(cid:147)AnInteractiveAmbientVisualizationforCodeSmells,(cid:148)inSoftVis,2010.[27]C.Parnin,C.G¤org,andO.Nnadi,(cid:147)ACatalogueofLightweightVisualizationstoSupportCodeSmellInspec-tion,(cid:148)inSoftVis,2008.[28]A.Bessey,K.Block,B.Chelf,A.Chou,B.Fulton,S.Hallem,C.Henri-Gros,A.Kamsky,S.McPeak,andD.Engler,(cid:147)AFewBillionLinesofCodeLater:UsingStaticAnalysistoFindBugsintheRealWorld,(cid:148)Comm.ACM,2010.[29]A.CockburnandL.Williams,(cid:147)TheCostsandBeneρtsofPairProgramming,(cid:148)XP,2000.[30]E.Murphy-HillandG.C.Murphy,(cid:147)PeerInteractionEffec-tively,yetInfrequently,EnablesProgrammerstoDiscoverNewTools,(cid:148)inCSCW,2011.[31]J.D.LeeandK.A.See,(cid:147)TrustinAutomation:DesigningforAppropriateReliance,(cid:148)J.HumanFactorsandErgonomicsSoc.,2004.[32]P.Madhavan,D.A.Wiegmann,andF.C.Lacson,(cid:147)Au-tomationFailuresonTasksEasilyPerformedbyOperatorsUndermineTrustinAutomatedAids,(cid:148)J.HumanFactorsandErgonomicsSoc.,2006.[33]N.S.Shami,M.Muller,andD.Millen,(cid:147)BrowseandDis-cover:SocialFileSharingintheEnterprise,(cid:148)inCSCW,2011.[34]M.Sch¤afer,M.Sridharan,J.Dolby,andF.Tip,(cid:147)RefactoringJavaProgramsforFlexibleLocking,(cid:148)inICSE,2011.[35]D.Dig,J.Marrero,andM.D.Ernst,(cid:147)RefactoringSequentialJavaCodeforConcurrencyviaConcurrentLibraries,(cid:148)inICSE,2009.[36]M.Vakilian,D.Dig,R.L.Bocchino,Jr.,J.L.Overbey,V.Adve,andR.Johnson,(cid:147)InferringMethodEffectSum-mariesforNestedHeapRegions,(cid:148)inASE,2009.[37](cid:147)EclipseDocumentationonRefactoringWizard,(cid:148)http://help.eclipse.org/indigo/topic/org.eclipse.jdt.doc.user/reference/ref-wizard-refactorings.htm.[38]E.Murphy-Hill,(cid:147)AModelofRefactoringToolUse,(cid:148)inWRT,2009,http://people.engr.ncsu.edu/ermurph3/papers/wrt09.pdf.[39]F.SteimannandA.Thies,(cid:147)FromPublictoPrivatetoAbsent:RefactoringJavaProgramsunderConstrainedAccessibility,(cid:148)inECOOP,2009.[40]G.C.Murphy,M.Kersten,andL.Findlater,(cid:147)HowAreJavaSoftwareDevelopersUsingtheEclipseIDE?(cid:148)IEEESoftware,2006.[41](cid:147)EclipseUsageData,(cid:148)http://www.eclipse.org/epp/usagedata.Detecting Data Races on Framework-Based
Applications

Federico Balaguer, Thuc S. M. Ho , Ralph Johnson
Department of Computer Science
University of Illinois at Urbana-Champaign
Email: {balaguer,mauhosi2,johnson}@uiuc.edu

s. F

s.

Abstract (cid:132)

k-

s.

Da
a. H

l.

s. T

n.

I . IN TRODUC T ION
Multi-threading programming has increased along with the
popularity of web-services and server-applications. Multi-
threading programming is used on the server side for handling
connections and in the client side for performing background
operations [15]. Threads provide great beneﬁts but they are
hard to use and debug as they make the expected behavior of
code less apparent [4].
Threads can affect the behavior of applications developed
with frameworks. Frameworks are an object-oriented reuse
technique and are widely used in many application domains
[11], [16]. Frameworks provide template execution paths (ﬂow
of control) that eventually call code provided by the applica-
tion [8]. Although the framework assumes it is in control, it
relies at some point on the code provided by the application.
This code can use other frameworks which in turn will assume
control over the execution. Between each framework lies
the code of the application that has to ﬁll the gaps among
frameworks. Figure 1 shows the code of the operation doPost()
that will be called from a servlet framework. Inside this
operation another framework is used to retrieve from and save
objects to a database.
There are many factors that can determine whether this
piece of code has a data race. First, different Http requests
can be handled with just one servlet or a new servlet can
handle each of them. Second, the persistence framework can
make blocking or non-blocking calls to the database. Third,
queries and SQL commands can be performed outside or
inside transactions, moreover the transaction semantics can
vary. A data race is a sign that the chain of execution between
frameworks is broken. Data races are a non-atomic execution

pS e
pS e
// Pseudo code
//retrieve or create account
account =
WebAccount.factory(req.getParameterValues(”ACC”));
//update account
account.update(req);
//save in db (insert / update)
writeResponse(account.save(), rsp);

Fig. 1.

doPost() operation of a servlet framework

of critical sections [21]. We found cases where data races exist
even when the observable results in the database were correct.
By changing the database settings we were able to produce
inconsistencies in the database.
This paper presents a technique for ﬁnding data races on ap-
plications developed using multiple frameworks. Our approach
has two steps. First, traces are collected from the application
execution. The traces are represented as execution trees [17]
and are collected at those points where the frameworks hands
control over to the application code. Second, traces are used
to compute a set of conﬂicting accesses using the LockSet
algorithm as described in [26]. von Praun et al showed that
conﬂicting accesses are good approximations to data races
[28].

A. Frameworks Collision
Frameworks are usually designed under the assumption that
they are in control of the execution of the application using
them [16]. Berlin showed that inconsistencies can appear in an
application when multiple frameworks implement their own
event-loop [3]. Garlan et al described how a user-interface
framework and a network messaging framework interfere with
each other; when one of the frameworks is in control the other
one loses events [12].
The problem we are describing is different. One framework
that has control over the execution of an application hands
control over to another framework that does not fulﬁll its
expectations. For example, servlets such as the one in Figure 1
are implemented out of web frameworks that eventually call
the d
or d
functions. The servlet frame-
works are responsible for providing the multi-threading model
in which one instance of a servlet can service one connec-
tion (monothreading) or multiple connections (multithreading).

Proceedings of the 30th Annual International Computer Software and Applications Conference (COMPSAC'06)0-7695-2655-1/06 $20.00  © 2006R
a
c
e
c
o
n
d
i
t
i
o
n
s
a
r
e
h
a
r
d
t
o
d
e
t
e
c
t
i
n
f
r
a
m
e
w
o
r
b
a
s
e
d
a
p
p
l
i
c
a
t
i
o
n
r
a
m
e
w
o
r
k
s
o
f
t
e
n
i
m
p
r
o
v
e
p
e
r
f
o
r
m
a
n
c
e
b
y
p
r
o
v
i
d
i
n
g
t
h
r
e
a
d
i
n
g
,
b
u
t
t
h
i
s
t
h
r
e
a
d
i
n
g
i
s
u
s
u
a
l
l
y
h
i
d
d
e
n
f
r
o
m
a
p
p
l
i
c
a
t
i
o
n
p
r
o
g
r
a
m
m
e
r
T
h
e
r
e
f
o
r
e
,
i
t
i
s
e
a
s
y
f
o
r
a
p
p
l
i
c
a
t
i
o
n
p
r
o
g
r
a
m
m
e
r
s
t
o
a
c
c
i
d
e
n
t
a
l
l
y
c
r
e
a
t
e
d
a
t
a
r
a
c
e
t
a
r
a
c
e
s
c
a
n
b
e
d
e
t
e
c
t
e
d
t
r
a
c
i
n
g
t
h
e
(cid:148)
o
w
o
f
e
x
e
c
u
t
i
o
n
,
b
u
t
t
r
a
c
i
n
g
t
e
n
d
s
t
o
p
r
o
d
u
c
e
t
o
o
m
u
c
h
d
a
t
o
w
e
v
e
r
,
t
h
e
s
t
r
u
c
t
u
r
e
o
f
f
r
a
m
e
w
o
r
k
s
c
a
n
b
e
u
s
e
d
t
o
c
o
n
t
r
o
l
t
h
e
a
m
o
u
n
t
o
f
d
a
t
a
c
o
l
l
e
c
t
e
d
a
n
d
t
h
a
t
m
a
k
e
s
t
r
a
c
i
n
g
p
r
a
c
t
i
c
a
W
e
h
a
v
e
d
e
v
e
l
o
p
e
d
a
t
r
a
c
i
n
g
a
n
d
a
n
a
l
y
s
i
s
t
o
o
l
t
h
a
t
a
l
l
o
w
s
a
p
p
l
i
c
a
t
i
o
n
p
r
o
g
r
a
m
m
e
r
s
t
o
e
x
p
l
o
r
e
d
i
f
f
e
r
e
n
t
c
o
n
(cid:147)
g
u
r
a
t
i
o
n
s
o
f
a
n
a
p
p
l
i
c
a
t
i
o
n
a
n
d
(cid:147)
n
d
p
r
o
b
a
b
l
e
d
a
t
a
r
a
c
e
h
i
s
e
n
a
b
l
e
s
t
h
e
m
t
o
h
a
v
e
m
u
t
i
t
h
r
e
a
d
e
d
f
r
a
m
e
w
o
r
k
s
s
a
f
e
l
y
w
i
t
h
o
u
t
h
a
v
i
n
g
t
o
l
e
a
r
n
t
h
e
d
e
t
a
i
l
s
o
f
t
h
e
f
r
a
m
e
w
o
r
k
d
e
s
i
g
d
o
P
o
s
t
(
H
t
t
r
v
l
e
t
R
e
q
u
e
s
t
r
e
q
,
H
t
t
r
v
l
e
t
R
e
s
p
o
n
s
e
r
s
p
)
o
P
o
s
t
(
)
o
G
e
t
(
)
Usually developers of servlets have no control over the com-
putation before the servlets are called and the only opportunity
they have to implement functionality is inside d
and
. The servlet in Figure 1 retrieves an object from a
database, updates ﬁelds in the account object and ﬁnally stores
the object back into the database using some persistent frame-
work. Usually, persistence frameworks take care of database
connection, sessions and transactions and allow developers to
customize the mapping between objects and tables. Problems
can arise if the persistence framework makes non-blocking
calls to the database because that could unexpectedly yield
control of the servlet allowing other servlets to run.
One alternative to minimize the possibility of data races in
framework-based applications is to create critical sections at
the point where the framework calls the application code. For
many frameworks this is impractical because of the restrictions
it imposes on applications. Another alternative is to force
developers to run the code that interacts with the framework
in only one thread. Swing uses this solution and experience
shows that
it
is difﬁcult
to program [24]. No matter the
solution is based on critical sections, semaphores or advanced
thread programming, developers need to ﬁnd the source of the
problem. Our approach allows developers to explore different
conﬁgurations of the system and study the effect that each
conﬁguration has on shared state.

B. Manipulating Traces

Lange and Nakamura presented several techniques to dis-
play the execution information of programs [18]. These tech-
niques are based on Execution Trees. Each tree represents
the execution of a function that is the root of the tree [23].
Figure 2 shows an execution tree representing the execution
of d
of the servlet in Figure 1.

Fig. 2. Execution Tree of operation doPost()

Nodes in the tree can be one of ﬁve possible node types:
n In
nodes represent the invocation of
primitive functions or messages sent
to some object.
When a function invocation is root of a tree, the branches
represent the execution of that function.
e Ac
nodes represent assignments and reads
to a variable.

nodes represent nodes that give up
control such as yield, and semaphore operations.

nodes represent
the end of the execution of
function invocation, in normal conditions the rightmost
node of a tree is a return node
nodes represent loops and if-then-else structures
The sequence of execution for one tree can be generated by
doing the pre-order traverse of the nodes, that is, visiting ﬁrst
the root and then recursively visiting each of the child nodes.
Execution trees scale to multi-threaded programs but a
broader context is needed since one execution tree is only
responsible for what is done by one thread. Multi-threaded
programs are represented by a set of competing execution
trees that gain and relinquish control over the execution. Once
the execution trees are established for each thread a tool
can automatically produce a sequence of execution among
the threads and also the sequence in which objects and their
variables are accessed.

I I . F IND ING CON FL IC T ING ACC E S S E S

A. LockSet algorithm
Savage et al presented the LockSet algorithm as part of
Eraser, a tool for ﬁnding data races [26]. LockSet searches for
shared-memory references that don’t have a consistent locking
behavior.
Given a non empty set of execution trees that represent
threads of a program, it is possible to ﬁnd possible conﬂicting
accesses by computing the set of variable accesses. Each
variable access carries the following information:
: identiﬁcation of the thread
the identiﬁcation of the variable being accessed.
The identiﬁcation of the variable is a composed key
with objectID and the index of the variable inside the
containing object.
: the kind of access, it can be either r
.
the identiﬁcation of the function issuing the access
the program counter
: the set of semaphores acquired (but not re-
leased) by the thread until this point in the execution.
A conﬂicting access happens when in the set of variable
access at
two tuples access the same variable, are
least
generated by different threads, at least one of them is a write
and intersection of acquired locks is empty.

or

B. Green LockSet
LockSet is a simple algorithm and it gives too many false
positives. Eraser implements a modiﬁed version of LockSet
that consider the following exceptions:
initialization, read-
share data and read-write locks. Another source of improve-
ment can be the thread scheduling policy. There are widely
accepted scheduling policies based on non-preemptible coop-
erative threads i.e. ﬁbers that are used in many object-oriented
systems. Fibers, also known as green threads, are thread
libraries implemented at the process level. They are indepen-
dent of the operating system and primarily implemented in
user-space. In ﬁbers-based scheduling a thread yields control

Proceedings of the 30th Annual International Computer Software and Applications Conference (COMPSAC'06)0-7695-2655-1/06 $20.00  © 2006o
P
o
s
t
(
)
d
o
G
e
t
(
)
o
P
o
s
t
(
)
(cid:128)
F
u
n
c
t
i
o
v
o
c
a
t
i
o
n
(cid:128)
V
a
r
i
a
b
l
c
e
s
s
(cid:128)
C
o
n
t
r
o
l
P
r
i
m
i
t
i
v
e
(cid:128)
R
e
t
u
r
n
(cid:128)
J
u
m
p
(cid:128)
t
i
d
(cid:128)
v
i
d
(cid:128)
k
i
n
d
e
a
d
w
r
i
t
e
(cid:128)
f
i
d
(cid:128)
p
c
(cid:128)
S
e
m
S
e
t
voluntarily by calling a thread primitive such as s
or implicitly by making non-blocking call. This is important
because the lack of time-slicing makes the execution of the
system possible to simulate. Figure 3 shows an execution tree
of our WebAccount servlet example. The tuple < t 1, v1... >
represents the access to the variable v1 by the thread t 1. It is
possible to infer that the servlet will yield control twice before
returning control to the servlet framework, if it is using non-
blocking calls to the database (I/O). However, if the servlet
is using blocking calls, it will not yield control and then the
access tuple < t 1, v1... >
is unique for the variable v1 .

Fig. 3. Execution Tree of operation doPost() with I/O

, it visits

We extend the LockSet algorithm with the semantics of
green threads. Given a collection of ExecutionTrees the re-
sulting Green LockSet algorithm visits the nodes in each tree
following green thread scheduling policy. The algorithm reacts
to the types of node as follows:
(cid:128) For each node representing a f
the children of that node.
(cid:128) For each node representing a v
, it
adds the access to the set of variable accesses. The
algorithm checks for LockSet’s conﬂicting accesses.
(cid:128) For each node representing an operation that c
, it checks if the operation yields control or
is a semaphore operation. In the ﬁrst case, the algorithm
picks the next-to-run thread. For operations acquiring
or releasing a semaphore it computes the state of the
semaphore and proceeds accordingly.
(cid:128) For each node representing a r
, it checks whether
the thread ended its computation. When a thread ﬁnishes
the algorithm removes all accesses added to the set of
variable accesses
(cid:128) For each node representing a j
, it visits the j
subtree accordingly.
The set of operations that are considered control primitives
can be changed making simple blocking operation into a non-
blocking one. This in turn will change the way variables are
accessed in the execution tree.

’s

I I I . IM P L EM EN TAT ION

A. Tracing Tool
Our current design of the tracing tool contains the following
main components: tracers, tracing service, trace logs, and a
trace viewer. They are built upon the concept of activation
points that keep track of tracing information.

An activation point is an abstraction representing the set of
information collected by the tracer after each stepping activity.
For stack-based virtual machines such as the Java Virtual
Machine or the Smalltalk virtual machine in VisualWorks,
activation points can populate its internal data structure from
the stack frame (the method invocation context right after a
step). In our implementation (Figure 4), an activation point
stores the compiled code, byte code index, the class imple-
menting the method, the receiver’s actual class, the selector
associated with the compiled code (if one exists) and the hash
of the receiver object as an object identity. For child processes
(threads) activation points have an extra reference to the tracer
attached to the child process. This allows connecting the parent
trace log with the child trace log.
Activation points also keep track of types of activities being
performed (a message sending, a jump, a variable assignment,
a variable read, a loop or a return from method invocation).
They are kept in the a
list in ﬁgure 4. This information
is useful while analyzing the trace log contents. Part of these
information can be generated by running additional tools after
the trace process ﬁnishes. It may be desirable to extend the
contents of an activation point to ﬁt the kind of analysis
required on a trace log. Figure 4 shows the ﬁelds of an
ActivationPoint.

< compiledCode, pc, methodClass, receiverClass,
selector, objectId, action>
compiledCode = thread id
pc = byte code index
methodClass = the class implementing the method
receiverClass = the receiver’s actual class
selector = the method name associated with the compiled code
objectId = the hash of the receiver object as an object identity.
action = list of activities associated with the activation point.

Fig. 4. ActivationPoint Tuple

Tracer and TracingService (Figure 5) are two major com-
ponents of the tracing tool. A Tracer creates and drives the
simulated execution of code using its tracing service and keeps
the log of activation points. The tracing service performs
the actual simulated execution of code and can be derived
from existing debugging service or debugging API in the
development environment. For multi-threaded programs, each
thread is served by one tracer. It also notiﬁes the tracer object
when each stepping activity is completed. Additional types of
stepping activities are added to the tracing service to address
a variety of program behaviors outside the capability of a
common debugger. In particular, whenever the program under
tracing creates a new thread, the current tracer forks a new
tracer instance to trace that thread separately. When that thread
ﬁnishes, the trace log is merged back to its parent’s trace
log at the forking point. This ﬂexible approach to tracing
multi-threaded programs allows us to obtain trace logs for
multiple threads independently. Different trace logs can be
combined later for analytical purposes. In latter cases, some
preprocessing may be required before trace logs are suitable

Proceedings of the 30th Annual International Computer Software and Applications Conference (COMPSAC'06)0-7695-2655-1/06 $20.00  © 2006u
s
p
e
n
d
u
n
c
t
i
o
n
c
a
l
l
a
r
i
a
b
l
e
a
c
c
e
s
s
o
n
t
r
o
l
p
r
i
m
i
t
i
v
e
s
e
t
u
r
n
u
m
p
u
m
p
c
t
i
o
n
ExecutionTreeNode

THREAD

*
1

ActivationPoint

Tracer

ExecutionTree

TracingService

TraceViewer

ProcessTracer BlockTracer

BlockActivationPoint ForkingActivationPoint

DebuggerService

Fig. 5. Class Diagram of the core classes of the Tracer

for analysis.
We discovered that a debugging service in VisualWorks
always forks service threads to perform its duties. When
the tracer is used to trace multi-threading programs, threads
under tracing will be scheduled together with those service
threads by the system default process scheduler. This may
lead to incorrect behavior e.g. the trace log may represent
a sequence of events that is different from the true event
sequence when the multi-threading program runs outside the
tracer. Interesting, this is exactly an instance of the multi-
threading programming issue discussed in this paper, when the
chain of execution is broken by unexpected collaboration of
reusable source codes. In VisualWorks, the DebuggerService
is more than just a class library, and it assumes its own model
of thread handling, which is in conﬂict with the tracer thread
model. We solved this problem by adapting the tracer to the
implicit multi-threading nature of the tracing service built upon
debugger service. Specially, we introduced a set of semaphores
managed by the main tracer (the tracer that is created ﬁrst)
that imposes the correct execution order on program threads
scheduled by the default process scheduler.
In applying our tracing tool for detecting data race condi-
tions on framework-based applications, we generally do not
have to trace into the framework code. Instead, the pieces
of code in focus will be user-developed parts that will in-
teract with framework components and/or get called by the
framework itself. This is partly due to the inversion of control
characteristics of framework-based applications [11, Chap1-2].
This fact helps to ﬁght against the log size explosion problem
and eases the analysis of trace logs later. To achieve this, users
of our tracing tool can deﬁne proper conﬁgurations for the
tracer to run. This method is used to obtain the trace logs for
our case studies.
A trace log is ﬁrst generated as a sequence of activation
points. Then, based on the relative relations between activation
points, a tree-like structure is built that represents the activation
points in calling sequence. Every level of a trace log begins
and ends with a pair of activation points that correspond to
the ﬁrst message call and the returning call. As mentioned
above, several trace logs can be generated independently or
concurrently and then combined for later analysis.
There can be many ways to visualize the tracing log.
One of the possibilities is implemented in the TraceViewer.
TraceViewer displays the tracing log as a tree-like hierarchy
plus reference to the source code with the step taken high-

Fig. 6. Partial view of a trace log inside the TraceViewer

lighted. One can easily trace through the code by navigating
the tree hierarchy. A screenshot of the trace log obtained in
the Seaside-PPL case study described in subsection IV-B is
displayed in ﬁgure 6.
Our current implementation of the tracing tool in Visual-
Works Smalltalk is depicted by Figure 5. Class ActivationPoint
represents an activation point. Its subclasses BlockActivation-
Point and ForkingActivationPoint describe an activation point
that occurs inside a block or when a child thread forks,
subsequently. Tracer class is responsible for most of operations
that a tracer requires. BlockTracer and ProcessTracer are used
to trace a block of code and a whole process. TracingSer-
vice inherits from existing DebuggerService in VisualWorks
system library and serves the request from tracer objects.
ExecutionLog represents the tree-like structure of trace logs
and TraceViewer is a GUI tool to visualize the trace log.

B. Data Race Finder (DRF)
The Data Race Finder (DRF) has a simple class model
(Figure 7) based primarily in two classes: TracePlayer and
TraceCoordinator.

TracePlayer

TraceCoordinator

ExecutionTree

TraceBlocker

Fig. 7. Classes implementing the Data Race Finder

Instances of class TracePlayer are always associated with
one ExecutionTree and one instance of TraceCoordinator. A
TracePlayer is able to traverse its ExecutionTree simulating the
execution. It means that it recognizes c
operations. Any scheduling decision is implemented in the
class TraceCoordinator. One instance of TraceCoordinator has
one association with at least one TracePlayer which informs
it about any scheduling related event. Each TraceCoordinator
has a queue of ready-to-run players and a collection of objects
representing semaphores in use (TraceBlocker). Every running

Proceedings of the 30th Annual International Computer Software and Applications Conference (COMPSAC'06)0-7695-2655-1/06 $20.00  © 2006o
n
t
r
o
l
p
r
i
m
i
t
i
v
e
instance of DRF has one TraceCoordinator for scheduling the
TracePlayers. TraceBlocker class represents objects that can
block the execution of a TracePlayer. Instances of this class
are used to represent semaphores and locks. Each instance has
a collection of blocked Players.
Users of the tool need to load the Execution Trees that will
be part of the simulation. The top pane in Figure 8 is a list
representing the ready queue of the TraceCoordinator. As the
simulation progresses this list changes because TracePlayer
can fork new TracePlayers, ﬁnish or get blocked by a blocker.

Fig. 8.

Interface of the Data Race Finder

The bottom area of the tool is the log where messages are
printed. The buttons on the ”logging” box control how DRF
behaves ones users gives the run command. The options are:
: logging each function call in the simulation as
seeing by the corresponding TracePlayer
: simulating thread scheduling
: logging accesses to variables
ﬁ d
: logging conﬂicting accesses

IV. CA S E S TUD I E S

We need to test our ideas and techniques on tracing and
data race detection. One thing is to validate our claim that
by tracing the framework ﬂow of control we can minimize
the amount of collected data. Among others, we want
to
convince ourselves on the effectiveness of post-mortem trace
log analysis in data race detection.
We applied the techniques and tools described in previous
sections in two following case studies. The ﬁrst case study is a
simple servlet-based web-application where the servlet engine
generates concurrent accesses to shared objects in memory.
The second case study is a more sophisticated example that
uses a web application framework called Seaside together
with PPL, an object-relational persistence framework. The
case studies illustrate common problems in multi-threading
programming with web and server applications as mentioned
in the introduction section.

A. Servlet-Based Web-Application
Servlet is a common way to provide dynamic contents for
web applications. Servlets work closely with domain-speciﬁc
frameworks to fulﬁll the needs of an application. In this case
study we build a servlet-based web application that allows
users to browse and register themselves for training courses.
The servlet engine is provided by Web Toolkit extension in
VisualWorks. The example is an extension to Web Toolkit
that is part of the Cincom VisualWorks Smalltalk [1]. In this
example, Toyz is the name of a ﬁctitious company that offers
its own employees to register for on-line courses. To keep the
case study simple, domain objects are created and manipulated
entirely in the web application memory space. They are shared
between various sessions. In reality, however, domain objects
are often kept under control by external services such as web
services or persistence frameworks, many of them utilize an
asynchronous service model.
The servlet ServletAddCourse in Figure 9 is responsible
for adding a new course for a registered web user. This
servlet inherits from HttpServlet, which allows only a single
servlet object to serve many different requests. As usual, the
servlet carries out its duty in a http POST request handler,
as shown below. However, ServletAddCourse delegates the
actual domain processing to a set of utility classes, including
a factory class (Toyz). Toyz on its side queries and updates
the domain objects to serve each servlet request. In particular,
a shared SortedCollection object is used to keep registered
courses for all employees. This object is read during the call to
getNumberOfRegisteredCoursesFor: and modiﬁed in addXref:.

ServletAddCourse>> doPost: aRequest response: aResponse
| courseNumber mySession eNumber |
courseNumber := aRequest anyFormValueAt: ’courseNumber’.
mySession := aRequest session.
eNumber := (mySession at: ’signon’) number.
Toyz instance addCourse: courseNumber to: eNumber.
aResponse redirectTo: ’j2eeEmployeecourses6.ssp’

Toyz>> addCourse: courseNumber to: employeeNumber
| eName cName num |
num := self getNumberOfRegisteredCoursesFor: employeeNumber.
num < 4 ifTrue:
[ eName := self getEmployeeName: employeeNumber.
cName := self getCourseName: courseNumber.
self addXref: (Xref new employeeNumber: employeeNumber
employeeName: eName courseNumber: courseNumber courseName: cName)]

Fig. 9. Smalltalk Source Code for Adding Course

We obtain trace logs for servlet execution during http POST
requests for two concurrent sessions. The tracer is ﬁne-tuned
to trace instructions involving querying and updating list data
structures, which are skipped by default. This suggests that
while looking for possible data races, we already aim at some
suspicious pieces of code. This appears to be productive in
practice but requires some a priori knowledge of the code
under tracing. The data race detector reveals a data race
condition deeply buried inside list data structure operations.
Following the steps of our approach, we traced two concur-
rent accesses of the servlet and loaded the obtained execution
trees into DRF. That sets the scenario when the application

Proceedings of the 30th Annual International Computer Software and Applications Conference (COMPSAC'06)0-7695-2655-1/06 $20.00  © 2006(cid:128)
s
t
e
p
s
(cid:128)
y
i
e
l
d
(cid:128)
v
a
r
i
a
b
l
e
s
(cid:128)
v
a
r
i
a
b
l
e
s
a
t
a
r
a
c
e
s
servlet is handling two requests for the same domain object.
We ran the LockSet algorithm and found a number of conﬂict-
ing accesses. One of them is presented in Figure 10. We ran
the tool again with Green LockSet algorithm and the above
conﬂicting access was not reported.

Variable Access Violation: 7250.ﬁrstIndex
’servlet-ﬁrst’ SortedCollection:7250 (OrderedCollection) insert:before: WRITE: 1
’servlet-second’ SortedCollection:7250 (OrderedCollection) do: LOOP

Fig. 10. Output showing a Conﬂicting Access with Servlets

The ﬁrst line on Figure 10 is a write operation on the
instance variable ﬁrstIndex for a SortedCollection object,
whereas the second line corresponds to read operations inside
a LOOP based on that instance variable.

B. Seaside and PPL
Seaside [2], [10] is a mature Smalltalk framework for build-
ing industrial-strength web applications. Seaside framework
users can enjoy the power of object-oriented programming in
Smalltalk and a rich set of features:
the servlet architecture of Seaside as a web application
server.
a session object accessible from any web page.
components (Smalltalk objects) that know how to render
themselves as HTML pages and process user requests
continuation-based multiple control ﬂow that allow de-
velopers to approach dynamic web pages in a manner
similar to common GUI interface manipulation
transactions that help isolate a set of related actions
(including user interaction) with ﬂow control over page
navigation.
We applied our tracing tool to study the architecture of
Seaside. In particular, the tracing tool has been used to detect
possible racing conditions in web applications built upon
Seaside.
Seaside uses the concept of transactions to ensure the
correct behavior of ﬂow control. Whenever the user crosses the
boundary of a transaction, it is impossible go back to change
anything in the state of the program. Actually, a page expired
event will be raised and the user is redirected to the current
active web page. However, a close look at the transactional
mechanism and the continuation-based ﬂow control in general
yields that transactional behavior can’t be guaranteed with
implicit multi-threading programming involvement. Speciﬁ-
cally, users can start simultaneously two sessions of the same
web application. It is quite often that these two web sessions
can share some domain objects. Processing of those shared
objects can be delegated to other framework, which may lead
to possible data race conditions.
We modify the Sushi web shop example built in Seaside
[10] to illustrate how the data race conditions can be ob-
served. The Seaside framework eventually calls the handler
WAStoreTask>
go to display a set of dynamic web pages.
First, it creates cart, an instance of the shopping cart, Figure

11. This object is shared between working sessions with the
same login name. The cart contents are ﬁlled in a couple of
pages that come next. Finally, the cart is saved using PPL,
a persistent framework. PPL was developed in the Illinois
Department of Public Health and it was used in several projects
[29]. PPL interacts with the underlying database management
system using a multithreaded ODBC library. It is that kind of
interaction between concurrent accesses initiated by Seaside
and PPL, and between PPL and multihtreaded ODBC that
raises a data race occurring inside PPL framework.

WAStoreTask >> go
| shipping billing creditCard |
person := Person new.
self isolate: [
[ self login] whileFalse] .
WACartFactory instance connect.
”cart instance is shared between sessions”
cart := WACartFactory instance retrieveCart: person name.
self isolate:
[ self ﬁllCart.
self conﬁrmContentsOfCart] whileFalse] .

self isolate:
[ ”save the cart using a multithreaded persistence framework”
cart save.
self displayConﬁrmation]

Fig. 11.

Implementation of Operation go in Seaside

PPL assumes that it is in control of its internal variable
isPersisted. However, that assumption is undermined when the
asynchronous ODBC call yields its thread of execution. Figure
12 shows the implementation of operation saveAsTransaction
on PPL.

PersistentObject>> saveAsTransaction: aDBConnection
self isPersisted
ifTrue: [ self update: aDBConnection]
ifFalse: [ self create: aDBConnection] .
self makeClean

Fig. 12.

Implementation of saveAsTransaction in PPL

We obtain the trace logs for cart save during two executions
of the above code in a Seaside application. Note that the line of
code cart save is protected inside the block i
. Sea-
side uses such blocks to ensure transactional behavior among
a sequence of web page accesses. The data race detection
tool reveals possible data race conditions between these two
executions. In particular, it reports concurrent accesses with
at least one write to instance variables of the cart object as
suspicious places for data races (Figure 13).

Variable Access Violation: 10317.isPersisted
’session-ﬁrst’ Seaside.WAStoreCart:10317 (PersistentObject) isPersisted RETURN
’session-ﬁrst’ Seaside.WAStoreCart:10317 (PersistentObject) basicCreate: WRITE: 2
’servlet-second’ Seaside.WAStoreCart:10317 (PersistentObject) isPersisted RETURN

Fig. 13. Output showing a Conﬂicting Access with Seaside And PPL

In the above variable access violation report the instance
variable isPersisted of cart object WAStoreCart:10317 is con-

Proceedings of the 30th Annual International Computer Software and Applications Conference (COMPSAC'06)0-7695-2655-1/06 $20.00  © 2006(cid:128)
(cid:128)
(cid:128)
(cid:128)
(cid:128)
>
[
s
o
l
a
t
e
d
:
currently read by the method i
method b
of the same object.

and written by

V. R E LAT ED WORK

A. Tracing methodology
Our approach to tracing object-oriented programs relies on
debugging mechanism. Actually, the debugger is used as a
simulator to interpret program instructions and collect tracing
information. Reusing the debugger can be considered just as
an implementation advantage, since the main goal is to be able
to drive the simulated code and to examine program state after
each stepping activity. Several extensions and adaptations are
made to existing debugging machinery to meet the demands
of the tracing process.
Tracing programs based on debugging technology has been
used in other works [14], [18], [25]. Lange and Nakamura
built a tool called Program Explorer to trace C++ object-
oriented programs. Their approach consists of applying trace
points (similar to debug breakpoints) to program source code
that can reveal a C++ object’s t
pointer to a trace
recorder. Programs are then recompiled and trace events are
generated during execution. Lencenvicius et al used a debugger
written in Java to continually monitor the results of a user-
speciﬁed query string while a Java program is running. This
customized debugger instrumented Java class ﬁles to invoke
the debugger at points speciﬁed by the dynamic query. Hamou-
Lhadj and Lethbridge provided a survey of representative trace
exploratory tools and techniques, among which debugger-
based tools in Java such as Shimba [27] generally require
setting breakpoints at places of interest and then executing
target systems under control of a customized debugger.
The strength of our approach consists of the following:
(cid:128) The tracer interprets program instructions to generate
trace logs containing required information for analytical
purposes.
(cid:128) The tracing process is carried out with unmodiﬁed pro-
gram source code, without any prior program instrumen-
tation and trace-points setting. We need only to specify
the block of code that requires tracing and an optional
tracing conﬁguration.
In general, we don’t need to trace the whole application.
In contrast, most of the times we can limit the tracing
to the ﬂow of control of a framework. It does not
require deep/exhaustive knowledge of the traced program,
allowing exploratory understanding of unfamiliar code.
(cid:128) The tracer is specially designed and ﬁne-tuned to trace
multi-threading programs.
Our tracing methodology differs from the above-mentioned
approaches in that
interprets the code under tracing to
it
gather the tracing information selectively. Such an approach
allows to generate extra tracing information post-mortem,
e.g.
to process the trace log and insert additional
tracing
information regarding accesses to method parameters. On the
other hand, this approach can also have some disadvantages.
Since the method invocation context is examined on every

step, performance may suffer. However, the interactive usage
of the tracer to trace small to average block of code makes this
disadvantage not a very serious obstacle. On the other hand,
ﬂexible conﬁgurations allow us to obtain trace logs quickly
for the case studies in section IV.

B. Analyzing Trace Logs
Burrows et al [26] describe a tool called Eraser that is
capable of detecting data races in lock-based multi-threading
programs using an efﬁcient implementation of the LockSet
algorithm. Eraser instruments a binary program to generate the
trace log for data race detection and is generally not limited
to object-oriented programs.
Lange and Nakamura [17] suggest efﬁcient techniques of
merging and pruning objects and method calls to reduce the
trace log search space. Much effort has been spent on visual-
ization and statistical discovery to extract useful information
from program traces [14], [19]. Jinsight [22] is a Java visu-
alization program that can display a program execution view
and help comprehend the behavior of multiple threads in Java
programs. Various ﬁlters [18] can be applied to trace logs to
get simpler representations. However, low-level ﬁlters (ﬁlters
on function calls, for example) have a disadvantage that they
can not show a good interaction between remaining elements,
and the information contained in ﬁltered out elements are lost.
It is important to know what to ﬁlter, where to ﬁlter and how to
represent what remains after ﬁltering. Recently program query
languages have been proposed over traces to study dynamic
program behaviors [9], [13], [20]
To approach the problem of ﬁnding race conditions from
program dynamic information we propose the concept of
merging different trace logs (each for one thread of execution).
Each program thread can be traced separately (using a tracer
object in our design) and then merged back when the trace
log is ready. A program analyzer will visit the nodes inside
the trace logs and perform required analytical activities. Trace
log information is kept as documentation of the frameworks,
this is different from [7] and [28]. Every trace log node holds
information regarded the identity of the object receiving the
message call, a pointer to its source code, and the charac-
teristics of the message call. Details on how the data races
are detected using the combined trace log is discussed in
subsection III-B.
Instead of detecting possible race conditions in existing
programs, Boyapati et al [6] suggest a completely different
approach to prevent data races and deadlocks in the ﬁrst
place, using a static type system extension to the Java source
language. A corresponding type system extension for the Java
virtual machine language is built, which results in a language
called SafeJVML. Well typed SafeJVML programs are shown
to be free of data races and deadlocks [5].

V I . CONC LU S ION
Multi-threading programming offers a trade-off between
responsiveness and complexity. Multi-threading applications
have better responsiveness but
they are more complex to

Proceedings of the 30th Annual International Computer Software and Applications Conference (COMPSAC'06)0-7695-2655-1/06 $20.00  © 2006s
P
e
r
s
i
s
t
e
d
a
s
i
c
C
r
e
a
t
e
:
h
i
s
(cid:128)
develop and maintain. Frameworks are also affected. Frame-
works seem to hide the complexity of multi-threading by con-
trolling the creation and control of threads, but if application
domain objects are shared by two different threads then there
is the possibility of data races. Because frameworks hide the
creation and control of threads, it can be hard for application
programmers to ﬁnd the data races, even though the data races
are in the code that they wrote.
Since framework-based applications and multi-threading
programming are common, developers may need techniques
and tools that can keep them aware of such pitfalls and
avoid unwanted outcomes. Test cases may help in ﬁrst place.
However, data races can be present in a program even if the
results in a external module such a database appear to be
correct during some testing execution. Changes to external
libraries or components of a system can make data races to
surface. Having a better way to detect possible data races will
be of great help to increase software quality. We presented
a technique that uses tracing to ﬁnd conﬂicting accesses. We
extended the LockSet algorithm with green thread semantics.
Conﬂicting accesses are good approximations to data races.
We found that Execution Trees are good documentation of the
ﬂow of control of a frameworks and that they can be used
effectively in ﬁnding data races. Execution Trees can also be
used as an exploration tool when considering changes in the
framework or calls to external libraries.
The design of the tools and data structures presented in this
paper are guidelines to others who want to implement similar
utilities in other languages. They will be specially useful in
reﬂective languages that provide access to bytecodes and other
artifacts that help simulate the execution of virtual machine.
As we showed in the paper, the structure of frameworks can
be used to reduce the amount of tracing so that programmers
do not get overwhelmed with tracing data. Moreover, the fact
that the internal details of frameworks that do not interest
them can be hidden alleviates the need to process large volume
of trace logs and thus helps application developers focus on
their own code. We applied our technique and tools to case
studies with servlets and web applications based on the Seaside
framework. The tool reveals a few data race conditions and
conﬁrms our above arguments on data races on framework-
based applications.

[5] Chandrasekhar Boyapati. SafeJava: A Uni “ed Type System for Safe
Programming. PhD thesis, Massachusetts Institute of Technology, 2004.
[6] Chandrasekhar Boyapati, Robert Lee, and Martin Rinard. A type system
for preventing data races and deadlocks in java programs. In Conference
,
on Object-Oriented Programming Systems, Languages and Application
pages 211–230. ACM Press, 2002.
[7] Jong-Deok Choi, Keunwoo Lee, Alexey Loginov, Robert O’Callahan,
Vivek Sarkar, and Manu Sridharan. Efﬁcient and precise datarace
In Conference
detection for multithreaded object-oriented programs.
, pages 258 –
on Programming Language Design and Implementation
269. ACM Press, 2002.
[8] Desmond D’Souza, Aamod Sane, and Alan Birchenough. First-class
extensibility for UML packaging of proﬁles, stereotypes, patterns, 1999.
[9] St ´ephane Ducasse, Michael Freidig, and Roel Wuyts. Logic and trace-
based object-oriented application testing. In International Wor kshop on
Object-Oriented Reeingeering, 2004.
[10] St ´ephane Ducasse, Adrian Lienhard, and Lukas Renggli. Seaside - a
multiple control ﬂow web application framework. In In Proceedings of
, 2004.
European Smalltalk User Group Research Track
[11] Mohamed Fayad, Doug Schimidt, and Ralph Johnson, editors. Object-
. Willey, 1999.
oriented Foundations of Framework Design
[12] David Garlan, Robert Allen, and John Ockerbloom. Architectural
mismatch: Why reuse is so hard. In IEEE Software, 1995.
[13] Simon Goldsmith, Robert O’Callahan, and Alex Aiken. Relational
In Proceedings of the Conference on
queries over program traces.
,
Object-Oriented Programming Systems, Languages and Application
pages 385–402. ACM Press, 2005.
[14] Abdelwahab Hamou-Lhadj and Timothy Lethbridge. A survey of trace
exploration tools and techniques. In Proceedings of the 2 0
04 conference
, 2004.
of the Centre for Advanced Studies on Collaborative research
[15] Paul Hyde. Java Thread Programming : The Authoritative Solution
.
Sams, 2000.
[16] Ralph Johnson and Brian Foote. Designing reusable classes. Journal of
Object-Oriented Programming, June/July 1988.
[17] Danny Lange and Yuichi Nakamura. Interactive visualization of design
patterns can help in framework understanding. In Conference on Ob ject-
, pages 342–
Oriented Programming Systems, Languages and Application
357. ACM Press, 1995.
[18] Danny Lange and Yuichi Nakamura. Object-oriented program tracing
and visualization. IEEE Computer, 30(5):63–70, 1997.
[19] Darko Marinov and Robert O’Callahan. Object equality proﬁling.
In
Conference on Object-Oriented Programming Systems, Languages and
Application, pages 313–325. ACM Press, 2003.
[20] Michael Martin, Benjamin Livshits, and Monica Lam. Finding applica-
tion errors using PQL: A program query language. In Proceedings of
the Conference on Object-Oriented Programming Systems, Languages
and Application. ACM Press, 2005.
[21] Robert H. B. Netzer and Barton P. Miller. What are race conditions?:
Some issues and formalizations. ACM Lett. Program. Lang. Syst.
,
1(1):74–88, 1992.
[22] Wim De Pauw, Erik Jensen, Nick Mitchell, Gary Sevitsky, John Vlis-
sides, and Jeaha Yang. Visualizing the execution of java programs. In
, 2002.
Seminar on Software Visualization
[23] Wim De Pauw, David Lorenz, John Vlissides, and Mark Wegman.
In Proceedings
Execution patterns in object-oriented visualization.
, 1998.
Conference on Object-Oriented Technologies and Systems
[24] Monica Pawlan. Multithreaded Swing applications. Sun Developer Net-
work.
http://java.sun.com/developer/technicalArticles/Threads/swing/,
September 2001.
[25] Ambuj Singh Raimondas Lencevicius, Urs Hoelzle. Dynamic query-
based debugging.
In European Conference on Object-Oriented Pro-
gramming, pages 135–160. Springer Verlag, 1999.
[26] Stefan Savage, Michael Burrows, Greg Nelson, Patrick Sobalvarro,
and Thomas Anderson. Eraser: A dynamic data race detector for
multithreaded programs. ACM Transactions on Computer Systems
, 1997.
[27] Hausi M ¨uller Tarja Syst ¨a, Kai Koskimies. Shimba - an environment
for reverse engineering java software systems. Software Practice and
Experience, 31(4):371–394, 2001.
[1] Cincom smalltalk. http://smalltalk.cincom.com.
[28] Christoph von Praun and Thomas Gross. Object race detection.
In
[2] Seaside. http://www.seaside.st.
Conference on Object-Oriented Programming Systems, Languages and
[3] Lucy Berlin. When objects collide: Experiences with reusing multiple
Application, pages 70–82. ACM Press, 2001.
class hierarchies.
In Conference on Object Oriented Programming,
[29] Joe Yoder, Ralph Johnson, and Quince Wilson. Connecting business ob-
, pages 181–193, 1990.
System, Languages and Applications
jects to relational databases. In Fifth Conference on Patterns Languages
[4] Joshua Bloch and Neal Gafter. Java(TM) Puzzlers : Traps, Pitfalls, and
of Programs, 1998.
Corner Cases. Addison-Wesley, 2005.

R E F ER ENC E S

ACKNOW L EDGM EN T

The authors would like to thank St ´ephane Ducasse, mem-
bers of the Software Architecture Group (SAG) at University
of Illinois at Urbana-Champaign and the anonymous reviewers
for their valuable comments to the paper.

Proceedings of the 30th Annual International Computer Software and Applications Conference (COMPSAC'06)0-7695-2655-1/06 $20.00  © 2006 
 
Multiple Design Patterns for Voice over IP (VoIP) Security 
 
Zahid Anwar†    William Yurcik‡    Ralph E. Johnson†    Munawar Hafiz†    Roy H. Campbell† 
 
†Department of Computer Science 
‡National Center for Supercomputing Applications (NCSA) 
University of Illinois at Urbana-Champaign 
{anwar,johnson,mhafiz,rhc}@cs.uiuc.edu  byurcik@ncsa.uiuc.edu 
 
 

I. INTRODUCTION 

 

The  continuous  number  of  high-profile  Internet 
security  breeches  reported  in  the  mass  media  show  that 
despite  an  emphasis  on  security  processes  that  there  is 
still  a  gap  between  theory  and  practice.    Not  only  is 
there  a  need  to  develop  better  software  engineering 
processes  but  also  theoretical  security  improvements 
need to find their way into real systems. 
Software 
as 
defined 
design 
patterns 
are 
“descriptions of communicating objects and classes that 
are  customized  to  solve  a  general  design  problem  in  a 
particular  context”  [5].  As  software  design  patterns 
their  value 
have  proven 
in 
the  development  of 
production  software1, 
they  are  a  promising  new 
approach  to  help  in  both  the  theoretical  development 
                                                 
1 Java APIs, OpenStep libraries, and the Microsoft Foundation Classes 
all use catalogued design patterns. 

1-4244-0198-4/06/$20.00 ©2006 IEEE

485

Design  patterns  capture  software  solutions  to 
(cid:150) 
specific  problems  that  have  evolved  over  time  and  reflect 
many  iterations  of  work.    Documenting  such  patterns 
promotes  proven  design  and  software  reuse.  There  has 
been  a  growing  amount  of  work  documenting  design 
patterns  for  security,  however,  little work  specific  to VoIP 
security. 
In  2005  NIST 
released  a 
report  on 
recommendations  and  best  practices  for  securing  VoIP, 
however  it  lacks  the  structure,  terminology,  and  ease-of-
understanding needed for both technical and non-technical 
audiences that is an inherent feature of design patterns. 
   In  this  paper  we  document  three  design  patterns  for 
VoIP 
implementations  related 
to 
specific 
security 
problems:  (1)  secure  traversal  of  firewalls  and  NATs;  (2) 
detecting  and  mitigating  DDoS  attacks;  and  (3)  securing 
against  eavesdropping.   With many  VoIP  vendors  rushing 
products  to  market  with  overlapping  functionality  and 
requirements  for  interoperability,  documenting  design 
patterns  is  poised  to  become  an  important  part  of  secure 
programming processes for VoIP. 
 
  security  design  patterns,  VoIP  security, 
x  T
threat  modeling,  secure  traversal  of  firewalls  and  NATs, 
Internet telephony 
 

and  practical 
security 
implementation  of  better 
processes 
[3,12,15,16].  First,  many/most  software 
developers  have  only  a  limited  knowledge  of  security 
processes  and  patterns  are  a  proven  way  to  improve 
their  understanding.    Second,  patterns  work  against 
“reinventing-the-wheel” 
learning  best 
to  promote 
practices from the larger community to save time, effort, 
and  money  with  easily  accessible  and  validated 
examples.    Third,  code  can  be  reused  since  the  same 
security  patterns  arise  in  many  different  contexts.   
Fourth,  AntiPatterns  or  common  security  failures  are 
valuable examples of what not to do [18]. 
A  growing  number  of  security  design  patterns  have 
already been documented including patterns for services 
(firewalls,  mailers)  and  common  security  functions 
(authenticators, key management) [16].  In this paper we 
focus  on  Voice  over  IP  (VoIP)  security  where  security 
design  patterns  may  prove  exceedingly  useful.  Internet 
telephony  or  VoIP  has  grown  in  importance  and  has 
now  passed  the  tipping  point  –  in  2005 U.S.  companies 
bought more VoIP phones than ordered new POTS lines 
[20].  However,  with  the  powerful  convergence  of 
software-based  VoIP  to  enable  new  functionality  to 
store, copy, combine with other data, and distribute over 
the  Internet  also  comes  security  problems  that  need  to 
be  solved 
in  standard  ways 
in  order 
to  ensure 
interoperability.    This  is  further  complicated  by  the  fact 
that  various  vendors  competing  for  market  share 
currently drive VoIP security. 
Given  the  importance  of  VoIP  security,  we  are  only 
aware of only two other efforts for VoIP security design 
patterns,  a  chapter within  [15]  and  an unpublished M.S. 
thesis  supervised  by  Eduardo  Fernandez  of  Florida 
Atlantic University.  
The  remainder  of  this  paper  is  organized  as  follows: 
Section  II  summarizes  previous  work  by  reviewing  a 
recent NIST  report  on VoIP  security. Section  III briefly 
presents three design patterns for VoIP security. We end 
with a summary and conclusions in Section IV. 

A
b
s
t
r
a
c
t
I
n
d
e
e
r
m
s
(cid:150)
                                                             Figure 1.  VoIP Infrastructure Vulnerabilities 

 

 

II. REVIEW OF NIST VOIP REPORT 
 
NIST  released  a  report  on  VoIP  security  in  January 
2005  [10].    This  report  elaborates  on  various  aspects  of 
securing  VoIP  and  the  impact  of  such  measures  on  call 
performance.  The  report  argues  that  VoIP  performance 
and  security  are  not  seamlessly  compatible;  in  certain 
areas  they are orthogonal.   We briefly review this report 
and  group  VoIP 
three 
into 
threats 
infrastructure 
categories  as  depicted  in  Figure  1:  (1)  protocol,  (2) 
implementation, and (3) management. 
 
A. Quality of Service (QoS) Issues 
The  description  given  in  the  NIST  report  about  QoS 
issues  is  primarily  based  on  the  work  by  Goode  [6], 
Barbieri  [1],  and  Chuah  [4].  A  VoIP  call  is  susceptible 
to 
latency, 
jitter, 
and 
packet 
loss. 
ITU-T 
recommendation  G.114  [7]  has  established  150  ms  as 
the upper limit on one-way latency for domestic calls. If 
Goode's  latency budget  is considered, very  little  time  (< 
29 ms)  is  left  for  encryption/decryption  of  voice  traffic. 
QoS-unaware  network  elements  such  as 
routers, 
firewalls,  and  Network  Address  Translators  (NAT)  all 
contribute  to  jitter  (no  uniform  packet  delays).  Use  of 
IPsec  both  contributes  to  jitter  and  reduces  the  effective 
bandwidth.  VoIP  is  sensitive  to  packet  loss  with 
tolerable  loss  rates  of  1-3%;  however,  forward  error 
correction schemes can reduce loss rates. 
 
B. Signaling and Media Protocol Security 
SIP  (Session  Initiation  Protocol)  (RFC  3261)  and 
H.323  [8]  are  the  two  competing  protocols  for  VoIP 
signaling. H.323   is an ITU-T umbrella of protocols that 
supports  secure  RTP  (SRTP)  (RFC  3711)  for  securing 
media 
Internet  Keying 
traffic,  and  Multimedia 
(MIKEY)  (RFC  3830)  for  key  exchange.    SIP  supports 
TLS  and  S/MIME  for  signaling message  confidentiality 
and SRTP for media confidentiality.   
 
C. Firewalls and NATs 
RTP  is  assigned  a  dynamic  port  number  that 
presents  a  problem  for  firewall  port  management.  A 
firewall has  to be made aware of  the ports on which  the 
media  will  flow.  Thus  a  stateful  and  application-aware 
firewall  is  necessary.  However,  if  a  client  is  behind  a 

NAT, call establishment signaling messages transmit the 
IP  address  and  RTP  port  number  that  is  not  globally 
reachable.  NAT  traversal  protocols  like  STUN  (RFC 
3489),  TURN  (RFC  2026),  and  ICE  (14)  are  necessary 
to establish a globally routable address for media traffic.  
For  protocols  that  send  call  setup  messages  via  UDP, 
the  intermediate  signaling  entity  must  send  to  the  same 
address and port from which the request arrived. 
 
C. Encryption and IPsec 
IPsec  is  preferred  for  VoIP  tunneling  across  the 
Internet, however, it is not without substantial overhead. 
When IPsec is used in tunnel mode, the VoIP payload to 
packet  size  ratio  for  a  payload  of  40  bytes  and 
RTP/UDP headers drops to ~30%. The NIST solution to 
avoid queuing bottlenecks at routers due to encryption is 
to  perform  encryption/decryption  solely  at  endpoints. 
SRTP  and  MIKEY  are  specified  for  encrypting  media 
traffic and establishing session keys respectively. 
 
D. Categorizing VoIP Threats 
The  threats  faced  by  a  VoIP  are  similar  to  other 
communication 
including:  unwanted 
applications 
(unlawful 
(spam),  privacy  violations 
intercept), 
impersonation  (masquerading), 
theft-of-service,  and 
denial-of-service.    Table  1  groups  these  threats  into 
protocol, implementation, and management categories. 
  
 
                  Table 1. Categorizing VoIP Threats 
 
 
Protocol 
Signaling,  
Media  Confidentiality, 
Integrity 
Configuration, 
Confidentiality,  
Integrity 
Identity Assertion 

end-to-end  protection  as  well  as  hop-by-
hop (Proxies might be malicious) 

most VoIP devices are managed remotely 

Users  concerned  about  whether  they  are 
talking  to  the  real  entity  as  opposed  to  a 
'phished' entity 

Reputation Management 
Implementation 
Buffer Overflow, Insecure Bootstrapping. 
Management 
Access Control 

protection against unauthorized access to 
VoIP servers and gateways 

Power Failures 
 

486

D. Is the NIST Report Complete? 
In four key areas we find the NIST report incomplete.  
First,  the  NIST  report  cites  results  that  the  SHA1  hash 
algorithm  throughput  is  less  than  the  throughput  of 
DES/3DES  for  a  VoIP  packet  stream.  This  result  is 
counter-intuitive  since encryption/decryption algorithms 
are  generally  believed  to  require  more  processing  than 
hashing algorithms.  
Second,  the  Mean  Opinion  Score  (MOS)  is  a 
standardized  quantitative  measure  of  human  speech 
quality  at  the  destination  end  of  a  voice  circuit.  MOS 
uses  subjective  tests  that  are  averaged  to  calculate  an 
indicator of system performance. The NIST Report does 
not  use  MOS  which  is  a  useful  metric  for  balancing 
security versus performance tradeoffs.   
Third,  greater  payload  compression  means  that  the 
codec employs temporal relationships between the voice 
blocks. It is this temporal relationship that is sensitive to 
packet  loss.  However,  this  is  not  clear  from  the  NIST 
report  when  it  says  "greater  payload  compression  rates 
resulted into higher sensitivity to packet loss" [10].  
Fourth,  the NIST  report does not anticipate  the use of 
VoIP as a SPAM DoS  tool. While Email spam  relies on 
SMTP servers for transmission, VoIP RTP packets have 
no  such  constraint.  Qovia  [11],  a  company  that  sells 
tools  for  VoIP  monitoring  and  management,  recently 
applied  for  two patents on  technology  to both broadcast 
and block messages using VoIP. 
While  VoIP  has  threats,  in  comparison  traditional 
phone  service  has  dealt  with  many  threats  over  many 
years.  For  example,  tapping  a  landline  at  a wirebox  and 
eavesdropping  by  tuning  in  a  cordless  phone  frequency 
is  currently  easier  than  spoofing  VoIP  packets.    VoIP 
companies  such  as  Vonage  and  AT&T  have  taken  only 
preliminary  precautions  at  this    point  (firewalls).  The 
VoIP  Security  Alliance  (VOIPSA)  [19]  has  been 
organized  to  improve  security  awareness  and  form 
consensus on “Best Practices”.  
. 

 

III. VOIP SECURITY DESIGN PATTERNS 
While  the  NIST  report  missed  some  points,  it  does 
provide  a  general  summary  of  VoIP  security  problems. 
However,  the  NIST  report  does  not  describe  specific 
solutions  used  to  overcome  the  problems  identified.    In 
this  section  we  describe  software  design  patterns  that 
have  emerged  as  implemented  solutions  to  specific 
VoIP security problems.   In the first pattern we describe 
the  ad  hoc  but  effective  techniques  used  by  most  VoIP 
vendors  to  traverse  firewalls  and  NATs.2  In  the  second 
pattern  we  describe  how  to  keep  “Man-in-the-Middle” 
                                                 
2  Skype,  the  world's  most  popular  VoIP  service  provider  with  38 
million software downloads representing about 5 percent of all Internet 
users implements the techniques described in pattern one [17]. 
 

attacks  from  disrupting  VoIP  connections.    In  the  third 
pattern  we  describe  how  to  protect  VoIP  against 
eavesdropping.   
Software design patterns  typically have a presentation 
format  that  includes:  (1) UML diagrams of  the structure 
and  dynamic  interactions  of  the  objects  that  constitute 
the  patterns,  (2)  examples  of  the  patterns  in  use,  (3) 
pointers  to  related  patterns,  and  (4)  sample  code 
implementing  the  pattern.   We  adapt  this  format  due  to 
space  limitation  to  focus  on  the  four  essential  elements 
of a pattern:  (1) pattern name,  (2) problem,  (3) solution, 
and (4) consequences [5].  We begin each design pattern 
with  a  name  and  example  scenario  with  accompanying 
assumptions.    Given  the  example  context,  we  present 
problem(s) matched with corresponding solution(s), and 
consequences  –  all  of  which  distilled  from  the  VoIP 
community.  
 
A.  VoIP Security Design Pattern One 
Secure Traversal of Firewalls or NATs for VoIP: allows 
clients  using  private  IP  addresses  hidden  behind 
firewalls/NATs  to  be  able  to  make  VoIP  calls  to  other 
clients without the need to modify intermediate firewalls 
or NATs or making assumptions about device types. 
Example:  Alice  works  at  a 
large  organization 
scheduling  meetings  between 
teams  distributed  at 
offices  around  the  world  using  the  telephone.    Her 
manager  decides  that  she  should  use  a  new VoIP phone 
for  cost  savings.  Alice  is  not  concerned  about  voice 
quality in her short conversations.  
As  shown  in  Figure  2,  the  organization  uses  firewalls 
with  strict  policies.  Alice’s  new  VoIP  phone  uses  SIP 
but it is giving her problems. She is trying to call Bob at 
another office behind  a  firewall. Alice had been warned 
that firewalls are a common problem with VoIP phones. 
When  the  called  party  picks  up  the  phone  the  two 
people  often  cannot  hear  each  other.  In  Alice’s  case, 
Bob’s phone does not even ring when she calls. 
 
 
 

    
             
             Figure 2. VoIP Between Firewalled Networks 
    

 

487

Alice tries to switch to phones that use other protocols 
(e.g.  H.323)  but  the  same  problem  occurs.  She  contacts 
her  organizational  support  staff  to  request  opening 
certain  firewall ports but  is  turned down. After hours of 
debugging,  Alice  and  the  technical  support  staff  of  the 
VoIP  provider  deduce 
the  NAT  device  her 
that 
organization  uses  is  the  most  stringent  type  (i.e.  a 
symmetric  NAT  that  changes  its  IP/port  configuration 
based on both caller and callee identities).  
Problem: Setting up a VoIP call has  two major parts. 
First,  a  signaling  protocol  is  used  to  set  up  a  call  and 
play  Dial  and  Ring  tones.  Subsequently  if  the  called 
party  goes  off-hook  then  this  protocol  negotiates 
address/port  and  then  the  data  protocol  takes  over  to 
exchange voice until the call is torn down.  
Firewalls  and  Network  Address  Translators  (NATs) 
are  located  at  the  edge  of  most  all  enterprise  networks. 
Often  software-based  firewalls  and  NATs  are  bundled 
in  residential  DSL  packages  as  well,  so  this  problem 
affects  both  business  users  and  residential  users.    The 
problem  starts with  how  to  locate  a  client  that  is behind 
a firewall? How to determine if they are even online? 
Signaling  between  clients  contains  details  of  the 
private  IP  addresses  and  ports  that  the  clients  want  to 
use for the media flows. When the clients attempt to use 
these  private  addresses  to  send/receive  media,  the 
connection  fails  because  they  are  not  routable.  Some 
solutions such as TURN and STUN have been proposed 
to  help  solve 
this  problem.  However, 
they  are 
incomplete because  they are designed  to work with data 
only  (assuming  signaling  is  working)  and  do  not  work 
with every type of NAT.  
The  TURN  protocol  requires  TURN  capability  in  the 
actual  client  and  a  trust  relationship  based  on  shared 
credentials  [13].    A  VoIP  phone  or  software  package 
may include a STUN client, which will send a request to 
a  STUN  server.  The  server  then  reports  back  to  the 
STUN  client  what  the  public  IP  address  of  the  NAT 
router is and what port was opened by the NAT to allow 
incoming  traffic  back  in  to  the  network.  The  response 
allows  the STUN  client  to determine what  type of NAT 
is  in  use,  as  different  types  of  NATs  handle  incoming 
UDP  packets  differently.    This  will  work  with  a  full 
cone  NAT  (address  binding  remain  constant  for  all 
outgoing  connections),  but  requires  some  special 
treatment  with  restricted  cone  NATs  that  only  allow 
connections  initiated  by  firewalled  machines.  STUN 
will  not  work with  symmetric NATs  (which  create  new 
bindings  based  on  each  source  and  destination  pair). 
Unfortunately,  symmetric  NATs  are  found  in  many 
enterprise networks.   
Solution:   A Global Directory  Index  (GDI) maintains 
a  list  of  all  online  clients.  Certain  clients  are  selected 
that  are  accessible  from  the  public  network  to  act  as 
relays. When  a  client  comes  online  it  registers  with  the 

GDI  which  does  not  save  the  contact  information 
provided  in  the  Register  message  but  rather  saves  the 
real address. Subsequently, the GDI and client exchange 
keep-alive  packets  with  the  GDI  below  the  NAT 
binding  expiration  time  threshold.  When  a  permanent 
link  is  open  between  a  client  and  the  GDI,  a  VoIP 
signaling session can then be negotiated at any time.  
When  two  clients  wish  to  communicate,  the  caller 
tries  to contact  the called party directly. However,  if  the 
called  party  is  protected  by  a  NAT,  then  the  called 
party’s  computer  is  asked  by  the  GDI  to  connect  in  the 
reverse  direction  back  to  the  caller’s  computer.  If  either 
of 
these  connections  succeeds 
then 
the  call 
is 
established using  the direct connection  that provides  the 
lowest-latency connection possible.  
If  both  parties  to  the  call  are  behind  restrictive 
firewalls,  then  neither  party  will  be  able  to  reach  the 
other  directly.  The  GDI  then  chooses  a  third  party 
(relay)  who  is  reachable  by  both  parties.  In  this  case, 
both  the  caller’s  and  the  called  party’s  computers 
establish  a  direct  link  to  the  relay  that will  forward data 
packets between the two parties.  When calls are relayed 
by third parties, the entire contents of the call (including 
any voice conversations, text messages, or file transfers) 
are encrypted between the caller and the called party.  
Structure: The  signaling  sequence diagram  in Figure 
3  shows  the  interaction  between  different  entities  in  the 
system.  During  startup,  each  VoIP  client  registers  with 
the  GDI.  The  GDI  records  the  client’s  actual  public  IP 
address  and  port.  Subsequently  it  exchanges  keep-alive 
messages  with  the  client  to  ensure  that  the  bindings 
remain  open.  If  the  callee  happens  to  be  behind  a 
restricted-cone  NAT  (where  the  private  IP  may  only 
participate  in  a  connection  that  it  initiates)  then  it  asks 
the  callee  to  call back  the  caller.  In  the  case where RTP 
media  cannot  flow  directly  between  parties  the  GDI 
chooses  a  public  relay  that  tunnels  the  media  for  them. 
With  the  most  global  view,  the  GDI  is  in  the  best 
position  to  select  relays  for  shortest  path  routing,  low 
latency routing, and load balancing.   
 

        
         Figure 3. VoIP Signaling Sequence Diagram 

 

488

 
Implementation:   There  are  two parts  to maintaining 
a  VoIP  connection  -  signaling  and  media.  VoIP  will 
normally  open  separate  ports  for  each  part.  If  the  client 
is  behind  a  restrictive  firewall,  the  client  will  have  to 
maintain bindings for the two separately.  
VoIP  signaling  protocols  can  be  roughly  divided  into 
two  main  categories,  client-server  and  point-to-point.  
SIP  and  H.323  are  two  popular  examples  of  point-to-
point  protocols.  SIP  which  is  relatively  lightweight  and 
flexible  For  example,  the  HTTP  text-based  protocol 
uses  an  “INVITE”  message  to  request  a  session  with  a 
successful  response  being  “200  OK”.  These  simple 
messages  can  be  used  to  establish  communication 
between  a  SIP  client  and  a  GDI.  In  the  event  that  the 
caller  cannot  access  the  callee directly,  the GDI  can  ask 
the callee to send a “RE-INVITE” message to the caller. 
For 
client-server  based  VoIP  protocols, 
the 
controlling  entity  is  known  as  a  “Call  Agent”  which 
manages  all  the  signaling  between  the  media  streaming 
devices known as Gateways (e.g. MGCP and H.248). In 
such a scenario the role of the GDI can be played by the 
Call Agent resulting in minimal change to the protocol.  
The Session Description Protocol (SDP) is used by all 
VoIP  signaling  protocols 
to  exchange  parameters 
particular to the session (RFC 2327). Parameters include 
but  are  not  limited  to:  IP  address,  port  number,  frame 
rate,  compression 
type,  and  encoding.  The  NAT 
bindings  should  be  exchanged  via  the  SDP  protocol. 
The  example  in  Figure  4  shows  a  SIP  message 
encapsulating  a  SDP  descriptor  (Lines  13  to  20).  The 
highlighted  values  indicate  the  IP  address  and  port  that 
need to be changed in either the public address provided 
by the NAT binding or the address of the relay. 
 

       
          Figure 4.  Session Description Protocol (SDP)  
 
Once  the  signaling  determines  that  the  parties  are 
ready  to  talk,  a  new  channel  is  opened  for  media 
binding. Since the GDI can only be used to maintain the 
NAT  binding  for  the  signaling  this  binding  has  to  be 

 

489

maintained in some other way.3 RTP is normally used to 
transfer  the  media  payload  between  the  clients.  The 
receiving  address  and  port  number  have 
to  be 
determined by the client itself using a signaling protocol 
such  as  SIP,  H.323,  MGCP,  H.248  etc.  The  frequency 
of media  packets  is  a  typically much higher  than  that of 
the 
signaling 
and 
the  binding 
is  maintained 
automatically.  This  way  there  is  no  need  to  modify  the 
RTP  protocol  except  to  use  the  same  port  for  incoming 
and  outgoing  media.  The  only  way  the  binding  can  be 
broken  is  if  there  are  long  silent  pauses  in  between 
conversations  and  the  media  packets  are  suppressed  to 
preserve  bandwidth. 
It 
is  desired 
that 
silence 
suppression  not  be  used  as  a  feature  when  using  this 
pattern,  however,  silence  suppression  is  extremely 
popular  with  VoIP  vendors  because  conversations 
typically  consist  of  ~50%  silence.  Disabling  silence 
suppression  will  ensure  the  UDP  bindings  at  the  NAT 
are maintained. 
Known  Uses:    Skype  uses    peer-to-peer  networking 
with  super  nodes  as  relays  to  overcome  the  NAT 
traversal  problem  [2].    eNat  software  runs  on  the  client 
device  and  allows  the popular MSN Messenger  to  allow 
voice  chat  behind  firewalls  [9].  It  basically  acts  as  a 
proxy  diverting  all  signaling  and  media  through  itself 
and  through  special  ports  it  asks  the  user  to  open  in  the 
firewall.  This  will  not  work  in  an  enterprise  setting 
where a user does not have control of the firewall. 
Consequences: This pattern has these advantages: 
1)  End  users  do  not  need  to  be  aware  of NAT  and 
firewall configurations 
2)  Provides  increased  security  over  opening  ports 
or tunneling through firewalls 
3)  The  overlay  nature  of  this  pattern  distributes 
relay load over multiple clients 
4)  Works  for  groups  of  users,  however,  the 
conference size is limited by relay bandwidth 
This design pattern has the following disadvantages: 
1)  Relays increase bandwidth consumption 
2)  The GDI is a single point of failure 
3)  Added complexity 

 
B.  VoIP Security Design Pattern Two 
Detecting  and  Mitigating  DDoS  Attacks  Targeting 
VoIP:  allows  key  components  in  a  VoIP  infrastructure 
to  detect  and  mitigate  Distributed-Denial-of-Service 
(DDoS) attacks meant  to overwhelm either client and/or 
server resources and disrupt VoIP operations. 
Example:  Alice  tries  to  call  Bob  on  her  VoIP 
telephone  with  an  important  message  as  depicted  in 
Figure  5.  An  attacker  anticipates  Alice’s  call  attempt 
                                                 
3 media never goes through the GDI but rather directly between the 
parties and the relay 

and  sends  a  specially  crafted  messages  to  Alice’s  ISP 
server  causing  it  to  over  allocate  resources  such  that 
Alice  receives  a  “service  not  available”  (busy  tone) 
message. 
 
 

 

     
     Figure 5. VoIP Environment to Consider DoS Attacks 
 
Alice  switches  to  her  backup  line  that  uses  the  SIP  
protocol  that  does  not  signal  through  a  central  server. 
Her  phone makes  a  direct  connection  to Bob  but  before 
Alice  can  convey  her  message  an  attacker  sends  a 
special ‘BYE’ message to Bob’s VoIP phone pretending 
to be Alice which prematurely ends the connection. 
Alice  is  persistent  and  dials  Bob  again.  This  time  the 
attacker  intermittently  sends  garbage  voice  packets  to 
Bob’s  phone  in  between  those  of Alice’s  voice  packets. 
Bob’s  phone  is  so  busy  trying  to  process  the  increased 
packet  flow  that  the  jitter  (delay  variation)  causes  any 
conversation to be incomprehensible.   
In  this  pattern  we  assume  that  the  vendor  has 
implemented  the  minimal  set  of  recommended  VoIP 
recommends 
[10].  Megaco 
security 
requirements 
security  mechanisms 
in 
the  underlying 
transport 
mechanisms  such  as  IPSec.  Implementations  of  the 
protocol  using  IPv4  are  required  to  implement  the 
interim AH scheme.  
MGCP  (RFC  3435)  and  Megaco/H.248  (RFC  3261) 
are  control  protocols  designed  to  centrally  manage 
Media  Gateways  (MG)  deployed  across  a  VoIP 
infrastructure.  A  MG  executes  commands  sent  by  the 
centralized  Media  Gateway  Controller  (MGC)  and  is 
designed  to  convert  data  between PSTN  to  IP, PSTN  to 
ATM,  ATM  to  IP,  and  also  IP  to  IP.  MGCP  and 
Megaco/H.248  can  be  used  to  set  up,  maintain,  and 
terminate  calls  between  multiple  endpoints,  while 
monitoring  all  of  the  events  and  connections  associated 
with  those endpoints  from  the MGC. The MGC  is a key 
component  in  the  entire  infrastructure  as  it  can  control 
multiple MGs  each with  its  own many  endpoints  (VoIP 
users).   In addition it talks to other MGCs using SIP if a 

490

call  warrants  a  connection  between  an  endpoint  on  an 
MG  controlled  by  one  MGC  and  endpoint  on  an  MG 
controlled by a different MGC.  
Occasionally  some  endpoints  have  a  feature  which 
enables  them  to make a call directly  to another endpoint 
without  having  to  go  through  an  MG  or  MGC  using 
SIP. Usually  this  requires an address  lookup  from a SIP 
Proxy  server  and  the  rest  of  the  signaling  and  media  is 
handled by the endpoints themselves.   
Problem  1:    An  attacker  can  disrupt  Alice’s  Media 
Gateway.    MGs  are  dumb  clients  in  the  MGC-MG 
relationship,  not  holding  call  state  and  carrying  out 
instructions  received  from  the  MGC  without  validity 
checks.  Although  an  attacker  cannot  pretend  to  be  the 
MGC  owing 
the 
in 
the  AH  check  required 
to 
authentication  header  of  the Megaco  protocol,  they  can 
mount  a  replay  attack  on  the MG  when  they  detect  that 
Alice is about to make a call.  
An  attacker  has  a  number  of  options  available  after 
Alice  is  detected  making  a  call.  They  can  replay  with 
any  one  of  the  Megaco  commands  listed  in  Table  2 
spoofed  off  the  MGC  outbound  links  earlier  in  the 
communication.   By  replaying  any  of  these messages  to 
Alice  during  her  call,  an  attacker  will  force  the  MG  to 
teardown Alice’s conversation with Bob.  
 
   Table 2. Megaco Commands Which Can Disrupt 
       
causes  MG  to  hard  reboot.  Used  in 
registration initial set up. 
signifies called party has hung up 
deletes  ephemeral  termination  created 
for media exchange 
changes  media  protocol  to  send  but 
not receive voice packets 
 
Once  an  attacker  knows  which  packet  corresponds  to 
which  message,  another  attack  is  selective  dropping  of 
Alice’s  important  packets.  For  example,  an  attacker  can 
prevent  Alice’s  call  from  even  getting  set-up  by 
detecting  her Notify  event  ‘Dial Digits’  and  dropping  it. 
Table  3  lists  three  ways  in  which  an  attacker  can 
identify 
the 
specific  messages 
from  MGC-MG 
communication.  
 
   Table 3.  Methods for Identifying Specific Messages  
           
Timing 
ServiceChange  Restart  is  the  first 
message  sent  by  MGC  to  MG  after 
MG registration 
associate  messages  with  observed 
physical  events  (OnHook  command  is 
observed after Alice hangs up phone) 
by 
identified 
commands 
traffic 
(Subtract 
Ephemeral 
pattern; 
Termination  command    sent  when 
RTP  media  traffic  of  constant–sized 
packets stops) 
Solution  1:  Commands  between  the  MGC  and  the 
MG  are  grouped  into  Transactions,  each  of  which  is 
identified  by  a  TransactionID.    Transactions  consist  of 
one  or  more 
actions 
and 
are  presented 
as 

Network Traffic Analysis 

Visualization 

t O
k 

y M

a S

y 

e R

t 

 

y E

t T

n 

S
e
r
v
i
c
e
C
h
a
n
g
e
s
t
a
r
N
o
t
i
f
v
e
n
n
H
o
o
S
u
b
t
r
a
c
e
r
m
i
n
a
t
i
o
M
o
d
i
f
e
d
i
e
n
d
O
n
l
TransactionRequests.    Corresponding  responses  to  a 
TransactionRequest  are  received  in  a  single  reply. 
is  not  guaranteed 
Ordering  of  Transactions 
- 
in  any  order  or 
transactions  may  be  executed 
simultaneously.  Transactions  are 
identified  by  a 
TransactionID,  which  is  assigned  by  sender  and  is 
unique within  the  scope  of  the  sender.    The MG  should 
explicitly check TransactionIDs have not been  repeated. 
If  a  repeated  command  is  found  with  a  TransactionID 
then  it  should  be  silently  discarded.  TransactionID 
sequences  should  start  from  a  unique  random  value  for 
each  session  so  that  it  is  hard  for  an  attacker  to  reuse 
messages from old sessions.  
The  MG 
should  use 
the  Megaco  message-
piggybacking  feature  to make  it  difficult  for  an  attacker 
to  correlate  Alice’s  particular  messages  based  on 
visualization  and  network  traffic  analysis.  Multiple 
commands can be sent simultaneously by  the MG  to  the 
MGC  randomly  shuffling  their  order  in  the  message 
body. MGs  can  also be made  less predictable by adding 
random  delays  between  the  occurrence  of  a  physical 
event (hanging up) and its notification to the MGC.  
Problem  2:  An  attacker  may  degrade  VoIP  QoS.  An 
attacker  may  exploit  the  property  of  VoIP  media 
communication  that  it  is  highly  sensitive  to  delay  and 
jitter.  Delays  greater  than  150  ms  cause  a  conversation 
to  become  uncomfortable.  This  level  of  delay  is  usually 
the  point  at  which  both  parties  begin  to  speak  at  the 
same  time.  Jitter manifests  to  the  listener as pops/clicks, 
words  missing,  and/or  garbled  speech.    If  jitter  values 
exceed 50ms it is usually considered poor voice quality, 
To  reduce  the  impact  of  jitter,  VoIP  phones  usually 
have  a  jitter  buffer. The  jitter  buffer  is  usually  designed 
to  hold  1-2  datagrams  and  may  adjust  dynamically 
based  on  the  perceived  jitter.  As  datagrams  arrive,  they 
are  placed  in  the  jitter  buffer,  which  holds  them  long 
enough  to supply  them  to  the codec at a constant rate. If 
a datagram  arrives  too early or  too  late,  it may not  fit  in 
the  jitter buffer and  is discarded.  Ideally  the  jitter buffer 
should  be  just  large  enough  to  handle  the  maximum 
delay variation, however, for every millisecond  that you 
increase  the  jitter  buffer  you  also  add  a  millisecond  of 
delay.  
The  attacker  has  two  options:  (1)  faking  some  of 
Alice’s  packets  by  changing  the  SSRC  field,  which 
designates  the  source  of  RTP  packets  (to  impersonate 
Alice)  and  inject  artificial  packets with  higher  sequence 
numbers  that  will  cause  the  injected  packets  to  be 
played  in  place  of  the  real  packets;  or    (2)  sending 
garbage  packets  meaning  both  the  header  and  the 
payload  are  filled  with  random  bytes  corrupting  Bob’s 
jitter  buffer  (most  likely  this  will  cause  Bob’s  VoIP 
phone  to  crash  or  cause  exorbitant  delay  processing  
which disrupts established VoIP conversations). 

Solution  2:  A  VoIP  implementation  should  have  an 
intrusion  detection  system  (IDS)  or  firewall  on  the 
phone  itself  that  checks  the  media  packet  flow.  Either 
the  IDS  or  firewall  can  then  be  used  to  ensure:  (a) 
packets  with  very 
large  sequence  numbers  are 
discarded,  (b)  garbage  packets  are  identified  and 
discarded  before  the  codecs  try  to  mathematically 
decode  them,  and  (c)  large  traffic  volume  for  a  single 
RTP flow signal a warning. 
Problem  3:  An  attacker  can  mount  a  DoS  attack  on 
the  VoIP  signaling.  An  attacker  can  prematurely  tear 
down Alice’s and Bob’s direct SIP signaling connection 
by  sending  a  fake  SIP  BYE  or  ICMP  Port Unreachable 
message  to  either  of  the  parties.  This  results  in  the 
attacked  party 
transmission 
the  media 
stopping 
immediately  while  the  other  party  continuing  the 
conversation  oblivious  that  the  connection  has  been 
degraded or terminated. 
Solution  3:  In  order  to  detect  this  attack,  the  VoIP 
infrastructure  should  create  a  rule  that  it  detects  orphan 
RTP  flows.  Specifically,  if  it  is  indeed  B  who  wants  to 
stop the connection, then A should not see the RTP flow  
from B after getting the BYE message. 
Consequences:  This  design  patterns  has 
the 
advantage  of  users  having  increased  security  for  their 
VoIP calls but the disadvantage of increased delay. 
 
C.  VoIP Security Design Pattern Three 
Securing VoIP against Eavesdropping 
Example: RTP is not a complete protocol but a rather 
a 
framework  where 
vendors 
are 
provided 
implementation  freedom  according  to  their  specific 
application  profiles.  RTP  facilitates  network  transport 
functions  for  real-time  data,  provides  application  level 
framing,  and  usually  runs  over  an  unreliable  transport 
protocol such as UDP that does not guarantee the timely 
delivery  of  packets 
in  order.  RTP 
is  usually 
implemented  in  conjunction  with  higher  layer  control 
that  provides  feedback  information  on  transmission 
quality.  
Problem:  Security  facilities  provided  by  RTP  alone 
are 
inadequate.  RTP  provides  a 
framework 
for 
implementing  high-level  protocols  which  in  turn  can 
implement 
their  own  security  services 
that  may 
eventually  provide  benefit  to  RTP  itself  (RFC  1889). 
RTP cannot rely on the underlying network just because 
it  is  transmitted  over  IP  and  considering  IPSec  will 
consequently  provide  the  security  services.  Services 
provided  by  IPSec  are  not  useful  for  protocols  other 
than  IP  and  also  do not  support multicast  sessions. RTP 
is  network  independent  and  could  use  other  protocols 
like  ATM/AAL5  for  transmission  of  real-time  data  for 
which  IPSec  is  not  relevant.  We  discuss  a  technique  to 
provide  actual  RTP  packet  encryption  which  provides 

491

reasonable  privacy  from  eavesdroppers  and  does  not 
change  the  RTP  properties  of  out-of-order  packets, 
delay, and jitter requirements. 
Solution:  The  DES  cryptographic  algorithm  is  used 
in  the  DES-CBC  mode.  The  DES-CBC  mode  has  a 
random  access  property  that  guarantees  lost  packets 
only  prevent  decoding  of  themselves  and  the  following 
packets  of  their  specific  blocks  without  affecting  the 
remaining  transmission.  The  overhead  of  DES  is  much 
lower than that of compression algorithms used by RTP. 
The  slight  disadvantage  of  this  approach  is  that  DES  is 
typically  implemented  in  hardware  and  difficult  to 
implement  in  software.  This makes  the  solution  slightly 
harder  to  implement  since  most  VoIP  products  are 
software  based.  Other  than  DES,  the  current  AES 
standard  encryption  algorithm  may  also  be  used  with 
Counter Mode and f-8 mode (normally used for wireless 
transmission).  AES  overcomes  the  flaws  of  individual 
bit  manipulation  introduced  by  the  CBC  mode  since 
AES  encryption/decryption  of  one  packet  does  not 
depend  upon  preceding  packets.  It  also  provides 
increased security with a larger block size (128 bits) and 
larger encryption keys.  
 

IV. SUMMARY  

 

As  VoIP  market  penetration  increases  there  are 
growing  security  concerns.  The  2005  NIST  report  is 
currently  the  most  comprehensive  source  on  VoIP 
security  and  in  this  role  is  a  good  summary  for 
managers  considering 
the  potential  use  of  VoIP, 
however,  it  does  not  provide  practical  details  about 
specific solutions that can be emulated.   
This  is  where  design  patterns  come  in  –  design 
patterns  are  accepted  solutions  to  well  known  problems 
cataloged  by  and  for  the  actual  developers  who  have 
been  working  with  the  internals  of  the  technology. 
Design  patterns  reveal 
insights  on  how  software 
solutions  are  actually  implemented  in  real  systems.  We 
review  the general guidance within  the NIST report as a 
vehicle  to  contrast  it  with  the  specific  guidance  of 
security software design patterns. 
With  this  paper  we  contribute  to  the  cataloging  of 
                                                                                                         

VoIP  security  design  patterns  by  presenting  three 
patterns.  We 
this  work  and 
invite  feedback  on 
contributions  of  other  VoIP  security  design  patterns 
using the forum in [16].   

[7] 

[8] 

[9] 

REFERENCES 
[1]  R.  Barbieri,  D.  Bruschi,  and  E  Rosti,  “Voice  over  IPsec: 
Analysis  and  Solutions”.    18th  Annual  Computer  Security 
Applications Conference (ACSAC), 2002. 
[2]  S. A. Baset and H. Schulzrinne, “An Analysis of the Skype Peer-
to-Peer Internet Telephony Protocol,” IEEE Infocom, 2006. 
[3]  B. Blakley, C. Heath, and members of The Open Group Security 
Forum,  “Technical  Guide:  Security  Design  Patterns,”  The  Open 
Group, April 2004.  
[4]  C-N.  Chuah,  “Providing  End-to-End  QoS  for  IP  based  Latency 
sensitive  Applications.”  Technical  Report,  Dept.  of  ECE, 
University of California at Berkeley, 2000. 
[5]  E.  Gamma,  R.  Helm,  R.  Johnson,  and  J.  Vlissides,  Design 
Patterns:  Elements  of  Reusable  Object-Oriented  Software, 
Addison-Wesley, 1995. 
[6]  B.  Goode,  “Voice  Over  Internet  Protocol  (VoIP)”.  Proceedings 
of the IEEE, Vol. 90 No. 9, Sept. 2002. 
ITU-T,  “Recommendation  G.114  -  One-Way  Transmission 
Time,” Feb 2003. 
ITU-T,  “H.323  -  Packet-Based  Multimedia  Communications 
Systems”, Feb. 1998.  
JDSoft, “eNAT for MSN Messenger,” 
<http://www.easyfp.com/> 
[10]  D. R. Kuhn, T.J. Walsh, and S. Fries, Security Considerations for 
Voice  Over  IP  Systems, U.S. National  Institute  of  Standards  and 
Technology (NIST) Special Publication 800-58, January 2005. 
[11]  Qovia, Inc. <http://www.qovia.com/> 
[12]  L. Rising (editor), Design Patterns in Communications Software, 
Cambridge University Press, 2001. 
[13]  J.  Rosenberg.,  "Traversal  Using  Relay  NAT  (TURN)",  Internet-
Draft draft-rosenberg-midcom-turn-07, Feb. 2005. 
[14]  J.  Rosenberg,  "Interactive  Connectivity  Establishment  (ICE), 
Internet-Draft draft-ietf-mmusic-ice-04, Feb 2005. 
[15]  M.  Schumacher,  E.  Fernandez-Buglioni,  D.  Hybertson,  F. 
Buschmann,  and  P.  Sommerlad,  Security  Patterns:  Integrating 
Security and Systems Engineering, Wiley, 2006. 
[16]  Security Patterns Homepage <http://www.securitypatterns.org/>  
[17]  Skype, “Skype-The Whole World can Talk for Free,” 
<http://www.skype.com> 
[18]  B.  Smaalders,  “Performance  Anti-Patterns,”  ACM  Queue, 
February 2006. 
[19]  Voice over IP Security Alliance. <http://www.voipsa.org/> 
[20]  K.  Werbach,  “Using  VoIP  to  Compete,”  Harvard  Business 
Review, September 2005. 

492

Transaction Support Using Unit of Work Modeling in the Context of MDA 

 61801  

Abstract  

Transactions  are  an  i mportant  part  of 
most  
  Sometimes  they  are  
enterprise  computing  systems. 
by   DBMS  and   sometimes  
supported 
by   transaction  
monitors. 
  In  either  case,
  they  are  part  of  the  platform
used 
by   application  developers. 
  platfor m
independent 
must  
model  of  enterprise  computing 
abstract  away  transactions  and  provide  platform
independent ways of describing them. 

This paper   shows  how  
be used  
  can 
çunit  of work
to  support   platform
independent  descriptions  of  
enterprise  computing  syste ms  that  use  transactions. 
's Model Driven  
  is   in   the   context  of  the OM G
Our  work
Architecture  so  we  provide  a 
UML
  profile  for  
We  have  developed  a  tool,
describing  unit  of  work. 
  that  can  translate  platform
Mercator ,
  independent  
models  using   the  unit  of  work
  profile  to  platform
dependent 
models using transactions. 

When  added  to  our  previous   work
  on  persistence,
this  provides  a  general  way   of  handling  transparent  
transaction 
management in MDA. 

[1 ]

1.  Introduction 

[2 ]

[3 ]

Proceedings of the 2005  Ninth IEEE International ED
 IEEE 
0-7695-2441-9/05 $20.00 © 2005

OC Enterprise Computing Conference (ED OC í05) 

W
e
e
r
a
s
a
k
 
W
i
t
t
h
a
w
a
s
k
u
l
,
 
R
a
l
p
h
 
J
o
h
n
s
o
n
 
S
o
f
t
w
a
r
e
 
A
r
c
h
i
t
e
c
t
u
r
e
 
G
r
o
u
p
 
D
e
p
a
r
t
m
e
n
t
 
o
f
 
C
o
m
p
u
t
e
r
 
S
c
i
e
n
c
e
 
U
n
i
v
e
r
s
i
t
y
 
o
f
 
I
l
l
i
n
o
i
s
 
a
t
 
U
r
b
a
n
a
-
C
h
a
m
p
a
i
g
n
,
 
I
L
w
i
t
t
h
a
w
a
@
u
i
u
c
.
e
d
u
,
 
j
o
h
n
s
o
n
@
c
s
.
u
i
u
c
.
e
d
u
 
 
 
A
 
 
é
 
 
 
 
 
 
E
n
t
e
r
p
r
i
s
e
 
a
p
p
l
i
c
a
t
i
o
n
s
 
a
r
e
 
u
s
u
a
l
l
y
 
t
r
a
n
s
a
c
t
i
o
n
a
l
,
 
d
i
s
t
r
i
b
u
t
e
d
 
a
n
d
 
p
l
a
t
f
o
r
m
 
d
e
p
e
n
d
e
n
t
.
 
 
T
h
e
y
 
r
u
n
 
o
n
 
d
i
f
f
e
r
e
n
t
 
o
p
e
r
a
t
i
n
g
 
s
y
s
t
e
m
s
,
 
a
r
e
 
w
r
i
t
t
e
n
 
i
n
 
d
i
f
f
e
r
e
n
t
 
l
a
n
g
u
a
g
e
s
 
a
n
d
 
u
s
e
 
o
b
j
e
c
t
 
s
e
r
v
i
c
e
s
 
p
r
o
v
i
d
e
d
 
b
y
 
d
i
f
f
e
r
e
n
t
 
m
i
d
d
l
e
w
a
r
e
.
 
C
o
m
m
o
n
 
s
e
r
v
i
c
e
s
 
i
n
c
l
u
d
e
 
o
b
j
e
c
t
 
p
e
r
s
i
s
t
e
n
c
e
,
 
d
i
s
t
r
i
b
u
t
i
o
n
,
 
t
r
a
n
s
a
c
t
i
o
n
 
a
n
d
 
s
e
c
u
r
i
t
y
.
 
 
H
o
w
e
v
e
r
,
 
d
i
f
f
e
r
e
n
t
 
m
i
d
d
l
e
w
a
r
e
 
p
r
o
v
i
d
e
 
d
i
f
f
e
r
e
n
t
 
o
b
j
e
c
t
 
s
e
r
v
i
c
e
 
i
n
t
e
r
f
a
c
e
s
 
a
n
d
 
r
e
q
u
i
r
e
 
a
p
p
l
i
c
a
t
i
o
n
s
 
t
o
 
u
s
e
 
t
h
e
m
 
i
n
 
a
 
s
p
e
c
i
f
i
c
 
w
a
y
.
 
 
T
h
i
s
 
f
o
r
c
e
s
 
s
o
f
t
w
a
r
e
 
d
e
v
e
l
o
p
e
r
s
 
t
o
 
t
a
k
e
 
i
n
t
o
 
c
o
n
s
i
d
e
r
a
t
i
o
n
 
t
h
e
 
p
l
a
t
f
o
r
m
 
s
p
e
c
i
f
i
c
 
i
n
t
e
r
f
a
c
e
s
 
i
n
 
t
h
e
i
r
 
d
e
s
i
g
n
 
a
n
d
 
m
a
k
e
s
 
i
t
 
d
i
f
f
i
c
u
l
t
 
t
o
 
r
e
u
s
e
 
t
h
e
 
d
e
s
i
g
n
 
t
o
 
c
r
e
a
t
e
 
a
p
p
l
i
c
a
t
i
o
n
s
 
t
h
a
t
 
r
u
n
 
o
n
 
d
i
f
f
e
r
e
n
t
 
p
l
a
t
f
o
r
m
s
.
 
O
u
r
 
r
e
s
e
a
r
c
h
 
p
u
r
p
o
s
e
 
i
s
 
t
o
 
l
e
a
r
n
 
h
o
w
 
t
o
 
a
b
s
t
r
a
c
t
 
t
h
e
s
e
 
o
b
j
e
c
t
 
s
e
r
v
i
c
e
s
 
s
o
 
t
h
a
t
 
a
p
p
l
i
c
a
t
i
o
n
s
 
c
a
n
 
u
s
e
 
t
h
e
m
 
i
n
d
e
p
e
n
d
e
n
t
l
y
 
o
f
 
t
h
e
i
r
 
c
h
o
i
c
e
 
o
f
 
m
i
d
d
l
e
w
a
r
e
.
 
 
W
e
 
d
e
f
i
n
e
 
h
i
g
h
 
l
e
v
e
l
 
m
o
d
e
l
i
n
g
 
c
o
n
c
e
p
t
s
 
o
f
 
p
l
a
t
f
o
r
m
 
i
n
d
e
p
e
n
d
e
n
t
 
o
b
j
e
c
t
 
s
e
r
v
i
c
e
s
 
a
s
 
U
M
L
 
p
r
o
f
i
l
e
s
.
 
 
T
h
e
 
p
r
o
f
i
l
e
s
 
c
o
n
t
a
i
n
 
m
o
d
e
l
i
n
g
 
n
o
t
a
t
i
o
n
s
 
a
s
 
w
e
l
l
 
a
s
 
a
p
p
l
i
c
a
t
i
o
n
 
p
r
o
g
r
a
m
m
i
n
g
 
i
n
t
e
r
f
a
c
e
s
 
t
h
a
t
 
m
o
d
e
l
 
d
e
s
i
g
n
e
r
s
 
u
s
e
 
t
o
 
a
d
d
 
c
o
m
m
o
n
 
o
b
j
e
c
t
 
f
u
n
c
t
i
o
n
a
l
i
t
y
 
i
n
 
t
h
e
i
r
 
p
l
a
t
f
o
r
m
 
i
n
d
e
p
e
n
d
e
n
t
 
m
o
d
e
l
s
.
 
 
M
o
d
e
l
s
 
t
h
a
t
 
u
s
e
 
o
b
j
e
c
t
 
s
e
r
v
i
c
e
 
p
r
o
f
i
l
e
s
 
a
r
e
 
t
r
a
n
s
f
o
r
m
e
d
 
i
n
t
o
 
e
x
e
c
u
t
a
b
l
e
 
p
l
a
t
f
o
r
m
 
s
p
e
c
i
f
i
c
 
m
o
d
e
l
s
 
b
y
 
a
 
m
o
d
e
l
 
m
a
p
p
i
n
g
 
t
o
o
l
.
 
 
M
o
d
e
l
 
d
e
s
i
g
n
e
r
s
 
m
a
k
e
 
m
a
p
p
i
n
g
 
c
h
o
i
c
e
s
 
a
n
d
 
r
u
n
 
t
h
e
 
t
o
o
l
 
t
o
 
g
e
n
e
r
a
t
e
 
i
m
p
l
e
m
e
n
t
a
t
i
o
n
s
 
t
h
a
t
 
u
s
e
 
s
e
r
v
i
c
e
s
 
p
r
o
v
i
d
e
d
 
b
y
 
s
p
e
c
i
f
i
c
 
m
i
d
d
l
e
w
a
r
e
.
 
 
O
u
r
 
p
r
e
v
i
o
u
s
 
w
o
r
k
 
[
 
d
e
f
i
n
e
d
 
a
n
 
o
b
j
e
c
t
 
p
e
r
s
i
s
t
e
n
c
e
 
p
r
o
f
i
l
e
 
a
n
d
 
s
h
o
w
e
d
 
t
h
a
t
 
a
p
p
l
i
c
a
t
i
o
n
s
 
c
a
n
 
u
s
e
 
o
b
j
e
c
t
 
p
e
r
s
i
s
t
e
n
c
e
 
i
n
 
a
 
p
l
a
t
f
o
r
m
 
i
n
d
e
p
e
n
d
e
n
t
 
w
a
y
 
a
n
d
 
b
e
 
t
r
a
n
s
f
o
r
m
e
d
 
i
n
t
o
 
o
n
e
s
 
t
h
a
t
 
u
s
e
d
 
a
 
v
a
r
i
e
t
y
 
o
f
 
p
e
r
s
i
s
t
e
n
c
e
 
m
e
c
h
a
n
i
s
m
s
 
s
u
c
h
 
a
s
 
X
M
L
,
 
R
D
B
M
S
 
o
r
 
E
J
B
.
 
 
T
h
i
s
 
p
a
p
e
r
 
c
o
n
t
i
n
u
e
s
 
t
h
e
 
w
o
r
k
 
i
n
 
o
b
j
e
c
t
 
t
r
a
n
s
a
c
t
i
o
n
 
s
e
r
v
i
c
e
 
a
n
d
 
p
r
o
p
o
s
e
s
 
a
 
u
n
i
t
 
o
f
 
w
o
r
k
 
p
r
o
f
i
l
e
 
t
o
 
s
u
p
p
o
r
t
 
t
r
a
n
s
a
c
t
i
o
n
s
 
i
n
 
a
 
p
l
a
t
f
o
r
m
 
i
n
d
e
p
e
n
d
e
n
t
 
w
a
y
.
 
O
u
r
 
a
p
p
r
o
a
c
h
 
f
o
l
l
o
w
s
 
t
h
e
 
M
o
d
e
l
 
D
r
i
v
e
n
 
A
r
c
h
i
t
e
c
t
u
r
e
 
i
n
i
t
i
a
t
i
v
e
 
 
t
o
 
r
a
i
s
e
 
t
h
e
 
a
b
s
t
r
a
c
t
i
o
n
 
l
e
v
e
l
 
o
f
 
s
o
f
t
w
a
r
e
.
 
 
T
h
e
 
M
D
A
 
s
e
p
a
r
a
t
e
s
 
b
u
s
i
n
e
s
s
 
o
r
 
a
p
p
l
i
c
a
t
i
o
n
 
l
o
g
i
c
 
f
r
o
m
 
u
n
d
e
r
l
y
i
n
g
 
p
l
a
t
f
o
r
m
 
t
e
c
h
n
o
l
o
g
y
 
b
y
 
d
e
f
i
n
i
n
g
 
a
p
p
l
i
c
a
t
i
o
n
 
m
o
d
e
l
s
 
a
t
 
t
w
o
 
l
e
v
e
l
s
;
 
a
 
P
l
a
t
f
o
r
m
 
I
n
d
e
p
e
n
d
e
n
t
 
M
o
d
e
l
 
(
P
I
M
)
 
a
n
d
 
a
 
P
l
a
t
f
o
r
m
 
S
p
e
c
i
f
i
c
 
M
o
d
e
l
 
(
P
S
M
)
.
 
 
T
h
e
 
P
I
M
 
i
s
 
a
 
h
i
g
h
 
l
e
v
e
l
 
m
o
d
e
l
 
t
h
a
t
 
d
o
e
s
 
n
o
t
 
d
e
p
e
n
d
 
o
n
 
m
i
d
d
l
e
w
a
r
e
,
 
p
l
a
t
f
o
r
m
s
,
 
o
p
e
r
a
t
i
n
g
 
s
y
s
t
e
m
s
,
 
p
r
o
g
r
a
m
m
i
n
g
 
l
a
n
g
u
a
g
e
s
 
a
n
d
 
t
e
c
h
n
o
l
o
g
y
 
w
h
e
r
e
a
s
 
t
h
e
 
P
S
M
 
i
s
 
a
 
c
o
m
p
l
e
t
e
,
 
e
x
e
c
u
t
a
b
l
e
 
m
o
d
e
l
 
f
o
r
 
a
 
p
a
r
t
i
c
u
l
a
r
 
t
a
r
g
e
t
 
p
l
a
t
f
o
r
m
.
 
 
U
M
L
 
 
i
s
 
t
h
e
 
m
o
s
t
 
c
o
m
m
o
n
 
m
o
d
e
l
i
n
g
 
l
a
n
g
u
a
g
e
 
f
o
r
 
r
e
p
r
e
s
e
n
t
i
n
g
 
t
h
e
 
P
I
M
 
a
n
d
 
t
h
e
 
P
S
M
,
 
b
u
t
 
O
M
G
 
p
e
r
m
i
t
s
 
a
n
y
 
l
a
n
g
u
a
g
e
 
d
e
f
i
n
e
d
 
 1 

* 
  *  @transaction 
  *
/ 
public void insertOrder(Order order )  {  
   
(cid:141)ordernumŽ
order.setOrderId (getNextId(
;      
   orderDao.insertOrder(order )
; 
   itemDao.updateQuantity (order )
; 

 1.

insertOrder 

  1)

[4 ]

[5 ]

[6 ]

markings
markings

mapping
mapping

PIM
PIM

Marked
Marked
PIM
PIM

PSM
PSM
PSM
PSM

Marks
Marks

 1.

Annotations
Annotations
Annotations
Annotations

[7 ]

insertOrderm

  2 

  3 

[10 ]

pri vate  void insertOrder (Order order) 
throws DaoException  { 
  try  { 
   storeDaoManager.startTransaction (
; 
   
(cid:141)ordernumŽ
order.setOrderId (getNextId(
;      
   orderDao.insertOrder(order )
; 

2.  Motivating  example  

[8 ]
insertOrder 

Proceedings of the 2005  Ninth IEEE International ED
 IEEE 
0-7695-2441-9/05 $20.00 © 2005

OC Enterprise Computing Conference (ED OC í05) 

b
y
 
t
h
e
 
M
O
F
 
t
o
 
b
e
 
u
s
e
d
,
 
a
n
d
 
c
o
n
c
e
p
t
u
a
l
l
y
 
t
h
e
y
 
c
a
n
 
b
e
 
r
e
p
r
e
s
e
n
t
e
d
 
b
y
 
a
n
y
 
m
o
d
e
l
i
n
g
,
 
p
r
o
g
r
a
m
m
i
n
g
 
o
r
 
d
o
m
a
i
n
 
s
p
e
c
i
f
i
c
 
l
a
n
g
u
a
g
e
s
.
 
 
D
e
s
i
g
n
i
n
g
 
s
o
f
t
w
a
r
e
 
a
t
 
a
 
p
l
a
t
f
o
r
m
 
i
n
d
e
p
e
n
d
e
n
t
 
l
e
v
e
l
 
f
o
c
u
s
e
s
 
o
n
 
t
h
e
 
p
r
o
b
l
e
m
 
d
o
m
a
i
n
 
a
n
d
 
l
e
a
v
e
s
 
o
u
t
 
s
p
e
c
i
f
i
c
 
i
m
p
l
e
m
e
n
t
a
t
i
o
n
 
d
e
t
a
i
l
s
 
u
n
t
i
l
 
a
 
l
a
t
e
r
 
s
t
a
g
e
.
 
 
S
o
f
t
w
a
r
e
 
d
e
v
e
l
o
p
e
r
s
 
d
e
s
i
g
n
 
a
n
 
o
b
j
e
c
t
 
m
o
d
e
l
 
i
n
 
a
 
P
I
M
;
 
a
p
p
l
y
 
(
(cid:141)
m
a
r
k
Ž
)
 
c
o
m
m
o
n
 
l
i
b
r
a
r
y
 
c
o
n
c
e
p
t
s
 
s
u
c
h
 
a
s
 
p
e
r
s
i
s
t
e
n
c
e
,
 
t
r
a
n
s
a
c
t
i
o
n
,
 
s
e
c
u
r
i
t
y
 
i
n
 
t
h
e
 
P
I
M
 
a
n
d
 
r
e
f
i
n
e
 
(
(cid:141)
a
n
n
o
t
a
t
e
Ž
)
 
t
h
e
 
m
a
r
k
e
d
 
P
I
M
 
w
i
t
h
 
s
p
e
c
i
f
i
c
 
i
m
p
l
e
m
e
n
t
a
t
i
o
n
 
d
e
t
a
i
l
s
 
f
o
r
 
e
a
c
h
 
P
S
M
 
(
F
i
g
u
r
e
.
 
 
 
A
 
m
o
d
e
l
 
m
a
p
p
i
n
g
 
t
o
o
l
 
g
e
n
e
r
a
t
e
s
 
a
 
P
S
M
 
f
r
o
m
 
t
h
e
 
m
a
r
k
e
d
 
P
I
M
 
a
n
d
 
t
h
e
 
p
l
a
t
f
o
r
m
 
s
p
e
c
i
f
i
c
 
a
n
n
o
t
a
t
i
o
n
.
 
 
T
h
e
 
P
S
M
 
c
a
n
 
b
e
 
e
x
e
c
u
t
e
d
 
i
n
 
a
 
m
o
d
e
l
i
n
g
 
e
n
v
i
r
o
n
m
e
n
t
 
u
s
i
n
g
 
a
 
v
i
r
t
u
a
l
 
m
a
c
h
i
n
e
 
a
p
p
r
o
a
c
h
 
 
o
r
 
t
r
a
n
s
l
a
t
e
d
 
i
n
t
o
 
e
x
e
c
u
t
a
b
l
e
 
a
r
t
i
f
a
c
t
s
 
(
c
o
d
e
 
a
n
d
 
c
o
n
f
i
g
u
r
a
t
i
o
n
 
f
i
l
e
s
)
 
u
s
i
n
g
 
a
 
c
o
d
e
 
g
e
n
e
r
a
t
i
o
n
 
a
p
p
r
o
a
c
h
 
.
 
 
T
h
e
 
M
D
A
 
r
e
u
s
e
s
 
a
 
P
I
M
 
b
e
c
a
u
s
e
 
t
h
e
 
s
a
m
e
 
P
I
M
 
c
a
n
 
b
e
 
u
s
e
d
 
t
o
 
g
e
n
e
r
a
t
e
 
d
i
f
f
e
r
e
n
t
 
P
S
M
s
 
b
y
 
u
s
i
n
g
 
d
i
f
f
e
r
e
n
t
 
a
n
n
o
t
a
t
i
o
n
s
 
a
n
d
 
m
a
p
p
i
n
g
 
r
u
l
e
s
.
 
F
i
g
u
r
e
 
P
I
M
,
 
P
S
M
 
a
n
d
 
m
a
p
p
i
n
g
 
p
r
o
c
e
s
s
 
O
n
e
 
o
f
 
t
h
e
 
i
m
p
o
r
t
a
n
t
 
o
b
j
e
c
t
 
s
e
r
v
i
c
e
s
 
i
s
 
t
r
a
n
s
a
c
t
i
o
n
s
.
 
 
T
r
a
n
s
a
c
t
i
o
n
s
 
a
r
e
 
e
s
s
e
n
t
i
a
l
 
f
o
r
 
b
u
i
l
d
i
n
g
 
r
e
l
i
a
b
l
e
,
 
l
a
r
g
e
 
s
c
a
l
e
 
e
n
t
e
r
p
r
i
s
e
 
a
p
p
l
i
c
a
t
i
o
n
s
 
.
 
 
H
o
w
e
v
e
r
,
 
d
e
s
i
g
n
i
n
g
 
t
r
a
n
s
a
c
t
i
o
n
a
l
 
a
p
p
l
i
c
a
t
i
o
n
s
 
u
s
u
a
l
l
y
 
i
n
v
o
l
v
e
s
 
i
m
p
l
e
m
e
n
t
a
t
i
o
n
 
d
e
t
a
i
l
s
 
s
u
c
h
 
a
s
 
c
h
o
i
c
e
s
 
o
f
 
p
e
r
s
i
s
t
e
n
c
e
 
t
e
c
h
n
o
l
o
g
y
 
o
r
 
t
y
p
e
s
 
o
f
 
a
p
p
l
i
c
a
t
i
o
n
 
m
i
d
d
l
e
w
a
r
e
 
u
s
e
d
 
i
n
 
t
h
e
 
s
y
s
t
e
m
 
b
e
c
a
u
s
e
 
d
i
f
f
e
r
e
n
t
 
m
i
d
d
l
e
w
a
r
e
 
e
n
f
o
r
c
e
 
d
i
f
f
e
r
e
n
t
 
w
a
y
s
 
o
f
 
p
e
r
s
i
s
t
i
n
g
 
o
b
j
e
c
t
s
,
 
m
a
n
a
g
i
n
g
 
t
r
a
n
s
a
c
t
i
o
n
s
 
a
n
d
 
s
p
e
c
i
f
y
i
n
g
 
c
o
n
c
u
r
r
e
n
c
y
 
l
e
v
e
l
s
.
 
 
A
b
s
t
r
a
c
t
i
n
g
 
t
r
a
n
s
a
c
t
i
o
n
 
s
u
p
p
o
r
t
 
a
t
 
t
h
e
 
P
I
M
 
l
e
v
e
l
 
w
i
l
l
 
m
a
k
e
 
t
h
e
 
a
p
p
l
i
c
a
t
i
o
n
 
m
o
d
e
l
 
i
n
d
e
p
e
n
d
e
n
t
 
o
f
 
i
m
p
l
e
m
e
n
t
a
t
i
o
n
 
c
h
o
i
c
e
s
 
a
n
d
 
a
l
l
o
w
 
u
s
 
t
o
 
s
w
i
t
c
h
 
i
m
p
l
e
m
e
n
t
a
t
i
o
n
 
c
h
o
i
c
e
s
.
 
 
T
h
e
 
n
e
x
t
 
s
e
c
t
i
o
n
 
s
h
o
w
s
 
t
h
a
t
 
a
d
d
i
n
g
 
t
r
a
n
s
a
c
t
i
o
n
 
s
u
p
p
o
r
t
 
r
e
q
u
i
r
e
s
 
k
n
o
w
l
e
d
g
e
 
a
b
o
u
t
 
t
h
e
 
t
r
a
n
s
a
c
t
i
o
n
 
b
o
u
n
d
a
r
y
 
a
n
d
 
t
r
a
n
s
a
c
t
i
o
n
a
l
 
m
i
d
d
l
e
w
a
r
e
.
 
 
I
f
 
w
e
 
w
a
n
t
 
t
o
 
i
n
c
r
e
a
s
e
 
t
h
e
 
a
b
s
t
r
a
c
t
i
o
n
 
l
e
v
e
l
 
o
f
 
t
r
a
n
s
a
c
t
i
o
n
s
,
 
t
h
e
 
P
I
M
 
m
u
s
t
 
u
s
e
 
n
o
t
a
t
i
o
n
s
 
t
h
a
t
 
c
o
n
t
a
i
n
 
t
h
a
t
 
k
n
o
w
l
e
d
g
e
 
a
n
d
 
y
e
t
 
d
o
 
n
o
t
 
d
e
p
e
n
d
 
o
n
 
m
i
d
d
l
e
w
a
r
e
.
 
 
C
o
n
s
i
d
e
r
 
a
n
 
e
-
c
o
m
m
e
r
c
e
 
o
r
d
e
r
 
e
x
a
m
p
l
e
 
a
d
a
p
t
e
d
 
f
r
o
m
 
i
B
A
T
I
S
(cid:144)
s
 
J
P
e
t
S
t
o
r
e
 
.
 
 
 
 
S
u
p
p
o
s
e
 
a
 
s
i
m
p
l
e
 
o
r
d
e
r
 
s
y
s
t
e
m
 
c
o
n
t
a
i
n
s
 
a
n
 
m
e
t
h
o
d
 
t
h
a
t
 
u
p
d
a
t
e
s
 
t
w
o
 
k
i
n
d
s
 
o
f
 
o
b
j
e
c
t
s
 
a
s
 
a
 
s
i
n
g
l
e
 
u
n
i
t
 
o
f
 
w
o
r
k
.
 
 
T
h
e
 
m
e
t
h
o
d
 
c
r
e
a
t
e
s
 
a
n
 
o
r
d
e
r
 
c
o
n
t
a
i
n
i
n
g
 
a
l
l
 
l
i
n
e
 
i
t
e
m
s
 
a
n
d
 
u
p
d
a
t
e
s
 
t
h
e
 
q
u
a
n
t
i
t
y
 
o
f
 
e
a
c
h
 
l
i
n
e
 
i
t
e
m
 
f
r
o
m
 
t
h
e
 
i
t
e
m
 
i
n
v
e
n
t
o
r
y
.
 
T
h
e
s
e
 
u
p
d
a
t
e
s
 
m
u
s
t
 
b
e
 
a
t
o
m
i
c
 
t
o
 
e
n
s
u
r
e
 
t
h
a
t
 
b
o
t
h
 
u
p
d
a
t
e
s
 
s
u
c
c
e
e
d
 
o
r
 
n
o
t
 
a
t
 
a
l
l
.
 
 
A
 
s
i
m
p
l
e
 
s
p
e
c
i
f
i
c
a
t
i
o
n
 
w
i
l
l
 
l
o
o
k
 
l
i
k
e
 
L
i
s
t
i
n
g
b
e
l
o
w
.
 
/
*
)
)
}
L
i
s
t
i
n
g
 
A
n
 
m
e
t
h
o
d
 
e
x
a
m
p
l
e
 
J
P
e
t
S
t
o
r
e
 
u
s
e
s
 
t
h
e
 
D
a
t
a
 
A
c
c
e
s
s
 
O
b
j
e
c
t
 
(
D
A
O
)
 
p
a
t
t
e
r
n
[
9
]
 
a
s
 
a
 
r
e
s
o
u
r
c
e
 
m
a
n
a
g
e
r
 
t
o
 
m
a
n
i
p
u
l
a
t
e
 
o
b
j
e
c
t
 
d
a
t
a
.
 
 
T
h
e
 
m
e
t
h
o
d
 
a
c
t
s
 
a
s
 
a
 
u
n
i
t
 
o
f
 
w
o
r
k
 
s
u
c
h
 
t
h
a
t
 
a
l
l
 
c
h
a
n
g
e
s
 
t
o
 
t
h
e
 
o
r
d
e
r
 
a
n
d
 
l
i
n
e
 
i
t
e
m
s
 
m
u
s
t
 
b
e
 
s
t
o
r
e
d
 
i
n
 
p
e
r
s
i
s
t
e
n
c
e
 
s
t
o
r
a
g
e
 
o
r
 
t
h
e
 
t
r
a
n
s
a
c
t
i
o
n
 
m
u
s
t
 
b
e
 
r
o
l
l
e
d
 
b
a
c
k
 
t
o
 
t
h
e
 
o
r
i
g
i
n
a
l
 
s
t
a
t
e
.
 
 
T
h
e
 
s
p
e
c
i
f
i
c
a
t
i
o
n
 
a
b
o
v
e
 
u
s
e
s
 
a
 
J
a
v
a
D
o
c
 
@
t
r
a
n
s
a
c
t
i
o
n
 
c
o
m
m
e
n
t
 
t
o
 
i
n
d
i
c
a
t
e
 
t
h
a
t
 
t
h
i
s
 
m
e
t
h
o
d
 
i
s
 
t
r
a
n
s
a
c
t
i
o
n
a
l
 
b
u
t
 
d
o
e
s
 
n
o
t
 
s
h
o
w
 
h
o
w
 
t
h
e
 
t
r
a
n
s
a
c
t
i
o
n
 
i
s
 
i
m
p
l
e
m
e
n
t
e
d
,
 
w
h
e
r
e
 
e
x
c
e
p
t
i
o
n
s
 
a
r
e
 
h
a
n
d
l
e
d
 
o
r
 
w
h
e
r
e
 
t
h
e
 
d
a
t
a
 
a
r
e
 
s
t
o
r
e
d
.
 
 
T
h
e
 
a
c
t
u
a
l
 
i
m
p
l
e
m
e
n
t
a
t
i
o
n
 
m
u
s
t
 
a
d
d
r
e
s
s
 
t
h
e
m
.
 
I
f
 
t
h
e
 
o
r
d
e
r
 
a
n
d
 
i
n
v
e
n
t
o
r
y
 
d
a
t
a
 
r
e
s
i
d
e
 
i
n
 
t
h
e
 
s
a
m
e
 
d
a
t
a
b
a
s
e
,
 
t
h
e
y
 
c
a
n
 
b
e
 
a
c
c
e
s
s
e
d
 
a
t
o
m
i
c
a
l
l
y
 
b
y
 
c
r
e
a
t
i
n
g
 
a
 
t
r
a
n
s
a
c
t
i
o
n
 
f
r
o
m
 
t
h
e
 
d
a
t
a
b
a
s
e
 
t
r
a
n
s
a
c
t
i
o
n
 
m
a
n
a
g
e
r
;
 
d
a
t
a
 
m
a
n
i
p
u
l
a
t
i
o
n
 
i
s
 
p
r
o
c
e
s
s
e
d
 
i
n
 
t
h
e
 
s
a
m
e
 
t
r
a
n
s
a
c
t
i
o
n
 
c
o
n
t
e
x
t
.
 
 
T
h
i
s
 
t
r
a
n
s
a
c
t
i
o
n
 
i
s
 
c
o
n
s
i
d
e
r
e
d
 
l
o
c
a
l
 
b
e
c
a
u
s
e
 
i
t
 
i
s
 
m
a
n
a
g
e
d
 
b
y
 
a
 
s
i
n
g
l
e
 
t
r
a
n
s
a
c
t
i
o
n
 
m
a
n
a
g
e
r
.
 
 
H
o
w
e
v
e
r
,
 
i
f
 
t
h
i
s
 
e
-
c
o
m
m
e
r
c
e
 
s
y
s
t
e
m
 
a
l
s
o
 
s
e
l
l
s
 
s
u
p
p
l
i
e
r
s
(cid:144)
 
p
r
o
d
u
c
t
s
 
a
s
 
w
e
l
l
 
a
s
 
i
t
s
 
o
w
n
 
o
r
 
t
h
e
 
s
y
s
t
e
m
 
m
o
v
e
s
 
t
h
e
 
i
n
v
e
n
t
o
r
y
 
d
a
t
a
 
i
n
t
o
 
a
n
o
t
h
e
r
 
d
a
t
a
b
a
s
e
 
t
h
e
n
 
i
t
 
w
i
l
l
 
u
s
e
 
m
o
r
e
 
t
h
a
n
 
o
n
e
 
d
a
t
a
b
a
s
e
 
a
n
d
 
s
o
 
t
h
e
 
u
s
t
 
s
u
p
p
o
r
t
 
d
i
s
t
r
i
b
u
t
e
d
 
t
r
a
n
s
a
c
t
i
o
n
.
 
 
D
i
s
t
r
i
b
u
t
e
d
 
t
r
a
n
s
a
c
t
i
o
n
 
g
u
a
r
a
n
t
e
e
s
 
t
h
e
 
c
o
n
s
i
s
t
e
n
c
y
 
o
f
 
d
a
t
a
b
a
s
e
 
o
p
e
r
a
t
i
o
n
s
 
a
c
r
o
s
s
 
m
u
l
t
i
p
l
e
 
d
a
t
a
b
a
s
e
 
b
o
u
n
d
a
r
i
e
s
 
b
u
t
 
r
e
q
u
i
r
e
s
 
h
i
g
h
 
o
v
e
r
h
e
a
d
 
i
n
 
d
i
s
t
r
i
b
u
t
e
d
 
s
y
n
c
h
r
o
n
i
z
a
t
i
o
n
 
m
e
c
h
a
n
i
s
m
 
a
n
d
 
s
h
o
u
l
d
 
b
e
 
u
s
e
d
 
o
n
l
y
 
w
h
e
n
 
n
e
c
e
s
s
a
r
y
.
 
 
L
i
s
t
i
n
g
s
h
o
w
s
 
a
n
 
i
m
p
l
e
m
e
n
t
a
t
i
o
n
 
o
f
 
a
 
l
o
c
a
l
 
t
r
a
n
s
a
c
t
i
o
n
 
p
r
o
v
i
d
e
d
 
b
y
 
i
B
A
T
I
S
(cid:144)
 
D
A
O
 
f
r
a
m
e
w
o
r
k
 
w
h
i
l
e
 
L
i
s
t
i
n
g
u
s
e
s
 
J
a
v
a
 
T
r
a
n
s
a
c
t
i
o
n
 
S
e
r
v
i
c
e
 
(
J
T
S
)
 
 
t
o
 
i
m
p
l
e
m
e
n
t
 
a
 
d
i
s
t
r
i
b
u
t
e
d
 
t
r
a
n
s
a
c
t
i
o
n
.
 
)
)
)
   itemDao.update Quantity(order)
; 
   storeDao Manager.commitTransaction (
; 
   } catch (Exception e )  { 
    /
/ omit roll back exception handling 
    
storeDaom Manager.rollbackTransaction (
; 
   } 

 2.

insertOrder 

pri vate void insertOrder (Order order ) 
throws DaoException { 
  try { 

ja vax.transaction.UserTransaction 
ut = context.getUserTransaction (
; 
   ut.begin (
; 
   
(cid:141)ordernum Ž
order.setOrderId(getNextId (
;      
   orderDao.insertOrder(order)
; 
   itemDao.update Quantity(order)
; 
   ut.commit(
; 
   } catch (Exception e )  { 
/ omit rollback exception handling 
    /
    ut.rollback (
; 
   } 

 3.

insertOrder 

J2E

  3.

insertOrder 

  1.

3. Challenges in platform independent  
transaction service 

Transaction Manager
Transaction Manager

Resource Manager
Resource Manager

1.. *
1.. *

Resources
Resources

Application
Application

1.. *
1.. *

 2.

  2 

1.

Local/global  transaction  scope. 

  transaction  scope

[11 ]

[12 ]

Proceedings of the 2005  Ninth IEEE International ED
 IEEE 
0-7695-2441-9/05 $20.00 © 2005

OC Enterprise Computing Conference (ED OC í05) 

)
)
}
L
i
s
t
i
n
g
 
T
h
e
 
w
i
t
h
 
l
o
c
a
l
 
t
r
a
n
s
a
c
t
i
o
n
 
)
)
)
)
)
)
}
L
i
s
t
i
n
g
 
T
h
e
 
w
i
t
h
 
d
i
s
t
r
i
b
u
t
e
d
 
t
r
a
n
s
a
c
t
i
o
n
 
N
o
t
i
c
e
 
t
h
a
t
 
b
o
t
h
 
t
h
e
 
D
A
O
 
a
n
d
 
U
s
e
r
T
r
a
n
s
a
c
t
i
o
n
 
r
e
q
u
i
r
e
 
a
 
d
e
c
l
a
r
a
t
i
v
e
 
t
r
a
n
s
a
c
t
i
o
n
 
p
o
l
i
c
y
 
t
h
a
t
 
i
s
 
n
o
t
 
s
h
o
w
n
 
i
n
 
t
h
e
 
l
i
s
t
i
n
g
.
T
h
e
 
d
i
s
t
r
i
b
u
t
e
d
 
i
m
p
l
e
m
e
n
t
a
t
i
o
n
 
r
e
q
u
i
r
e
s
 
a
 
E
 
c
o
n
t
a
i
n
e
r
 
t
o
 
u
s
e
 
J
T
S
.
 
 
 
T
h
e
r
e
 
a
r
e
 
t
w
o
 
i
m
p
o
r
t
a
n
t
 
p
o
i
n
t
s
 
i
n
 
t
h
e
 
c
o
d
e
 
i
n
 
L
i
s
t
i
n
g
 
 
F
i
r
s
t
,
 
t
h
e
 
d
e
v
e
l
o
p
e
r
 
h
a
s
 
t
o
 
e
x
p
l
i
c
i
t
l
y
 
i
m
p
l
e
m
e
n
t
 
t
h
e
 
s
u
p
p
o
r
t
 
f
o
r
 
b
o
t
h
 
l
o
c
a
l
 
a
n
d
 
d
i
s
t
r
i
b
u
t
e
d
 
t
r
a
n
s
a
c
t
i
o
n
s
 
e
v
e
n
 
t
h
o
u
g
h
 
t
h
e
 
d
i
s
t
r
i
b
u
t
i
o
n
 
d
e
c
i
s
i
o
n
 
m
a
y
 
n
o
t
 
b
e
 
m
a
d
e
 
u
n
t
i
l
 
t
h
e
 
s
o
f
t
w
a
r
e
 
c
o
n
f
i
g
u
r
a
t
i
o
n
 
m
a
n
a
g
e
m
e
n
t
 
p
h
a
s
e
.
 
 
S
e
c
o
n
d
,
 
b
o
t
h
 
i
m
p
l
e
m
e
n
t
a
t
i
o
n
s
 
d
e
p
e
n
d
 
o
n
 
h
o
w
 
t
h
e
 
m
i
d
d
l
e
w
a
r
e
 
s
u
p
p
o
r
t
s
 
t
r
a
n
s
a
c
t
i
o
n
s
 
a
n
d
 
t
h
u
s
 
m
a
k
e
s
 
i
t
 
h
a
r
d
e
r
 
t
o
 
c
h
a
n
g
e
 
t
h
e
 
c
o
d
e
 
f
r
o
m
 
o
n
e
 
i
m
p
l
e
m
e
n
t
a
t
i
o
n
 
t
o
 
a
n
o
t
h
e
r
,
 
i
.
e
.
,
 
m
o
v
i
n
g
 
f
r
o
m
 
J
T
S
 
t
o
 
C
O
R
B
A
 
T
r
a
n
s
a
c
t
i
o
n
 
S
e
r
v
i
c
e
.
 
 
W
e
 
w
a
n
t
 
t
o
 
m
a
k
e
 
t
h
e
 
i
n
d
e
p
e
n
d
e
n
t
 
o
f
 
d
a
t
a
 
s
o
u
r
c
e
s
 
a
n
d
 
t
r
a
n
s
a
c
t
i
o
n
 
s
u
p
p
o
r
t
 
p
o
l
i
c
y
 
s
o
 
t
h
a
t
 
t
h
e
 
p
l
a
t
f
o
r
m
 
i
n
d
e
p
e
n
d
e
n
t
 
i
m
p
l
e
m
e
n
t
a
t
i
o
n
 
i
s
 
a
s
 
s
i
m
p
l
e
 
a
s
 
t
h
a
t
 
i
n
 
L
i
s
t
i
n
g
 
 
W
e
 
w
i
l
l
 
s
h
o
w
 
t
h
a
t
 
a
 
m
a
p
p
i
n
g
 
t
o
o
l
 
c
a
n
 
g
e
n
e
r
a
t
e
 
d
i
f
f
e
r
e
n
t
 
P
S
M
s
 
f
r
o
m
 
t
h
e
 
s
a
m
e
 
P
I
M
 
w
i
t
h
 
e
a
c
h
 
s
p
e
c
i
f
i
c
 
a
n
n
o
t
a
t
i
o
n
.
 
 
H
o
w
e
v
e
r
,
 
b
e
f
o
r
e
 
d
o
i
n
g
 
s
o
,
 
i
t
 
i
s
 
i
m
p
o
r
t
a
n
t
 
t
o
 
d
e
s
c
r
i
b
e
 
a
 
t
r
a
n
s
a
c
t
i
o
n
 
m
o
d
e
l
 
a
n
d
 
h
o
w
 
t
o
 
s
u
p
p
o
r
t
 
t
r
a
n
s
a
c
t
i
o
n
s
 
i
n
 
a
 
p
l
a
t
f
o
r
m
 
i
n
d
e
p
e
n
d
e
n
t
 
w
a
y
.
 
F
i
g
u
r
e
 
T
r
a
n
s
a
c
t
i
o
n
a
l
 
M
o
d
e
l
 
F
i
g
u
r
e
s
h
o
w
s
 
a
n
 
a
p
p
l
i
c
a
t
i
o
n
 
t
r
a
n
s
a
c
t
i
o
n
a
l
 
m
o
d
e
l
.
 
 
A
n
 
a
p
p
l
i
c
a
t
i
o
n
 
a
c
c
e
s
s
e
s
 
d
a
t
a
 
f
r
o
m
 
o
n
e
 
o
r
 
m
o
r
e
 
r
e
s
o
u
r
c
e
 
m
a
n
a
g
e
r
s
.
 
 
A
 
r
e
s
o
u
r
c
e
 
m
a
n
a
g
e
r
 
m
a
n
a
g
e
s
 
a
 
s
e
t
 
o
f
 
d
a
t
a
 
t
h
a
t
 
c
a
n
 
b
e
 
r
e
a
d
 
o
r
 
w
r
i
t
t
e
n
 
b
y
 
p
r
o
v
i
d
i
n
g
 
d
a
t
a
 
s
o
u
r
c
e
 
i
n
t
e
r
f
a
c
e
s
 
t
o
 
r
e
s
o
u
r
c
e
s
.
 
 
E
a
c
h
 
d
a
t
a
 
s
o
u
r
c
e
 
p
r
o
v
i
d
e
s
 
a
 
c
o
n
n
e
c
t
i
o
n
 
t
o
 
r
e
s
o
u
r
c
e
s
 
a
n
d
 
t
h
e
 
c
o
n
n
e
c
t
i
o
n
 
c
a
n
 
b
e
 
p
o
o
l
e
d
.
 
 
T
y
p
i
c
a
l
 
r
e
s
o
u
r
c
e
 
m
a
n
a
g
e
r
s
 
a
r
e
 
a
 
R
D
B
M
S
,
 
a
n
 
O
D
B
M
S
,
 
o
r
 
a
n
 
X
M
L
 
D
B
M
S
.
 
 
I
f
 
t
h
e
 
a
p
p
l
i
c
a
t
i
o
n
 
n
e
e
d
s
 
t
o
 
a
c
c
e
s
s
 
m
u
l
t
i
p
l
e
 
d
a
t
a
 
s
o
u
r
c
e
s
 
a
t
o
m
i
c
a
l
l
y
,
 
i
t
 
s
h
o
u
l
d
 
o
b
t
a
i
n
 
a
 
t
r
a
n
s
a
c
t
i
o
n
 
m
a
n
a
g
e
r
 
f
r
o
m
 
t
h
e
 
r
e
s
o
u
r
c
e
 
m
a
n
a
g
e
r
 
t
o
 
m
a
n
a
g
e
 
t
h
e
 
t
r
a
n
s
a
c
t
i
o
n
 
b
o
u
n
d
a
r
y
 
o
f
 
t
h
e
 
a
t
o
m
i
c
 
o
p
e
r
a
t
i
o
n
s
.
 
 
T
h
e
r
e
 
a
r
e
 
f
o
u
r
 
p
r
i
m
a
r
y
 
c
o
n
c
e
r
n
s
 
i
n
 
s
u
p
p
o
r
t
i
n
g
 
h
i
g
h
 
l
e
v
e
l
,
 
p
l
a
t
f
o
r
m
 
i
n
d
e
p
e
n
d
e
n
t
 
t
r
a
n
s
a
c
t
i
o
n
s
.
 
 
A
i
n
d
i
c
a
t
e
s
 
t
h
e
 
t
y
p
e
 
o
f
 
t
h
e
 
d
a
t
a
b
a
s
e
 
m
a
n
a
g
e
m
e
n
t
 
s
y
s
t
e
m
 
.
 
 
T
h
e
 
s
c
o
p
e
 
o
f
 
a
 
t
r
a
n
s
a
c
t
i
o
n
 
i
s
 
l
o
c
a
l
 
i
f
 
t
h
e
 
t
r
a
n
s
a
c
t
i
o
n
 
m
a
n
i
p
u
l
a
t
e
s
 
o
b
j
e
c
t
s
 
t
h
a
t
 
a
r
e
 
m
a
n
a
g
e
d
 
b
y
 
a
 
s
i
n
g
l
e
 
r
e
s
o
u
r
c
e
 
m
a
n
a
g
e
r
.
 
 
I
f
 
t
h
e
 
r
e
s
o
u
r
c
e
 
m
a
n
a
g
e
r
 
i
s
 
a
 
D
B
M
S
,
 
t
h
e
 
t
r
a
n
s
a
c
t
i
o
n
 
i
s
 
h
a
n
d
l
e
d
 
b
y
 
t
h
e
 
t
r
a
n
s
a
c
t
i
o
n
 
s
u
p
p
o
r
t
 
f
r
o
m
 
t
h
e
 
d
a
t
a
b
a
s
e
 
c
o
n
n
e
c
t
i
o
n
.
 
O
n
 
t
h
e
 
o
t
h
e
r
 
h
a
n
d
,
 
t
h
e
 
s
c
o
p
e
 
o
f
 
a
 
t
r
a
n
s
a
c
t
i
o
n
 
i
s
 
g
l
o
b
a
l
 
i
f
 
t
h
e
 
t
r
a
n
s
a
c
t
i
o
n
 
m
a
n
i
p
u
l
a
t
e
s
 
o
b
j
e
c
t
s
 
f
r
o
m
 
d
i
f
f
e
r
e
n
t
 
r
e
s
o
u
r
c
e
 
m
a
n
a
g
e
r
s
.
 
A
 
d
i
s
t
r
i
b
u
t
e
d
 
t
r
a
n
s
a
c
t
i
o
n
 
m
a
n
a
g
e
r
 
i
s
 
n
e
e
d
e
d
 
t
o
 
c
o
o
r
d
i
n
a
t
e
 
c
h
a
n
g
e
s
 
t
o
 
o
b
j
e
c
t
s
 
f
r
o
m
 
d
i
f
f
e
r
e
n
t
 
r
e
s
o
u
r
c
e
 
m
a
n
a
g
e
r
s
.
 
 
 
T
h
e
s
e
 
r
e
s
o
u
r
c
e
 
m
a
n
a
g
e
r
s
 
m
u
s
t
 
s
u
p
p
o
r
t
 
d
i
s
t
r
i
b
u
t
e
d
 
t
r
a
n
s
a
c
t
i
o
n
 
c
o
m
m
i
t
 
a
n
d
 
r
o
l
l
b
a
c
k
 
s
u
c
h
 
a
s
 
t
w
o
-
p
h
a
s
e
 
c
o
m
m
i
t
 
t
o
 
e
n
s
u
r
e
 
d
a
t
a
 
c
o
n
s
i
s
t
e
n
c
y
 
a
c
r
o
s
s
 
o
b
j
e
c
t
s
 
i
n
 
t
h
e
 
t
r
a
n
s
a
c
t
i
o
n
.
 
F
o
r
 
e
x
a
m
p
l
e
,
 
a
 
f
u
n
d
 
t
r
a
n
s
f
e
r
 
s
y
s
t
e
m
 
w
i
t
h
d
r
a
w
s
 
m
o
n
e
y
 
f
r
o
m
 
a
n
 
a
c
c
o
u
n
t
 
f
r
o
m
 
o
n
e
 
b
a
n
k
 
a
n
d
 
d
e
p
o
s
i
t
s
 
t
h
e
 
s
a
m
e
 
a
m
o
u
n
t
 
m
i
n
u
s
 
a
 
p
r
o
c
e
s
s
i
n
g
 
f
e
e
 
i
n
t
o
 
a
n
o
t
h
e
r
 
a
c
c
o
u
n
t
 
i
n
 
a
n
o
t
h
e
r
 
b
a
n
k
 
(
t
h
e
 
p
r
o
c
e
s
s
i
n
g
 
f
e
e
 
i
n
i
t
i
a
t
e
s
 
a
 
n
e
s
t
e
d
 
t
r
a
n
s
a
c
t
i
o
n
 
t
h
a
t
 
d
e
p
o
s
i
t
s
 
i
t
 
i
n
t
o
 
t
h
e
 
p
r
o
c
e
s
s
i
n
g
 
b
a
n
k
(cid:144)
s
 
o
w
n
 
a
c
c
o
u
n
t
)
.
 
 
S
i
n
c
e
 
e
a
c
h
 
b
a
n
k
 
h
a
s
 
i
t
s
 
o
w
n
 
d
a
t
a
b
a
s
e
,
 
i
t
 
i
s
 
n
o
t
 
p
o
s
s
i
b
l
e
 
t
o
 
u
s
e
 
o
n
e
 
d
a
t
a
b
a
s
e
 
m
a
n
a
g
e
r
 
t
o
 
g
u
a
r
a
n
t
e
e
 
a
t
o
m
i
c
i
t
y
 
a
n
d
 
c
o
n
s
i
s
t
e
n
c
y
 
a
c
r
o
s
s
 
m
u
l
t
i
p
l
e
 
d
a
t
a
b
a
s
e
s
.
 
 1.

 3.

J2E

read
read

update
update

validate
validate

3.

 Transaction  granularity.

2.

 Concurrency   control.

[13 ]

[14 ]

1.

  3)

[12 ]

Proceedings of the 2005  Ninth IEEE International ED
 IEEE 
0-7695-2441-9/05 $20.00 © 2005

OC Enterprise Computing Conference (ED OC í05) 

T
r
a
n
s
a
c
t
i
o
n
 
s
c
o
p
e
 
s
u
p
p
o
r
t
 
a
t
 
t
h
e
 
P
I
M
 
l
e
v
e
l
 
i
m
p
l
i
e
s
 
t
h
a
t
 
t
h
e
 
m
o
d
e
l
 
m
a
p
p
i
n
g
 
t
o
o
l
 
m
u
s
t
 
k
n
o
w
 
t
h
e
 
d
a
t
a
 
s
o
u
r
c
e
 
o
f
 
e
a
c
h
 
o
b
j
e
c
t
 
i
n
v
o
l
v
e
d
 
i
n
 
a
 
t
r
a
n
s
a
c
t
i
o
n
.
 
 
T
h
e
 
d
a
t
a
 
s
o
u
r
c
e
 
o
f
 
e
a
c
h
 
o
b
j
e
c
t
 
i
s
 
d
e
f
i
n
e
d
 
a
t
 
t
h
e
 
c
l
a
s
s
 
l
e
v
e
l
 
i
n
 
a
 
p
e
r
s
i
s
t
e
n
c
e
 
a
n
n
o
t
a
t
i
o
n
.
 
 
T
h
e
 
t
o
o
l
 
f
i
n
d
s
 
o
b
j
e
c
t
s
 
a
c
c
e
s
s
i
b
l
e
 
f
r
o
m
 
t
h
e
 
t
r
a
n
s
a
c
t
i
o
n
a
l
 
o
p
e
r
a
t
i
o
n
 
i
n
 
t
h
e
 
P
I
M
 
a
n
d
 
o
b
t
a
i
n
s
 
t
h
e
 
d
a
t
a
 
s
o
u
r
c
e
s
 
o
f
 
t
h
e
 
o
b
j
e
c
t
s
 
f
r
o
m
 
t
h
e
 
p
e
r
s
i
s
t
e
n
c
e
 
a
n
n
o
t
a
t
i
o
n
 
o
f
 
t
h
e
 
o
b
j
e
c
t
(cid:144)
s
 
c
l
a
s
s
 
t
o
 
c
h
o
o
s
e
 
a
n
 
a
p
p
r
o
p
r
i
a
t
e
 
k
i
n
d
 
o
f
 
t
r
a
n
s
a
c
t
i
o
n
.
 
 
I
f
 
o
b
j
e
c
t
s
 
r
e
s
i
d
e
 
i
n
 
t
h
e
 
s
a
m
e
 
d
a
t
a
b
a
s
e
,
 
i
t
(cid:144)
s
 
m
o
r
e
 
e
f
f
i
c
i
e
n
t
 
t
o
 
u
s
e
 
l
o
c
a
l
 
t
r
a
n
s
a
c
t
i
o
n
s
 
o
b
t
a
i
n
e
d
 
b
y
 
t
h
e
 
d
a
t
a
b
a
s
e
 
m
a
n
a
g
e
r
.
 
 
O
n
 
t
h
e
 
o
t
h
e
r
 
h
a
n
d
,
 
i
f
 
o
b
j
e
c
t
s
 
r
e
s
i
d
e
 
i
n
 
d
i
f
f
e
r
e
n
t
 
d
a
t
a
b
a
s
e
s
,
 
t
h
e
y
 
n
e
e
d
 
a
 
h
i
g
h
e
r
 
o
v
e
r
h
e
a
d
,
 
d
i
s
t
r
i
b
u
t
e
d
 
t
r
a
n
s
a
c
t
i
o
n
 
m
a
n
a
g
e
r
 
t
o
 
c
o
o
r
d
i
n
a
t
e
 
t
r
a
n
s
a
c
t
i
o
n
 
c
o
m
m
i
t
 
a
m
o
n
g
 
m
u
l
t
i
p
l
e
 
d
a
t
a
b
a
s
e
 
m
a
n
a
g
e
r
s
.
 
 
 
E
n
t
e
r
p
r
i
s
e
 
a
p
p
l
i
c
a
t
i
o
n
s
 
a
r
e
 
u
s
e
d
 
b
y
 
m
a
n
y
 
u
s
e
r
s
 
s
i
m
u
l
t
a
n
e
o
u
s
l
y
.
 
 
O
n
e
 
u
s
e
r
 
s
h
o
u
l
d
 
n
o
t
 
s
e
e
 
c
h
a
n
g
e
s
 
m
a
d
e
 
b
y
 
a
n
o
t
h
e
r
 
u
n
t
i
l
 
t
h
e
 
o
t
h
e
r
(cid:144)
s
 
c
h
a
n
g
e
s
 
a
r
e
 
c
o
m
m
i
t
t
e
d
.
 
 
F
o
r
 
e
x
a
m
p
l
e
,
 
m
a
n
y
 
c
u
s
t
o
m
e
r
s
 
o
r
d
e
r
 
p
r
o
d
u
c
t
s
 
f
r
o
m
 
t
h
e
 
e
-
c
o
m
m
e
r
c
e
 
w
e
b
s
i
t
e
 
a
n
d
 
o
f
t
e
n
 
t
h
e
y
 
c
o
m
p
e
t
e
 
t
o
 
p
u
r
c
h
a
s
e
 
t
h
e
 
s
a
m
e
 
p
r
o
d
u
c
t
s
.
 
 
I
f
 
t
h
e
y
 
p
u
t
 
g
o
o
d
s
 
i
n
 
t
h
e
i
r
 
s
h
o
p
p
i
n
g
 
c
a
r
t
 
b
u
t
 
h
a
v
e
 
n
o
t
 
y
e
t
 
p
l
a
c
e
d
 
a
n
 
o
r
d
e
r
,
 
o
t
h
e
r
s
 
w
i
l
l
 
s
t
i
l
l
 
s
e
e
 
t
h
e
s
e
 
g
o
o
d
s
 
a
v
a
i
l
a
b
l
e
.
 
W
h
o
e
v
e
r
 
p
l
a
c
e
s
 
t
h
e
 
o
r
d
e
r
 
f
i
r
s
t
 
w
i
l
l
 
g
e
t
 
t
h
e
 
g
o
o
d
s
 
w
h
i
l
e
 
o
t
h
e
r
s
 
s
e
e
 
t
h
e
 
g
o
o
d
s
 
a
s
 
b
a
c
k
 
o
r
d
e
r
e
d
.
 
 
T
h
e
r
e
f
o
r
e
,
 
d
e
v
e
l
o
p
e
r
s
 
n
e
e
d
 
t
o
 
i
s
o
l
a
t
e
 
c
h
a
n
g
e
s
 
w
i
t
h
i
n
 
o
n
e
 
t
r
a
n
s
a
c
t
i
o
n
 
f
r
o
m
 
a
n
o
t
h
e
r
.
 
 
C
o
n
c
u
r
r
e
n
c
y
 
c
o
n
t
r
o
l
 
 
i
s
 
a
 
m
e
c
h
a
n
i
s
m
 
t
o
 
e
n
s
u
r
e
 
s
e
r
i
a
l
i
z
a
b
i
l
i
t
y
 
o
f
 
c
o
n
c
u
r
r
e
n
t
 
t
r
a
n
s
a
c
t
i
o
n
s
.
 
 
T
h
e
 
l
e
v
e
l
 
o
f
 
i
s
o
l
a
t
i
o
n
 
d
e
t
e
r
m
i
n
e
s
 
t
h
e
 
d
e
g
r
e
e
 
o
f
 
c
o
n
c
u
r
r
e
n
c
y
.
 
 
T
h
e
r
e
 
a
r
e
 
t
w
o
 
g
e
n
e
r
a
l
 
c
l
a
s
s
e
s
 
o
f
 
c
o
n
c
u
r
r
e
n
c
y
 
c
o
n
t
r
o
l
s
;
 
p
e
s
s
i
m
i
s
t
i
c
 
a
n
d
 
o
p
t
i
m
i
s
t
i
c
 
 
.
 
 
P
e
s
s
i
m
i
s
t
i
c
 
c
o
n
c
u
r
r
e
n
c
y
 
c
o
n
t
r
o
l
 
u
s
e
s
 
l
o
c
k
s
 
t
o
 
p
r
e
v
e
n
t
 
c
o
n
c
u
r
r
e
n
t
 
a
c
c
e
s
s
e
s
 
t
o
 
s
h
a
r
e
d
 
r
e
s
o
u
r
c
e
s
.
 
 
T
h
e
 
t
y
p
e
 
o
f
 
l
o
c
k
s
 
(
r
e
a
d
/
w
r
i
t
e
)
 
d
e
p
e
n
d
s
 
o
n
 
t
h
e
 
i
s
o
l
a
t
i
o
n
 
l
e
v
e
l
s
 
s
p
e
c
i
f
i
e
d
 
b
y
 
t
h
e
 
d
e
v
e
l
o
p
e
r
s
.
 
 
A
N
S
I
/
S
Q
L
 
d
e
f
i
n
e
s
 
f
o
u
r
 
s
t
a
n
d
a
r
d
 
l
e
v
e
l
s
;
 
r
e
a
d
 
u
n
c
o
m
m
i
t
t
e
d
,
 
r
e
a
d
 
c
o
m
m
i
t
t
e
d
,
 
r
e
p
e
a
t
a
b
l
e
 
r
e
a
d
 
a
n
d
 
s
e
r
i
a
l
i
z
a
b
l
e
.
 
 
T
h
e
 
i
m
p
a
c
t
 
o
f
 
t
h
e
 
i
s
o
l
a
t
i
o
n
 
o
n
 
d
i
f
f
e
r
e
n
t
 
c
o
n
s
i
s
t
e
n
c
y
 
p
h
e
n
o
m
e
n
a
l
 
i
s
 
s
h
o
w
n
 
i
n
 
T
a
b
l
e
 
O
p
t
i
m
i
s
t
i
c
 
c
o
n
c
u
r
r
e
n
c
y
 
c
o
n
t
r
o
l
 
a
l
l
o
w
s
 
s
i
m
u
l
t
a
n
e
o
u
s
 
a
c
c
e
s
s
e
s
 
t
o
 
s
h
a
r
e
d
 
r
e
s
o
u
r
c
e
s
 
a
n
d
 
u
s
e
s
 
o
b
j
e
c
t
 
s
n
a
p
s
h
o
t
 
o
r
 
v
e
r
s
i
o
n
i
n
g
 
t
o
 
d
e
t
e
c
t
 
p
o
t
e
n
t
i
a
l
 
c
o
n
c
u
r
r
e
n
c
y
 
c
o
n
f
l
i
c
t
s
 
d
u
r
i
n
g
 
t
h
e
 
v
a
l
i
d
a
t
i
o
n
 
s
t
e
p
 
(
F
i
g
u
r
e
.
 
 
S
u
p
p
o
r
t
i
n
g
 
v
e
r
s
i
o
n
i
n
g
 
u
s
u
a
l
l
y
 
r
e
q
u
i
r
e
s
 
m
o
d
i
f
y
i
n
g
 
t
h
e
 
o
b
j
e
c
t
 
s
c
h
e
m
a
 
b
y
 
a
d
d
i
n
g
 
a
 
v
e
r
s
i
o
n
 
f
i
e
l
d
 
(
u
s
e
 
i
n
c
r
e
m
e
n
t
a
l
 
v
e
r
s
i
o
n
 
n
u
m
b
e
r
 
o
r
 
r
e
a
d
/
w
r
i
t
e
 
t
i
m
e
s
t
a
m
p
 
)
.
 
 
 
T
a
b
l
e
 
I
s
o
l
a
t
i
o
n
 
l
e
v
e
l
 
i
m
p
a
c
t
 
o
n
 
t
r
a
n
s
a
c
t
i
o
n
 
c
o
n
s
i
s
t
e
n
c
y
 
C
o
n
s
i
s
t
e
n
c
y
 
P
h
e
n
o
m
e
n
a
l
 
I
s
o
l
a
t
i
o
n
 
L
e
v
e
l
D
i
r
t
y
 
R
e
a
d
N
o
n
-
r
e
p
e
a
t
a
b
l
e
 
R
e
a
d
P
h
a
n
t
o
m
 
R
e
a
d
u
n
c
o
m
m
i
t
t
e
d
 
(cid:0)
¥
(cid:0)
¥
(cid:0)
¥
R
e
a
d
c
o
m
m
i
t
t
e
d
 
×
(cid:0)
¥
(cid:0)
¥
R
e
p
e
a
t
a
b
l
e
 
r
e
a
d
 
×
 
×
 
(cid:0)
¥
S
e
r
i
a
l
i
z
a
b
l
e
 
×
 
×
 
×
 
F
i
g
u
r
e
 
T
h
r
e
e
 
s
t
e
p
s
 
i
n
 
o
p
t
i
m
i
s
t
i
c
 
c
o
n
c
u
r
r
e
n
c
y
 
c
o
n
t
r
o
l
 
T
r
a
n
s
a
c
t
i
o
n
 
s
u
p
p
o
r
t
 
a
t
 
t
h
e
 
P
I
M
 
l
e
v
e
l
 
r
e
q
u
i
r
e
s
 
a
 
m
o
d
e
l
 
n
o
t
a
t
i
o
n
 
t
h
a
t
 
i
n
d
i
c
a
t
e
s
 
t
h
e
 
t
y
p
e
 
o
f
 
c
o
n
c
u
r
r
e
n
c
y
 
c
o
n
t
r
o
l
 
f
o
r
 
e
a
c
h
 
t
r
a
n
s
a
c
t
i
o
n
a
l
 
o
p
e
r
a
t
i
o
n
.
 
 
I
f
 
a
 
p
e
s
s
i
m
i
s
t
i
c
 
c
o
n
t
r
o
l
 
i
s
 
s
p
e
c
i
f
i
e
d
,
 
a
n
 
i
s
o
l
a
t
i
o
n
 
l
e
v
e
l
 
m
u
s
t
 
b
e
 
i
n
d
i
c
a
t
e
d
.
 
 
A
 
m
o
d
e
l
 
m
a
p
p
i
n
g
 
t
o
o
l
 
i
s
 
r
e
s
p
o
n
s
i
b
l
e
 
f
o
r
 
s
p
e
c
i
f
y
i
n
g
 
t
h
e
 
a
p
p
r
o
p
r
i
a
t
e
 
i
s
o
l
a
t
i
o
n
 
l
e
v
e
l
 
f
o
r
 
e
a
c
h
 
t
r
a
n
s
a
c
t
i
o
n
a
l
 
o
p
e
r
a
t
i
o
n
 
i
n
 
t
h
e
 
t
a
r
g
e
t
 
p
l
a
t
f
o
r
m
,
 
f
o
r
 
e
x
a
m
p
l
e
,
 
a
s
 
a
 
d
e
c
l
a
r
a
t
i
v
e
 
t
r
a
n
s
a
c
t
i
o
n
a
l
 
p
o
l
i
c
y
 
i
n
 
t
h
e
 
d
e
p
l
o
y
m
e
n
t
 
d
e
s
c
r
i
p
t
o
r
 
f
i
l
e
 
i
n
 
E
 
p
l
a
t
f
o
r
m
 
o
r
 
a
s
 
a
n
 
i
m
p
l
e
m
e
n
t
a
t
i
o
n
 
c
o
n
f
i
g
u
r
a
t
i
o
n
 
f
i
l
e
 
i
n
 
C
O
R
B
A
 
p
l
a
t
f
o
r
m
.
 
I
f
 
t
h
e
 
c
o
n
c
u
r
r
e
n
c
y
 
c
o
n
t
r
o
l
 
i
s
 
o
p
t
i
m
i
s
t
i
c
,
 
t
h
e
 
m
a
p
p
i
n
g
 
t
o
o
l
 
m
u
s
t
 
t
r
a
n
s
p
a
r
e
n
t
l
y
 
c
r
e
a
t
e
 
a
 
v
e
r
s
i
o
n
 
f
i
e
l
d
 
f
o
r
 
e
a
c
h
 
p
a
r
t
i
c
i
p
a
t
i
n
g
 
o
b
j
e
c
t
s
 
i
n
 
t
h
e
 
P
S
M
 
a
n
d
 
u
s
e
 
i
t
 
t
o
 
c
o
m
p
a
r
e
 
t
h
e
 
o
b
j
e
c
t
 
a
c
c
e
s
s
 
c
o
n
f
l
i
c
t
 
d
u
r
i
n
g
 
t
h
e
 
t
r
a
n
s
a
c
t
i
o
n
 
v
a
l
i
d
a
t
i
o
n
 
s
t
e
p
.
 
 
A
 
v
e
r
s
i
o
n
 
f
i
e
l
d
 
i
s
 
a
d
d
e
d
 
t
o
 
t
h
e
 
m
a
r
k
e
d
 
P
I
M
 
b
u
t
 
i
s
 
n
o
t
 
s
e
e
n
 
i
n
 
t
h
e
 
d
o
m
a
i
n
 
P
I
M
.
 
 
 
 
 
A
 
t
r
a
n
s
a
c
t
i
o
n
 
i
s
 
u
s
u
a
l
l
y
 
s
h
o
r
t
 
a
n
d
 
s
h
o
u
l
d
 
b
e
 
d
o
n
e
 
w
i
t
h
i
n
 
a
 
s
i
n
g
l
e
 
c
l
i
e
n
t
-
s
e
r
v
e
r
 
i
n
v
o
c
a
t
i
o
n
.
 
 
H
o
w
e
v
e
r
,
 
t
h
e
r
e
 
a
r
e
 
c
a
s
e
s
 
w
h
e
r
e
 
a
 
t
r
a
n
s
a
c
t
i
o
n
 
s
p
a
n
s
 
m
u
l
t
i
p
l
e
 
r
e
q
u
e
s
t
s
 
o
r
 
d
e
p
e
n
d
s
 
o
n
 
u
s
e
r
 
i
n
t
e
r
a
c
t
i
o
n
.
 
 
F
o
r
 
e
x
a
m
p
l
e
,
 
a
n
 
o
n
l
i
n
e
 
w
e
b
-
b
a
s
e
d
 
t
r
a
v
e
l
 
r
e
s
e
r
v
a
t
i
o
n
 
w
i
z
a
r
d
 
c
o
n
t
a
i
n
s
 
a
i
r
,
 
c
a
r
 
a
n
d
 
h
o
t
e
l
 
r
e
s
e
r
v
a
t
i
o
n
 
p
a
g
e
s
;
 
a
 
c
u
s
t
o
m
e
r
 
f
i
l
l
s
 
o
u
t
 
i
n
f
o
r
m
a
t
i
o
n
 
f
o
r
 
e
a
c
h
 
p
a
g
e
 
a
n
d
 
c
o
n
f
i
r
m
s
 
t
h
e
 
r
e
s
e
r
v
a
t
i
o
n
 
a
t
 
t
h
e
 
l
a
s
t
 
s
t
e
p
.
 
 
I
f
 
t
h
e
 
c
u
s
t
o
m
e
r
 
c
o
n
f
i
r
m
s
,
 
a
l
l
 
r
e
s
e
r
v
a
t
i
o
n
s
 
a
r
e
 
s
t
o
r
e
d
;
 
o
t
h
e
r
w
i
s
e
,
 
t
h
e
y
 
w
i
l
l
 
b
e
 
d
i
s
c
a
r
d
e
d
 
a
n
d
 
a
v
a
i
l
a
b
l
e
 
t
o
 
o
t
h
e
r
 
c
u
s
t
o
m
e
r
s
.
 
 
T
r
a
n
s
a
c
t
i
o
n
 
g
r
a
n
u
l
a
r
i
t
y
 
i
n
d
i
c
a
t
e
s
 
a
 
l
i
f
e
 
c
y
c
l
e
 
o
f
 
t
h
e
 
t
r
a
n
s
a
c
t
i
o
n
 
a
n
d
 
c
a
n
 
b
e
 
[15 ]

[16 ]

a)
 Request Response
a)
 Request Response
a)
 Request Response

S
S
S

T
T
T

S = Session
S = Session
T  = Database transaction
T  = Database transaction

Application Transaction
Application Transaction
Application Transaction

b)
 Request Response
b)
 Request Response
b)
 Request Response

Request
Request
Request

Response
Response
Response

S1
S1
S1

T1
T1
T1

S2
S2
S2

T2
T2
T2

Detached Instances
Detached Instances
Detached Instances

Application Transaction
Application Transaction
Application Transaction

c )
c )
c )

 Request Response
 Request Response
 Request Response

Request
Request
Request

Response
Response
Response

S
S
S

T1
T1
T1

T2
T2
T2

Datasource disconnection
Datasource disconnection
Datasource disconnection

 4.

4 .

Nested  transaction.

[17 ]

  1)

2)
 3)

4. Unit  of  work modeling 

unit  of  wor k

[18 ]

  5)

Proceedings of the 2005  Ninth IEEE International ED
 IEEE 
0-7695-2441-9/05 $20.00 © 2005

OC Enterprise Computing Conference (ED OC í05) 

p
e
r
-
r
e
q
u
e
s
t
 
(
a
)
,
 
p
e
r
-
r
e
q
u
e
s
t
-
w
i
t
h
-
d
e
t
a
c
h
e
d
-
o
b
j
e
c
t
s
 
(
b
)
 
o
r
 
p
e
r
-
a
p
p
l
i
c
a
t
i
o
n
-
t
r
a
n
s
a
c
t
i
o
n
 
(
c
)
 
 
.
 
 
T
h
e
 
l
a
s
t
 
t
w
o
 
t
y
p
e
s
 
a
r
e
 
c
a
l
l
e
d
 
l
o
n
g
 
l
i
v
e
d
 
t
r
a
n
s
a
c
t
i
o
n
s
 
.
 
F
i
g
u
r
e
 
T
r
a
n
s
a
c
t
i
o
n
 
G
r
a
n
u
l
a
r
i
t
y
;
 
 
a
)
 
p
e
r
-
r
e
q
u
e
s
t
 
 
b
)
 
p
e
r
-
r
e
q
u
e
s
t
-
w
i
t
h
-
d
e
t
a
c
h
e
d
-
o
b
j
e
c
t
s
 
 
c
)
 
p
e
r
-
a
p
p
l
i
c
a
t
i
o
n
-
t
r
a
n
s
a
c
t
i
o
n
.
 
 
 
T
r
a
n
s
a
c
t
i
o
n
 
g
r
a
n
u
l
a
r
i
t
y
 
s
u
p
p
o
r
t
 
a
t
 
t
h
e
 
P
I
M
 
l
e
v
e
l
 
d
e
p
e
n
d
s
 
o
n
 
t
h
e
 
s
u
p
p
o
r
t
 
a
v
a
i
l
a
b
l
e
 
a
t
 
t
h
e
 
P
S
M
 
l
e
v
e
l
.
 
 
I
n
 
a
 
p
e
r
-
r
e
q
u
e
s
t
 
g
r
a
n
u
l
a
r
i
t
y
,
 
t
h
e
 
t
r
a
n
s
a
c
t
i
o
n
 
i
s
 
o
b
t
a
i
n
e
d
 
f
r
o
m
 
a
 
s
e
s
s
i
o
n
 
c
o
n
t
e
x
t
 
o
r
 
f
r
o
m
 
a
 
d
a
t
a
b
a
s
e
 
c
o
n
n
e
c
t
i
o
n
 
a
n
d
 
t
h
e
 
t
r
a
n
s
a
c
t
i
o
n
 
t
e
r
m
i
n
a
t
e
s
 
a
t
 
t
h
e
 
e
n
d
 
o
f
 
t
h
e
 
r
e
q
u
e
s
t
 
s
c
o
p
e
.
 
 
H
o
w
e
v
e
r
,
 
i
f
 
t
h
e
 
t
r
a
n
s
a
c
t
i
o
n
 
s
p
a
n
s
 
m
u
l
t
i
p
l
e
 
r
e
q
u
e
s
t
s
 
a
n
d
 
e
a
c
h
 
r
e
q
u
e
s
t
 
e
x
e
c
u
t
e
s
 
i
n
 
s
e
p
a
r
a
t
e
 
s
e
s
s
i
o
n
s
 
o
r
 
i
n
 
a
 
s
t
a
t
e
l
e
s
s
 
s
e
s
s
i
o
n
 
e
n
v
i
r
o
n
m
e
n
t
,
 
t
h
e
 
t
a
r
g
e
t
 
P
S
M
 
m
u
s
t
 
s
u
p
p
o
r
t
 
d
i
s
c
o
n
n
e
c
t
e
d
 
p
e
r
s
i
s
t
e
n
c
e
 
o
b
j
e
c
t
s
.
 
 
D
i
s
c
o
n
n
e
c
t
i
o
n
 
f
r
o
m
 
p
e
r
s
i
s
t
e
n
c
e
 
s
t
o
r
e
 
a
l
l
o
w
s
 
o
b
j
e
c
t
s
 
t
o
 
b
e
 
a
c
c
e
s
s
e
d
 
o
f
f
l
i
n
e
 
a
n
d
 
s
y
n
c
h
r
o
n
i
z
e
d
 
b
a
c
k
 
d
u
r
i
n
g
 
r
e
c
o
n
n
e
c
t
i
o
n
.
 
 
D
u
r
i
n
g
 
d
i
s
c
o
n
n
e
c
t
i
o
n
,
 
t
h
e
 
s
y
s
t
e
m
 
d
o
e
s
 
n
o
t
 
h
a
v
e
 
t
o
 
m
a
i
n
t
a
i
n
 
t
h
e
 
d
a
t
a
b
a
s
e
 
c
o
n
n
e
c
t
i
o
n
.
 
 
 
O
n
 
t
h
e
 
o
t
h
e
r
 
h
a
n
d
,
 
i
f
 
e
a
c
h
 
r
e
q
u
e
s
t
 
e
x
e
c
u
t
e
s
 
i
n
 
a
 
s
t
a
t
e
f
u
l
 
s
e
s
s
i
o
n
 
e
n
v
i
r
o
n
m
e
n
t
,
 
t
h
e
 
t
a
r
g
e
t
 
P
S
M
 
m
u
s
t
 
s
u
p
p
o
r
t
 
d
a
t
a
b
a
s
e
 
d
i
s
c
o
n
n
e
c
t
i
o
n
 
a
n
d
 
r
e
c
o
n
n
e
c
t
i
o
n
 
a
n
d
 
t
h
e
 
r
e
f
e
r
e
n
c
e
 
t
o
 
t
h
e
 
d
a
t
a
b
a
s
e
 
c
o
n
n
e
c
t
i
o
n
 
m
u
s
t
 
b
e
 
s
t
o
r
e
d
 
i
n
 
t
h
e
 
s
t
a
t
e
f
u
l
 
s
e
s
s
i
o
n
.
 
I
f
 
t
h
e
 
t
r
a
n
s
a
c
t
i
o
n
 
g
r
a
n
u
l
a
r
i
t
y
 
s
p
e
c
i
f
i
e
d
 
a
t
 
t
h
e
 
P
I
M
 
l
e
v
e
l
 
d
o
e
s
 
n
o
t
 
m
a
t
c
h
 
t
h
e
 
t
r
a
n
s
a
c
t
i
o
n
 
s
u
p
p
o
r
t
 
c
a
p
a
b
i
l
i
t
y
 
o
f
 
t
h
e
 
t
a
r
g
e
t
 
P
S
M
,
 
t
h
e
 
m
o
d
e
l
 
m
a
p
p
i
n
g
 
p
r
o
c
e
s
s
 
g
e
n
e
r
a
t
e
s
 
a
n
 
e
r
r
o
r
.
 
 
T
h
e
 
d
e
v
e
l
o
p
e
r
 
m
u
s
t
 
c
h
o
o
s
e
 
a
n
 
a
p
p
r
o
p
r
i
a
t
e
 
t
a
r
g
e
t
 
p
l
a
t
f
o
r
m
 
o
r
 
c
h
a
n
g
e
 
t
h
e
 
d
e
s
i
g
n
 
t
h
a
t
 
u
s
e
s
 
l
e
s
s
 
r
e
s
t
r
i
c
t
i
v
e
 
g
r
a
n
u
l
a
r
i
t
y
.
 
 
 
T
r
a
n
s
a
c
t
i
o
n
s
 
c
a
n
 
b
e
 
n
e
s
t
e
d
 
i
n
s
i
d
e
 
a
 
p
a
r
e
n
t
 
t
r
a
n
s
a
c
t
i
o
n
 
a
t
 
a
n
 
a
r
b
i
t
r
a
r
y
 
d
e
p
t
h
 
.
I
f
 
t
h
e
 
p
a
r
e
n
t
 
t
r
a
n
s
a
c
t
i
o
n
 
f
a
i
l
s
,
 
a
l
l
 
n
e
s
t
e
d
 
t
r
a
n
s
a
c
t
i
o
n
s
 
i
n
c
l
u
d
i
n
g
 
t
h
e
 
p
a
r
e
n
t
 
w
i
l
l
 
b
e
 
r
o
l
l
e
d
 
b
a
c
k
.
 
 
I
f
 
a
 
n
e
s
t
e
d
 
t
r
a
n
s
a
c
t
i
o
n
 
f
a
i
l
s
,
 
t
h
e
 
p
a
r
e
n
t
 
t
r
a
n
s
a
c
t
i
o
n
 
m
a
y
 
d
e
c
i
d
e
 
t
o
 
r
o
l
l
 
b
a
c
k
 
o
n
l
y
 
t
h
e
 
n
e
s
t
e
d
 
t
r
a
n
s
a
c
t
i
o
n
 
a
n
d
 
p
r
o
c
e
e
d
 
o
r
 
r
o
l
l
 
b
a
c
k
 
a
l
l
 
t
r
a
n
s
a
c
t
i
o
n
s
 
i
n
 
t
h
e
 
t
r
a
n
s
a
c
t
i
o
n
 
t
r
e
e
.
 
 
 
A
 
P
I
M
 
u
s
e
s
 
a
 
n
e
s
t
e
d
 
t
r
a
n
s
a
c
t
i
o
n
 
w
h
e
n
 
a
 
t
r
a
n
s
a
c
t
i
o
n
a
l
 
o
p
e
r
a
t
i
o
n
 
i
n
v
o
k
e
s
 
a
n
o
t
h
e
r
 
t
r
a
n
s
a
c
t
i
o
n
a
l
 
o
p
e
r
a
t
i
o
n
.
 
 
E
a
c
h
 
o
p
e
r
a
t
i
o
n
 
c
o
n
t
a
i
n
s
 
a
 
t
r
a
n
s
a
c
t
i
o
n
 
a
t
t
r
i
b
u
t
e
 
i
n
d
i
c
a
t
i
n
g
 
w
h
e
t
h
e
r
 
t
h
e
 
t
r
a
n
s
a
c
t
i
o
n
 
w
i
l
l
 
o
b
t
a
i
n
 
a
 
n
e
w
 
t
r
a
n
s
a
c
t
i
o
n
 
f
r
o
m
 
t
h
e
 
t
r
a
n
s
a
c
t
i
o
n
 
m
a
n
a
g
e
r
;
 
i
f
 
t
h
e
r
e
 
i
s
 
a
l
r
e
a
d
y
 
a
 
t
r
a
n
s
a
c
t
i
o
n
,
 
i
t
 
w
i
l
l
 
f
a
i
l
;
 
 
p
a
r
t
i
c
i
p
a
t
e
 
w
i
t
h
 
t
h
e
 
c
u
r
r
e
n
t
 
t
r
a
n
s
a
c
t
i
o
n
 
o
r
 
c
r
e
a
t
e
 
a
 
n
e
w
 
t
r
a
n
s
a
c
t
i
o
n
 
o
r
 
c
r
e
a
t
e
 
a
 
n
e
s
t
e
d
 
t
r
a
n
s
a
c
t
i
o
n
.
 
 
T
h
e
 
n
e
s
t
e
d
 
t
r
a
n
s
a
c
t
i
o
n
 
d
e
p
e
n
d
s
 
o
n
 
t
h
e
 
s
u
p
p
o
r
t
 
o
f
 
t
h
e
 
t
a
r
g
e
t
 
P
S
M
.
 
 
I
f
 
t
h
e
 
t
a
r
g
e
t
 
p
l
a
t
f
o
r
m
 
d
o
e
s
 
n
o
t
 
s
u
p
p
o
r
t
 
n
e
s
t
e
d
 
t
r
a
n
s
a
c
t
i
o
n
,
 
t
h
e
 
m
a
p
p
i
n
g
 
g
e
n
e
r
a
t
e
s
 
a
n
 
e
r
r
o
r
.
 
T
o
 
a
d
d
r
e
s
s
 
t
h
e
s
e
 
f
o
u
r
 
c
o
n
c
e
r
n
s
,
 
d
e
v
e
l
o
p
e
r
s
 
n
e
e
d
 
a
 
s
y
s
t
e
m
a
t
i
c
 
w
a
y
 
t
o
 
d
e
f
i
n
e
 
t
r
a
n
s
a
c
t
i
o
n
 
s
u
p
p
o
r
t
 
a
t
 
a
 
P
I
M
 
l
e
v
e
l
 
t
h
a
t
 
d
o
e
s
 
n
o
t
 
d
e
p
e
n
d
 
o
n
 
c
h
o
i
c
e
s
 
o
f
 
t
r
a
n
s
a
c
t
i
o
n
 
a
n
d
 
p
e
r
s
i
s
t
e
n
c
e
 
m
i
d
d
l
e
w
a
r
e
.
 
 
W
e
 
p
r
o
p
o
s
e
 
a
 
U
n
i
t
 
o
f
 
W
o
r
k
 
(
U
o
W
)
 
m
o
d
e
l
i
n
g
 
a
s
 
a
 
s
o
l
u
t
i
o
n
 
t
o
 
s
u
p
p
o
r
t
 
t
r
a
n
s
a
c
t
i
o
n
 
o
f
 
p
e
r
s
i
s
t
e
n
c
e
 
o
b
j
e
c
t
s
 
a
t
 
a
 
p
l
a
t
f
o
r
m
 
i
n
d
e
p
e
n
d
e
n
t
 
l
e
v
e
l
.
 
 
T
h
e
 
n
e
x
t
 
s
e
c
t
i
o
n
 
d
e
s
c
r
i
b
e
s
 
t
h
e
 
U
o
W
 
m
o
d
e
l
i
n
g
 
c
o
n
c
e
p
t
 
a
s
 
a
 
w
a
y
 
t
o
 
s
p
e
c
i
f
y
 
t
r
a
n
s
a
c
t
i
o
n
 
b
o
u
n
d
a
r
y
,
 
d
e
t
e
r
m
i
n
e
 
o
b
j
e
c
t
s
 
i
n
v
o
l
v
e
d
 
i
n
 
t
h
e
 
t
r
a
n
s
a
c
t
i
o
n
 
a
n
d
 
e
x
p
l
a
i
n
s
 
a
 
t
r
a
n
s
f
o
r
m
a
t
i
o
n
 
t
o
o
l
 
t
h
a
t
 
t
a
k
e
s
 
a
n
 
i
n
p
u
t
 
P
I
M
 
a
n
d
 
a
n
n
o
t
a
t
i
o
n
s
 
f
o
r
 
t
a
r
g
e
t
 
p
l
a
t
f
o
r
m
 
c
h
o
i
c
e
s
 
t
o
 
c
r
e
a
t
e
 
a
n
 
e
x
e
c
u
t
a
b
l
e
 
P
S
M
.
 
U
n
i
t
 
o
f
 
w
o
r
k
 
i
s
 
a
 
b
r
o
a
d
 
t
e
r
m
 
t
h
a
t
 
h
a
s
 
m
a
n
y
 
m
e
a
n
i
n
g
s
.
 
 
F
o
w
l
e
r
 
d
e
f
i
n
e
s
 
 
(
U
o
W
)
 
a
s
 
a
 
m
e
c
h
a
n
i
s
m
 
t
o
 
m
a
i
n
t
a
i
n
 
a
 
l
i
s
t
 
o
f
 
o
b
j
e
c
t
s
 
a
f
f
e
c
t
e
d
 
b
y
 
a
 
b
u
s
i
n
e
s
s
 
t
r
a
n
s
a
c
t
i
o
n
 
a
n
d
 
c
o
o
r
d
i
n
a
t
e
 
t
h
e
 
w
r
i
t
i
n
g
 
o
u
t
 
o
f
 
c
h
a
n
g
e
s
 
a
n
d
 
t
h
e
 
r
e
s
o
l
u
t
i
o
n
 
o
f
 
c
o
n
c
u
r
r
e
n
c
y
 
p
r
o
b
l
e
m
s
 
 
.
 
T
h
e
 
U
o
W
 
s
u
p
p
o
r
t
s
 
o
b
j
e
c
t
 
t
r
a
n
s
a
c
t
i
o
n
 
b
y
 
d
e
t
e
r
m
i
n
i
n
g
 
t
r
a
n
s
a
c
t
i
o
n
 
s
c
o
p
e
 
f
r
o
m
 
o
n
e
 
o
r
 
m
o
r
e
 
t
r
a
n
s
a
c
t
i
o
n
a
l
 
o
p
e
r
a
t
i
o
n
s
;
 
r
e
g
i
s
t
e
r
i
n
g
 
o
b
j
e
c
t
s
 
p
a
r
t
i
c
i
p
a
t
i
n
g
 
i
n
 
t
h
e
 
t
r
a
n
s
a
c
t
i
o
n
;
 
a
n
d
 
c
o
m
m
i
t
/
m
e
r
g
e
/
r
o
l
l
b
a
c
k
 
c
h
a
n
g
e
s
 
a
t
 
t
h
e
 
e
n
d
 
o
f
 
t
h
e
 
t
r
a
n
s
a
c
t
i
o
n
 
t
o
 
a
 
p
e
r
m
a
n
e
n
t
 
s
t
o
r
a
g
e
 
(
F
i
g
u
r
e
.
 
 
T
h
e
 
g
r
a
n
u
l
a
r
i
t
y
 
o
f
 
d
a
t
a
 
i
n
 
U
o
W
 
i
s
 
a
t
 
t
h
e
 
o
b
j
e
c
t
 
l
e
v
e
l
.
 
 
UnitOfWork

  7 

UnitOfWor k

[1 ]

´profileª
´profileª
UnitOfWork
UnitOfWork

´stereotype ª
´stereotype ª
UnitOfWork
UnitOfWork

 7.

´metamodelª
´metamodelª
UML
UML

Operation
Operation

transactionAttribute 

concurrencyControl

isolationLevel 

Point of consistency
Point of consistency

New point of  consistency
New point of  consistency

object accesses/updates
object accesses/updates

a  unit  of work
a  unit  of work

Begin unit of work
Begin unit of work

 5.

Commit/rollback
Commit/rollback
unit of work
unit of work

 6)

[1 9

Unit  of  Work
Unit  of  Work

commit
commit

In-memory objects
In-memory objects

Registered 
Registered 
object  snapshot 
object  snapshot 

compare
compare

 6 .

Proceedings of the 2005  Ninth IEEE International ED
 IEEE 
0-7695-2441-9/05 $20.00 © 2005

OC Enterprise Computing Conference (ED OC í05) 

T
h
e
r
e
f
o
r
e
,
 
t
h
e
 
p
e
r
s
i
s
t
e
n
c
e
 
s
t
o
r
e
 
i
s
 
n
o
t
 
l
i
m
i
t
e
d
 
t
o
 
a
 
r
e
l
a
t
i
o
n
a
l
 
d
a
t
a
b
a
s
e
.
 
 
T
h
e
 
U
o
W
 
a
l
s
o
 
s
u
p
p
o
r
t
s
 
i
n
-
m
e
m
o
r
y
,
 
d
i
s
c
o
n
n
e
c
t
e
d
 
o
b
j
e
c
t
s
.
 
A
 
p
r
o
g
r
a
m
 
c
a
n
 
r
e
a
d
 
o
b
j
e
c
t
s
 
f
r
o
m
 
a
 
d
a
t
a
b
a
s
e
 
t
o
 
m
a
i
n
 
m
e
m
o
r
y
;
 
d
e
t
a
c
h
 
t
h
e
 
i
n
-
m
e
m
o
r
y
 
o
b
j
e
c
t
s
 
f
r
o
m
 
t
h
e
 
d
a
t
a
b
a
s
e
;
 
m
a
k
e
 
c
h
a
n
g
e
s
 
t
o
 
t
h
e
 
i
n
-
m
e
m
o
r
y
 
o
b
j
e
c
t
s
;
 
a
n
d
 
f
i
n
a
l
l
y
 
r
e
c
o
n
n
e
c
t
 
a
n
d
 
s
y
n
c
h
r
o
n
i
z
e
 
t
h
e
m
 
b
a
c
k
 
t
o
 
t
h
e
 
d
a
t
a
b
a
s
e
.
 
 
A
t
 
t
h
e
 
e
n
d
 
o
f
 
t
h
e
 
t
r
a
n
s
a
c
t
i
o
n
 
s
c
o
p
e
,
 
t
h
e
 
U
o
W
 
c
o
m
m
i
t
s
 
t
h
e
 
t
r
a
n
s
a
c
t
i
o
n
 
b
y
 
v
e
r
i
f
y
i
n
g
 
a
n
d
/
o
r
 
p
r
o
v
i
d
i
n
g
 
s
y
n
c
h
r
o
n
i
z
a
t
i
o
n
 
o
f
 
o
b
j
e
c
t
s
 
i
n
 
m
e
m
o
r
y
 
a
n
d
 
t
h
o
s
e
 
i
n
 
p
e
r
s
i
s
t
e
n
c
e
 
s
t
o
r
a
g
e
.
 
 
I
t
 
w
i
l
l
 
f
a
i
l
 
i
f
 
t
h
e
 
o
b
j
e
c
t
s
 
a
r
e
 
n
o
t
 
c
o
n
s
i
s
t
e
n
t
 
a
c
c
o
r
d
i
n
g
 
t
o
 
t
h
e
 
c
o
n
c
u
r
r
e
n
c
y
 
p
o
l
i
c
y
 
a
n
d
 
t
h
e
 
t
r
a
n
s
a
c
t
i
o
n
 
w
i
l
l
 
r
o
l
l
b
a
c
k
 
t
o
 
t
h
e
 
o
r
i
g
i
n
a
l
 
s
t
a
t
e
.
 
F
i
g
u
r
e
 
A
 
U
n
i
t
 
o
f
 
W
o
r
k
 
A
 
p
r
o
g
r
a
m
 
m
u
s
t
 
u
s
e
 
a
 
d
a
t
a
b
a
s
e
 
t
r
a
n
s
a
c
t
i
o
n
 
m
a
n
a
g
e
r
 
t
o
 
s
u
p
p
o
r
t
 
i
n
-
m
e
m
o
r
y
 
d
i
s
c
o
n
n
e
c
t
e
d
 
o
b
j
e
c
t
s
.
 
 
U
o
W
 
r
e
g
i
s
t
e
r
s
 
o
b
j
e
c
t
s
 
r
e
a
d
 
f
r
o
m
 
t
h
e
 
d
a
t
a
b
a
s
e
 
a
n
d
 
k
e
e
p
 
t
r
a
c
k
 
o
f
 
t
h
e
 
o
r
i
g
i
n
a
l
 
s
t
a
t
e
s
 
o
f
 
t
h
e
 
o
b
j
e
c
t
s
 
(
F
i
g
u
r
e
 
]
.
 
 
T
h
i
s
 
c
a
n
 
b
e
 
d
o
n
e
 
b
y
 
u
s
i
n
g
 
s
n
a
p
s
h
o
t
s
,
 
t
i
m
e
s
t
a
m
p
s
 
o
r
 
v
e
r
s
i
o
n
 
n
u
m
b
e
r
s
.
 
 
I
n
-
m
e
m
o
r
y
 
o
b
j
e
c
t
s
 
c
a
n
 
b
e
c
o
m
e
 
d
i
s
c
o
n
n
e
c
t
e
d
 
f
r
o
m
 
t
h
e
 
d
a
t
a
b
a
s
e
.
 
 
C
h
a
n
g
e
s
 
t
o
 
t
h
e
 
i
n
-
m
e
m
o
r
y
 
o
b
j
e
c
t
s
 
w
i
l
l
 
n
o
t
 
b
e
 
s
e
e
n
 
f
r
o
m
 
a
n
o
t
h
e
r
 
t
r
a
n
s
a
c
t
i
o
n
,
 
t
h
u
s
 
p
r
o
v
i
d
i
n
g
 
t
r
a
n
s
a
c
t
i
o
n
 
i
s
o
l
a
t
i
o
n
.
 
 
W
h
e
n
 
t
h
e
 
t
r
a
n
s
a
c
t
i
o
n
 
c
o
m
m
i
t
s
 
a
t
 
t
h
e
 
e
n
d
 
o
f
 
t
h
e
 
U
o
W
,
 
t
h
e
 
r
e
g
i
s
t
e
r
e
d
 
o
b
j
e
c
t
s
 
a
r
e
 
r
e
a
d
 
f
r
o
m
 
t
h
e
 
d
a
t
a
b
a
s
e
 
a
g
a
i
n
 
a
n
d
 
c
o
m
p
a
r
e
d
 
w
i
t
h
 
t
h
e
 
o
r
i
g
i
n
a
l
 
s
t
a
t
e
s
.
 
 
I
f
 
t
h
e
y
 
a
r
e
 
d
i
f
f
e
r
e
n
t
,
 
i
t
 
m
e
a
n
s
 
t
h
a
t
 
a
n
 
e
a
r
l
i
e
r
 
t
r
a
n
s
a
c
t
i
o
n
 
h
a
s
 
c
h
a
n
g
e
d
 
t
h
e
 
o
b
j
e
c
t
s
 
i
n
 
t
h
e
 
d
a
t
a
b
a
s
e
 
a
n
d
 
t
h
e
 
l
a
t
e
r
 
t
r
a
n
s
a
c
t
i
o
n
 
w
i
l
l
 
f
a
i
l
.
 
 
U
o
W
 
s
u
p
p
o
r
t
s
 
t
r
a
n
s
a
c
t
i
o
n
s
 
t
h
a
t
 
s
p
a
n
 
m
u
l
t
i
p
l
e
 
w
e
b
 
r
e
q
u
e
s
t
s
 
b
y
 
s
t
o
r
i
n
g
 
t
h
e
 
U
o
W
 
t
r
a
n
s
a
c
t
i
o
n
 
m
a
n
a
g
e
r
 
i
n
 
a
 
s
e
s
s
i
o
n
 
o
r
 
a
n
 
a
p
p
l
i
c
a
t
i
o
n
 
c
o
n
t
e
x
t
.
 
F
i
g
u
r
e
 
U
n
i
t
 
o
f
 
w
o
r
k
 
k
e
e
p
s
 
t
r
a
c
k
 
o
f
 
i
n
-
m
e
m
o
r
y
 
o
b
j
e
c
t
s
 
a
n
d
 
o
r
i
g
i
n
a
l
 
o
b
j
e
c
t
s
 
r
e
a
d
 
f
r
o
m
 
d
a
t
a
b
a
s
e
 
M
D
A
 
s
u
p
p
o
r
t
s
 
t
h
e
 
u
s
e
 
o
f
 
a
n
y
 
M
O
F
-
d
e
f
i
n
e
d
 
l
a
n
g
u
a
g
e
 
t
o
 
m
o
d
e
l
 
b
o
t
h
 
P
I
M
 
a
n
d
 
P
S
M
;
 
U
M
L
 
i
s
 
o
n
e
 
o
f
 
t
h
e
 
c
o
m
m
o
n
l
y
 
u
s
e
d
.
 
 
E
x
t
e
n
d
i
n
g
 
U
M
L
 
t
o
 
s
u
p
p
o
r
t
 
n
e
w
 
m
o
d
e
l
i
n
g
 
n
o
t
a
t
i
o
n
s
 
c
a
n
 
b
e
 
d
o
n
e
 
u
s
i
n
g
 
U
M
L
 
p
r
o
f
i
l
e
s
.
 
 
A
 
U
M
L
 
p
r
o
f
i
l
e
 
c
o
n
t
a
i
n
s
 
a
 
s
e
t
 
o
f
 
s
t
e
r
e
o
t
y
p
e
s
,
 
c
o
n
s
t
r
a
i
n
t
s
 
a
n
d
 
t
a
g
 
d
e
f
i
n
i
t
i
o
n
s
 
t
h
a
t
 
e
x
t
e
n
d
 
s
e
m
a
n
t
i
c
s
 
o
f
 
U
M
L
 
e
l
e
m
e
n
t
s
.
 
 
O
u
r
 
 
i
s
 
a
 
p
r
o
f
i
l
e
 
t
h
a
t
 
s
u
p
p
o
r
t
s
 
t
r
a
n
s
a
c
t
i
o
n
s
.
 
 
M
o
d
e
l
 
d
e
s
i
g
n
e
r
s
 
c
r
e
a
t
e
 
P
I
M
s
 
u
s
i
n
g
 
c
l
a
s
s
 
m
o
d
e
l
s
;
 
m
a
r
k
 
P
I
M
s
 
u
s
i
n
g
 
s
t
e
r
e
o
t
y
p
e
s
 
f
r
o
m
 
t
h
e
 
U
n
i
t
 
o
f
 
W
o
r
k
 
p
r
o
f
i
l
e
 
a
n
d
 
a
n
n
o
t
a
t
e
 
t
h
e
 
m
a
r
k
e
d
 
P
I
M
s
 
w
i
t
h
 
t
a
g
g
e
d
 
d
e
f
i
n
i
t
i
o
n
s
 
i
n
 
s
t
e
r
e
o
t
y
p
e
 
a
t
t
r
i
b
u
t
e
s
.
 
 
F
i
g
u
r
e
s
h
o
w
s
 
t
h
a
t
 
t
h
e
 
«
U
n
i
t
O
f
W
o
r
k
»
 
s
t
e
r
e
o
t
y
p
e
 
i
s
 
d
e
f
i
n
e
d
 
i
n
 
t
h
e
 
p
r
o
f
i
l
e
 
a
n
d
 
a
p
p
l
i
e
s
 
t
o
 
t
h
e
 
U
M
L
:
:
O
p
e
r
a
t
i
o
n
.
 
 
A
 
m
o
d
e
l
e
r
 
u
s
e
s
 
«
U
n
i
t
O
f
W
o
r
k
»
 
b
y
 
a
p
p
l
y
i
n
g
 
t
h
e
 
s
t
e
r
e
o
t
y
p
e
 
t
o
 
t
h
e
 
t
r
a
n
s
a
c
t
i
o
n
a
l
 
o
p
e
r
a
t
i
o
n
s
 
o
f
 
t
h
e
 
P
I
M
.
 
 
P
e
r
s
i
s
t
e
n
t
 
o
b
j
e
c
t
s
 
i
n
v
o
l
v
e
d
 
i
n
 
t
h
e
 
t
r
a
n
s
a
c
t
i
o
n
a
l
 
o
p
e
r
a
t
i
o
n
s
 
a
r
e
 
s
p
e
c
i
f
i
e
d
 
u
s
i
n
g
 
«
E
n
t
i
t
y
»
 
f
r
o
m
 
t
h
e
 
P
e
r
s
i
s
t
e
n
c
e
 
p
r
o
f
i
l
e
 
a
s
 
d
e
s
c
r
i
b
e
d
 
i
n
 
o
u
r
 
p
r
e
v
i
o
u
s
 
p
a
p
e
r
 
 
.
 
 
S
i
n
c
e
 
t
h
e
 
U
M
L
 
u
s
e
s
 
a
 
d
e
p
e
n
d
e
n
c
y
 
r
e
l
a
t
i
o
n
s
h
i
p
 
n
o
t
a
t
i
o
n
 
t
o
 
s
p
e
c
i
f
y
 
r
e
l
a
t
i
o
n
s
h
i
p
 
b
e
t
w
e
e
n
 
m
o
d
e
l
 
e
l
e
m
e
n
t
s
,
 
i
t
 
i
s
 
p
o
s
s
i
b
l
e
 
t
o
 
a
u
t
o
m
a
t
i
c
a
l
l
y
 
f
i
n
d
 
o
u
t
 
p
e
r
s
i
s
t
e
n
t
 
o
b
j
e
c
t
s
 
i
n
v
o
l
v
e
d
 
i
n
 
a
n
y
 
t
r
a
n
s
a
c
t
i
o
n
a
l
 
o
p
e
r
a
t
i
o
n
 
b
y
 
t
r
a
v
e
r
s
i
n
g
 
t
h
e
 
d
e
p
e
n
d
e
n
c
y
 
g
r
a
p
h
 
f
r
o
m
 
t
h
e
 
t
r
a
n
s
a
c
t
i
o
n
a
l
 
o
p
e
r
a
t
i
o
n
s
 
t
o
 
p
e
r
s
i
s
t
e
n
t
 
o
b
j
e
c
t
s
 
r
e
a
c
h
a
b
l
e
 
f
r
o
m
 
t
h
e
m
.
 
 
F
i
g
u
r
e
 
«
U
n
i
t
O
f
W
o
r
k
»
 
s
t
e
r
e
o
t
y
p
e
 
a
p
p
l
i
e
s
 
t
o
 
U
M
L
:
:
O
p
e
r
a
t
i
o
n
 
 
M
o
d
e
l
e
r
s
 
a
n
n
o
t
a
t
e
 
t
h
e
 
t
r
a
n
s
a
c
t
i
o
n
 
p
r
o
p
e
r
t
i
e
s
 
o
f
 
t
h
e
 
o
p
e
r
a
t
i
o
n
 
b
y
 
s
p
e
c
i
f
y
i
n
g
 
«
U
n
i
t
O
f
W
o
r
k
»
 
s
t
e
r
e
o
t
y
p
e
 
a
t
t
r
i
b
u
t
e
s
.
 
 
D
e
f
a
u
l
t
 
a
t
t
r
i
b
u
t
e
 
v
a
l
u
e
s
 
a
r
e
 
u
n
d
e
r
l
i
n
e
d
.
 
 
T
h
e
 
i
n
d
i
c
a
t
e
s
 
w
h
e
t
h
e
r
 
t
h
e
 
o
p
e
r
a
t
i
o
n
 
m
u
s
t
 
r
e
q
u
i
r
e
 
a
 
n
e
w
 
t
r
a
n
s
a
c
t
i
o
n
 
o
r
 
j
o
i
n
 
a
n
 
e
x
i
s
t
i
n
g
 
t
r
a
n
s
a
c
t
i
o
n
.
 
 
I
f
 
t
h
e
r
e
 
i
s
 
a
l
r
e
a
d
y
 
a
 
p
r
i
o
r
 
t
r
a
n
s
a
c
t
i
o
n
,
 
a
 
n
e
w
 
t
r
a
n
s
a
c
t
i
o
n
 
w
i
l
l
 
b
e
 
n
e
s
t
e
d
.
 
 
T
h
e
 
 
i
n
d
i
c
a
t
e
s
 
w
h
e
t
h
e
r
 
t
o
 
u
s
e
 
o
p
t
i
m
i
s
t
i
c
 
o
r
 
p
e
s
s
i
m
i
s
t
i
c
 
c
o
n
c
u
r
r
e
n
c
y
 
c
o
n
t
r
o
l
.
 
 
I
f
 
i
t
 
i
s
 
o
p
t
i
m
i
s
t
i
c
,
 
a
 
m
a
p
p
i
n
g
 
t
o
o
l
 
w
i
l
l
 
g
e
n
e
r
a
t
e
 
v
e
r
s
i
o
n
i
n
g
 
s
c
h
e
m
a
 
f
o
r
 
p
e
r
s
i
s
t
e
n
t
 
o
b
j
e
c
t
s
 
r
e
a
c
h
a
b
l
e
 
f
r
o
m
 
t
h
e
 
o
p
e
r
a
t
i
o
n
.
 
 
I
f
 
i
t
 
i
s
 
p
e
s
s
i
m
i
s
t
i
c
,
 
t
h
e
 
i
d
e
n
t
i
f
i
e
s
 
t
h
e
 
d
e
g
r
e
e
 
o
f
 
c
o
n
c
u
r
r
e
n
c
y
.
 
 
I
t
 
c
a
n
 
b
e
 
r
e
a
d
 
u
n
c
o
m
m
i
t
t
e
d
,
 
r
e
a
d
 
c
o
m
m
i
t
t
e
d
,
 
r
e
p
e
a
t
a
b
l
e
 
r
e
a
d
 
o
r
 
s
e
r
i
a
l
i
z
a
b
l
e
.
 
 
 
´stereotype ª
´stereotype ª
UnitOfWork
UnitOfWork

çnew é | 
transactionAttribute = 
transactionAttribute = 
çnew é | 
ç join é
ç join é
çpessimistic
concurrencyControl  :  String  =  
çoptimistic é | 
concurrencyControl  :  String  =  
çoptimistic é | 
çpessimistic
çreadUncommitted é | 
isolationLevel  :  String =  
isolationLevel  :  String =  
çreadUncommitted é | 
çreadCommitted é | 
çreadCommitted é | 
çrepeatableRead é | 
çrepeatableRead é | 
çserializable
çserializable
é | 
é | 
çperRequest
çperRequest
çperRequestW ithDetachedObjects é | 
çperRequestW ithDetachedObjects é | 
çperApplicationTransaction é
çperApplicationTransaction é

sessionScope :  String =  
sessionScope :  String =  

sessionGroup :  String
sessionGroup :  String
çfirst é | 
sessionGroupRole:  String  = 
sessionGroupRole:  String  = 
çfirst é | 
çmiddle
çmiddle

é | 
çlasté
é | 
çlasté

 8.

sessionScope 

 2 
 3.

sessionGroup 

sessionGroupRole 

5.  Mercator transformation tool  

[20 ]

[1 ]

Proceedings of the 2005  Ninth IEEE International ED
 IEEE 
0-7695-2441-9/05 $20.00 © 2005

OC Enterprise Computing Conference (ED OC í05) 

é
é
é
é
F
i
g
u
r
e
 
«
U
n
i
t
O
f
W
o
r
k
»
 
s
t
e
r
e
o
t
y
p
e
 
a
t
t
r
i
b
u
t
e
s
 
T
h
e
i
n
d
i
c
a
t
e
s
 
t
h
e
 
b
o
u
n
d
a
r
y
 
o
f
 
t
h
e
 
t
r
a
n
s
a
c
t
i
o
n
,
 
i
f
 
t
h
e
 
s
c
o
p
e
 
i
s
 
p
e
r
 
r
e
q
u
e
s
t
,
 
t
h
e
 
t
r
a
n
s
a
c
t
i
o
n
 
l
i
v
e
s
 
o
n
l
y
 
i
n
 
a
 
l
o
c
a
l
 
s
e
s
s
i
o
n
 
t
h
r
e
a
d
.
 
 
I
f
 
t
h
e
 
s
c
o
p
e
 
i
s
 
p
e
r
 
r
e
q
u
e
s
t
 
w
i
t
h
 
d
e
t
a
c
h
e
d
 
o
b
j
e
c
t
s
,
 
t
h
e
 
p
e
r
s
i
s
t
e
n
t
 
o
b
j
e
c
t
s
 
c
a
n
 
s
p
a
n
 
m
u
l
t
i
p
l
e
 
r
e
q
u
e
s
t
s
 
b
y
 
d
e
t
a
c
h
i
n
g
 
t
h
e
m
s
e
l
v
e
s
 
f
r
o
m
 
a
 
d
a
t
a
b
a
s
e
 
c
o
n
n
e
c
t
i
o
n
 
a
n
d
 
r
e
a
t
t
a
c
h
i
n
g
 
b
a
c
k
 
i
n
 
a
 
s
u
b
s
e
q
u
e
n
t
 
s
e
s
s
i
o
n
.
 
 
T
h
i
s
 
o
p
t
i
o
n
 
i
s
 
p
o
s
s
i
b
l
e
 
o
n
l
y
 
i
n
 
a
 
P
S
M
 
t
h
a
t
 
s
u
p
p
o
r
t
s
 
d
e
t
a
c
h
e
d
 
o
b
j
e
c
t
s
.
 
 
T
h
e
 
l
a
s
t
 
s
c
o
p
e
 
i
s
 
p
e
r
 
a
p
p
l
i
c
a
t
i
o
n
 
t
r
a
n
s
a
c
t
i
o
n
 
t
h
a
t
 
u
s
e
s
 
a
n
 
a
p
p
l
i
c
a
t
i
o
n
-
l
e
v
e
l
 
c
o
n
t
e
x
t
 
t
o
 
m
a
i
n
t
a
i
n
 
o
b
j
e
c
t
 
l
i
f
e
c
y
c
l
e
.
 
 
T
h
e
i
s
 
r
e
q
u
i
r
e
d
 
i
f
 
t
h
e
 
o
p
e
r
a
t
i
o
n
 
i
s
 
p
a
r
t
 
o
f
 
t
h
e
 
u
n
i
t
 
o
f
 
w
o
r
k
 
s
e
q
u
e
n
c
e
.
 
 
T
h
e
 
s
e
s
s
i
o
n
 
g
r
o
u
p
 
i
s
 
a
 
u
n
i
q
u
e
 
n
a
m
e
 
f
o
r
 
e
a
c
h
 
u
n
i
t
 
o
f
 
w
o
r
k
 
a
n
d
 
t
h
e
 
i
n
d
i
c
a
t
e
s
 
w
h
e
t
h
e
r
 
t
h
e
 
o
p
e
r
a
t
i
o
n
 
i
s
 
t
h
e
 
f
i
r
s
t
,
 
m
i
d
d
l
e
 
o
r
 
l
a
s
t
 
s
t
e
p
 
i
n
 
t
h
e
 
s
e
q
u
e
n
c
e
.
 
 
A
 
m
a
p
p
i
n
g
 
t
o
o
l
 
u
s
e
s
 
t
h
e
 
i
n
f
o
r
m
a
t
i
o
n
 
f
r
o
m
 
t
h
e
 
s
e
s
s
i
o
n
 
g
r
o
u
p
 
r
o
l
e
 
t
o
 
g
e
n
e
r
a
t
e
 
c
o
d
e
 
t
h
a
t
 
b
e
g
i
n
s
 
o
r
 
e
n
d
s
 
a
 
t
r
a
n
s
a
c
t
i
o
n
.
 
A
f
t
e
r
 
a
 
P
I
M
 
i
s
 
m
a
r
k
e
d
 
w
i
t
h
 
t
h
e
 
u
n
i
t
 
o
f
 
w
o
r
k
 
s
t
e
r
e
o
t
y
p
e
 
a
n
d
 
a
n
n
o
t
a
t
e
d
 
w
i
t
h
 
t
r
a
n
s
a
c
t
i
o
n
 
a
t
t
r
i
b
u
t
e
s
,
 
a
 
t
r
a
n
s
f
o
r
m
a
t
i
o
n
 
f
r
o
m
 
t
h
e
 
P
I
M
 
t
o
 
a
 
P
S
M
 
i
s
 
p
e
r
f
o
r
m
e
d
 
b
y
 
a
 
m
a
p
p
i
n
g
 
t
o
o
l
 
d
e
s
c
r
i
b
e
d
 
i
n
 
t
h
e
 
n
e
x
t
 
s
e
c
t
i
o
n
.
 
M
e
r
c
a
t
o
r
 
i
s
 
a
n
 
M
D
A
 
t
r
a
n
s
f
o
r
m
a
t
i
o
n
 
t
o
o
l
 
a
n
d
 
f
r
a
m
e
w
o
r
k
 
 
.
 
 
I
t
 
i
s
 
a
 
r
e
s
e
a
r
c
h
 
t
o
o
l
 
d
e
s
i
g
n
e
d
 
t
o
 
e
x
p
l
o
r
e
 
h
o
w
 
t
o
 
s
u
p
p
o
r
t
 
c
o
m
m
o
n
 
s
e
r
v
i
c
e
 
l
i
b
r
a
r
i
e
s
 
i
n
 
p
l
a
t
f
o
r
m
 
i
n
d
e
p
e
n
d
e
n
t
 
m
o
d
e
l
s
.
 
 
I
t
 
a
v
o
i
d
s
 
c
r
e
a
t
i
n
g
 
a
 
n
e
w
 
a
c
t
i
o
n
 
l
a
n
g
u
a
g
e
 
b
y
 
u
s
i
n
g
 
J
a
v
a
 
t
o
 
s
p
e
c
i
f
y
 
m
o
d
e
l
 
b
e
h
a
v
i
o
r
s
.
 
 
I
t
 
a
l
s
o
 
u
s
e
s
 
J
a
v
a
 
a
s
 
a
n
 
i
m
p
l
e
m
e
n
t
a
t
i
o
n
 
l
a
n
g
u
a
g
e
.
 
 
T
h
e
 
f
r
a
m
e
w
o
r
k
 
a
l
l
o
w
s
 
t
r
a
n
s
f
o
r
m
a
t
i
o
n
 
d
e
v
e
l
o
p
e
r
s
 
t
o
 
d
e
f
i
n
e
 
m
i
d
d
l
e
w
a
r
e
-
i
n
d
e
p
e
n
d
e
n
t
 
c
o
m
m
o
n
 
s
e
r
v
i
c
e
 
a
s
 
U
M
L
 
p
r
o
f
i
l
e
s
 
a
n
d
 
t
o
 
d
e
v
e
l
o
p
 
m
o
d
e
l
 
m
a
p
p
i
n
g
s
 
a
s
 
a
 
s
e
t
 
o
f
 
p
l
u
g
g
a
b
l
e
 
t
r
a
n
s
f
o
r
m
e
r
s
 
t
h
a
t
 
c
o
n
v
e
r
t
 
P
I
M
s
 
t
h
a
t
 
u
s
e
 
t
h
e
s
e
 
s
e
r
v
i
c
e
s
 
i
n
t
o
 
d
i
f
f
e
r
e
n
t
 
i
m
p
l
e
m
e
n
t
a
t
i
o
n
s
.
 
 
 
M
e
r
c
a
t
o
r
 
u
s
e
s
 
s
t
e
r
e
o
t
y
p
e
s
 
t
o
 
c
o
n
t
r
o
l
 
h
o
w
 
a
n
 
i
n
p
u
t
 
m
o
d
e
l
 
i
s
 
t
r
a
n
s
f
o
r
m
e
d
.
 
 
 
I
t
 
h
a
s
 
a
 
s
e
t
 
o
f
 
t
r
a
n
s
f
o
r
m
e
r
s
 
f
o
r
 
e
a
c
h
 
s
t
e
r
e
o
t
y
p
e
.
 
 
T
h
e
r
e
 
a
r
e
 
t
w
o
 
k
i
n
d
s
 
o
f
 
t
r
a
n
s
f
o
r
m
e
r
s
;
 
a
 
n
o
d
e
 
t
r
a
n
s
f
o
r
m
e
r
 
r
e
f
i
n
e
s
 
a
 
n
o
d
e
 
t
o
 
m
a
k
e
 
i
t
 
s
u
i
t
a
b
l
e
 
f
o
r
 
t
h
e
 
o
u
t
p
u
t
;
 
a
n
d
 
a
 
t
r
e
e
 
t
r
a
n
s
f
o
r
m
e
r
 
t
h
a
t
 
m
a
k
e
s
 
a
 
c
o
p
y
 
o
f
 
t
h
e
 
i
n
p
u
t
 
t
r
e
e
 
a
n
d
 
i
t
e
r
a
t
e
s
 
o
v
e
r
 
t
h
e
 
c
o
p
y
 
t
o
 
f
i
n
d
 
s
t
e
r
e
o
t
y
p
e
s
 
t
h
a
t
 
t
r
i
g
g
e
r
 
n
e
x
t
 
t
r
a
n
s
f
o
r
m
a
t
i
o
n
s
.
 
 
W
h
e
n
 
t
h
e
 
t
r
e
e
 
i
t
e
r
a
t
o
r
 
t
r
a
n
s
f
o
r
m
e
r
 
v
i
s
i
t
s
 
a
 
«
U
n
i
t
O
f
W
o
r
k
»
 
o
p
e
r
a
t
i
o
n
,
 
i
t
 
w
i
l
l
 
l
o
o
k
 
u
p
 
t
h
e
 
s
t
e
r
e
o
t
y
p
e
 
d
e
f
a
u
l
t
 
t
r
a
n
s
f
o
r
m
e
r
 
(
o
r
 
a
 
t
r
a
n
s
f
o
r
m
e
r
 
o
v
e
r
r
i
d
d
e
n
 
f
r
o
m
 
a
p
p
l
i
c
a
t
i
o
n
 
m
o
d
e
l
e
r
s
)
 
a
n
d
 
a
c
t
i
v
a
t
e
 
i
t
.
 
 
T
h
e
 
t
r
a
n
s
f
o
r
m
e
r
 
a
n
a
l
y
z
e
s
 
t
h
e
 
d
e
p
e
n
d
e
n
c
y
 
r
e
l
a
t
i
o
n
s
h
i
p
 
o
f
 
t
h
e
 
o
p
e
r
a
t
i
o
n
 
a
n
d
 
c
o
l
l
e
c
t
s
 
o
b
j
e
c
t
s
 
i
n
v
o
l
v
e
d
 
i
n
 
t
h
e
 
u
n
i
t
 
o
f
 
w
o
r
k
.
 
 
T
h
e
 
t
r
a
n
s
f
o
r
m
e
r
 
d
e
t
e
r
m
i
n
e
s
 
o
b
j
e
c
t
s
 
p
a
r
t
i
c
i
p
a
t
i
n
g
 
i
n
 
t
h
e
 
U
o
W
 
b
y
 
c
h
e
c
k
i
n
g
 
t
h
e
 
U
M
L
 
d
e
p
e
n
d
e
n
c
y
 
r
e
l
a
t
i
o
n
s
h
i
p
 
g
r
a
p
h
 
f
r
o
m
 
t
h
e
 
U
o
W
 
o
p
e
r
a
t
i
o
n
 
a
n
d
 
o
b
t
a
i
n
i
n
g
 
p
e
r
s
i
s
t
e
n
t
 
o
b
j
e
c
t
s
 
r
e
a
c
h
a
b
l
e
 
f
r
o
m
 
t
h
e
 
g
r
a
p
h
.
 
 
P
e
r
s
i
s
t
e
n
t
 
o
b
j
e
c
t
s
 
m
a
y
 
b
e
 
r
e
a
c
h
a
b
l
e
 
d
i
r
e
c
t
l
y
 
f
r
o
m
 
t
h
e
 
o
p
e
r
a
t
i
o
n
 
o
r
 
c
a
n
 
b
e
 
r
e
a
c
h
a
b
l
e
 
v
i
a
 
D
A
O
 
a
s
 
i
s
 
t
h
e
 
c
a
s
e
 
i
n
 
L
i
s
t
i
n
g
a
n
d
 
 
P
e
r
s
i
s
t
e
n
t
 
o
b
j
e
c
t
s
 
a
r
e
 
m
a
r
k
e
d
 
u
s
i
n
g
 
o
n
e
 
o
f
 
t
h
e
 
t
w
o
 
p
e
r
s
i
s
t
e
n
c
e
 
s
t
e
r
e
o
t
y
p
e
s
 
i
n
 
t
h
e
 
P
e
r
s
i
s
t
e
n
c
e
 
p
r
o
f
i
l
e
;
 
a
 
«
P
e
r
s
i
s
t
e
n
c
e
:
:
E
n
t
i
t
y
»
 
s
t
e
r
e
o
t
y
p
e
 
i
s
 
f
o
r
 
o
b
j
e
c
t
s
 
t
h
a
t
 
r
e
q
u
i
r
e
 
p
e
r
s
i
s
t
e
n
c
e
 
a
n
d
 
t
r
a
n
s
a
c
t
i
o
n
 
s
u
p
p
o
r
t
 
w
h
i
l
e
 
a
 
«
P
e
r
s
i
s
t
e
n
c
e
:
:
P
e
r
s
i
s
t
e
n
c
e
»
 
s
t
e
r
e
o
t
y
p
e
 
i
s
 
f
o
r
 
t
h
o
s
e
 
t
h
a
t
 
o
n
l
y
 
r
e
q
u
i
r
e
 
p
e
r
s
i
s
t
e
n
c
e
 
s
u
p
p
o
r
t
.
 
 
S
i
n
c
e
 
t
h
i
s
 
p
a
p
e
r
 
d
o
e
s
 
n
o
t
 
f
o
c
u
s
 
o
n
 
t
h
e
 
p
e
r
s
i
s
t
e
n
c
e
 
s
e
r
v
i
c
e
,
 
w
e
 
a
r
e
 
o
n
l
y
 
c
o
n
c
e
r
n
e
d
 
w
i
t
h
 
t
h
e
 
«
P
e
r
s
i
s
t
e
n
c
e
:
:
E
n
t
i
t
y
»
 
o
b
j
e
c
t
s
 
a
n
d
 
r
e
f
e
r
 
t
o
 
t
h
e
 
d
e
t
a
i
l
s
 
o
f
 
b
u
s
i
n
e
s
s
 
o
b
j
e
c
t
 
i
d
e
n
t
i
f
i
c
a
t
i
o
n
,
 
p
l
a
t
f
o
r
m
 
i
n
d
e
p
e
n
d
e
n
t
 
p
e
r
s
i
s
t
e
n
c
e
 
s
e
r
v
i
c
e
 
A
P
I
s
 
a
n
d
 
t
h
e
 
p
e
r
s
i
s
t
e
n
c
e
 
t
r
a
n
s
f
o
r
m
a
t
i
o
n
 
i
n
 
o
u
r
 
p
r
e
v
i
o
u
s
 
p
a
p
e
r
 
 
.
 
 
 
F
o
r
 
e
a
c
h
 
p
e
r
s
i
s
t
e
n
t
 
o
b
j
e
c
t
,
 
t
h
e
 
t
r
a
n
s
f
o
r
m
e
r
 
w
i
l
l
 
c
h
e
c
k
 
t
h
e
 
d
a
t
a
 
s
o
u
r
c
e
 
f
r
o
m
 
t
h
e
 
a
n
n
o
t
a
t
i
o
n
.
 
 
I
f
 
o
b
j
e
c
t
s
 
i
n
v
o
l
v
e
d
 
i
n
 
t
h
e
 
s
a
m
e
 
u
n
i
t
 
o
f
 
w
o
r
k
 
a
r
e
 
d
e
f
i
n
e
d
 
i
n
 
t
h
e
 
s
a
m
e
 
d
a
t
a
b
a
s
e
,
 
t
h
e
 
u
n
i
t
 
o
f
 
w
o
r
k
 
o
p
e
r
a
t
i
o
n
 
u
s
e
s
 
t
h
e
 
d
a
t
a
b
a
s
e
 
t
r
a
n
s
a
c
t
i
o
n
 
m
a
n
a
g
e
r
 
o
b
t
a
i
n
e
d
 
f
r
o
m
 
t
h
e
 
d
a
t
a
b
a
s
e
 
c
o
n
n
e
c
t
i
o
n
.
 
 
I
f
 
p
e
r
s
i
s
t
e
n
t
 
o
b
j
e
c
t
s
 
a
r
e
 
d
e
f
i
n
e
d
 
i
n
 
a
 
c
o
n
t
a
i
n
e
r
 
m
a
n
a
g
e
d
 
e
n
v
i
r
o
n
m
e
n
t
,
 
t
h
e
 
u
n
i
t
 
o
f
 
w
o
r
k
 
u
s
e
s
 
t
h
e
 
c
o
n
t
a
i
n
e
r
 
m
a
n
a
g
e
d
 
t
r
a
n
s
a
c
t
i
o
n
.
 
 
I
f
 
t
h
e
y
 
a
r
e
 
f
r
o
m
 
d
i
f
f
e
r
e
n
t
 
d
a
t
a
 
s
o
u
r
c
e
s
 
o
r
 
m
a
n
a
g
e
d
 
c
o
n
t
a
i
n
e
r
s
,
 
t
h
e
 
u
n
i
t
 
o
f
 
w
o
r
k
 
u
s
e
s
 
a
 
d
i
s
t
r
i
b
u
t
e
d
 
t
r
a
n
s
a
c
t
i
o
n
 
m
a
n
a
g
e
r
 
t
h
a
t
 
s
u
p
p
o
r
t
s
 
t
w
o
-
p
h
a
s
e
 
c
o
m
m
i
t
.
 
 
I
n
 
J
a
v
a
,
 
a
 
d
i
s
t
r
i
b
u
t
e
d
 
t
r
a
n
s
a
c
t
i
o
n
 
m
a
n
a
g
e
r
 
i
s
 
i
m
p
l
e
m
e
n
t
e
d
 
b
y
 
J
a
v
a
 
T
r
a
n
s
a
c
t
i
o
n
 
A
P
I
 
(
J
T
A
)
 
w
i
t
h
 
d
a
t
a
 
s
o
u
r
c
e
 
t
h
a
t
 
s
u
p
p
o
r
t
s
 
e
x
t
e
n
d
e
d
 
a
r
c
h
i
t
e
c
t
u
r
e
 
(
X
A
)
.
 
 
I
f
 
t
h
e
 
t
a
r
g
e
t
 
m
o
d
e
l
 
r
e
q
u
i
r
e
d
 
a
 
d
i
s
t
r
i
b
u
t
e
d
 
t
r
a
n
s
a
c
t
i
o
n
 
m
a
n
a
g
e
r
 
b
u
t
 
t
h
e
 
d
a
t
a
 
s
o
u
r
c
e
 
d
o
e
s
 
n
o
t
 
s
u
p
p
o
r
t
 
X
A
,
 
t
h
e
 
P
I
M
-
t
o
-
P
S
M
 
t
r
a
n
s
l
a
t
i
o
n
 
 
r
a
i
s
e
s
 
a
 
t
r
a
n
s
f
o
r
m
a
t
i
o
n
 
e
r
r
o
r
.
 
 
 
T
h
e
 
i
s
o
l
a
t
i
o
n
 
l
e
v
e
l
 
a
t
t
r
i
b
u
t
e
 
i
n
 
t
h
e
 
«
U
n
i
t
O
f
W
o
r
k
»
 
 
 
i
s
 
u
s
e
d
 
t
o
 
d
e
f
i
n
e
 
t
r
a
n
s
a
c
t
i
o
n
 
p
r
o
p
e
r
t
y
 
f
o
r
 
t
h
e
 
u
n
i
t
 
o
f
 
w
o
r
k
 
o
p
e
r
a
t
i
o
n
.
 
 
T
h
e
 
U
n
i
t
O
f
W
o
r
k
T
r
a
n
s
f
o
r
m
e
r
 
a
s
s
i
g
n
s
 
t
h
e
 
t
r
a
n
s
a
c
t
i
o
n
 
s
c
o
p
e
 
i
n
 
a
 
d
e
p
l
o
y
m
e
n
t
 
d
e
s
c
r
i
p
t
o
r
 
f
i
l
e
 
(
a
s
 
  1)

[22 ]

[21 ]

J2S
  5.0 

6.  Case  study  

J2E

insertOrder 

PetStore
PetStore

- orderDao : OrderDao
- orderDao : OrderDao
- itemDao :  ItemDao
- itemDao :  ItemDao

´UnitOfWork ª
´UnitOfWork ª

+insertOrder(Order order ):void
+insertOrder(Order order ):void

´DAO ª
´DAO ª
OrderDao
OrderDao

´DAO ª
´DAO ª
ItemDao
ItemDao

´Entityª
´Entityª
Order
Order

´Entityª
´Entityª
Item
Item

  3 

1.

n1.

  4 

annotation1.xml  
<Annotation id=
ŽclassŽ
 <property name =
>     

dataSource1

> 

org.apache.commons.dbcp.BasicDataSource 
 <
/property > 
 <property name =
"driverClassName "
> 
org.hsqldb.jdbcDriver  
 <
/property > 
 <property name =
"url"
> 
jdbc:hsqldb:hsql://localhost:9002
 <
/property > 

  <property 
/property > 
"username "
name=
>sa <
  <property name=
"password"
/property > 
/Annotation > 
<Annotation id =
Žclass Ž
  <property name=
>     

dataSource2

org.apache.commons.dbcp. BasicDataSource 
  <
/property> 
  <property name=
"dri verClassName"
> 
sun.jdbc.odbc.JdbcOdbcDriver 
  <
/property> 
  <property name=
"url "
> 
jdbc:odbc:myDSN
  <
/property> 
  ƒ 
/Annotation > 

 4.

´Entityª
´Entityª
dataSource = 
dataSource = 
çdataSource1é
çdataSource1é

´Entityª
´Entityª
dataSource = 
dataSource = 
çdataSource1é
çdataSource1é

´Entityª
´Entityª
dataSource = 
dataSource = 
çdataSource1é
çdataSource1é

´Entityª
´Entityª
dataSource = 
dataSource = 

aSo urce 2
aSo urce 2

 10.

 11.

´Entityª
´Entityª
Order
Order

´Entityª
´Entityª
Item
Item

 10.

´Entityª
´Entityª
Order
Order

´Entityª
´Entityª
Item
Item

 11.

insertOrder 

 10)
11)

Proceedings of the 2005  Ninth IEEE International ED
 IEEE 
0-7695-2441-9/05 $20.00 © 2005

OC Enterprise Computing Conference (ED OC í05) 

i
n
 
t
h
e
 
J
T
A
U
n
i
t
O
f
W
o
r
k
T
r
a
n
s
f
o
r
m
e
r
)
 
o
r
 
a
 
c
o
n
f
i
g
u
r
a
t
i
o
n
 
f
i
l
e
 
(
a
s
 
i
n
 
t
h
e
 
H
i
b
e
r
n
a
t
e
U
n
i
t
O
f
W
o
r
k
T
r
a
n
s
f
o
r
m
e
r
)
.
 
 
I
t
 
i
s
 
p
o
s
s
i
b
l
e
 
t
o
 
c
r
e
a
t
e
 
o
t
h
e
r
 
t
r
a
n
s
f
o
r
m
e
r
 
s
u
b
c
l
a
s
s
e
s
 
t
o
 
d
e
f
i
n
e
 
t
h
e
 
t
r
a
n
s
a
c
t
i
o
n
 
s
c
o
p
e
 
a
s
 
c
o
m
m
e
n
t
 
a
t
t
r
i
b
u
t
e
s
 
(
L
i
s
t
i
n
g
 
u
s
e
d
 
i
n
 
X
D
o
c
l
e
t
 
 
o
r
 
a
s
 
J
a
v
a
 
a
n
n
o
t
a
t
i
o
n
 
i
n
 
E
 
.
 
 
T
h
e
 
U
n
i
t
O
f
W
o
r
k
T
r
a
n
s
f
o
r
m
e
r
 
w
i
l
l
 
c
r
e
a
t
e
 
w
a
r
n
i
n
g
s
 
i
f
 
t
h
e
r
e
 
a
r
e
 
«
P
e
r
s
i
s
t
e
n
c
e
:
:
P
e
r
s
i
s
t
e
n
c
e
»
 
o
b
j
e
c
t
s
 
i
n
 
t
h
e
 
«
U
n
i
t
O
f
W
o
r
k
»
 
o
p
e
r
a
t
i
o
n
.
 
 
S
i
n
c
e
 
«
P
e
r
s
i
s
t
e
n
c
e
»
 
o
b
j
e
c
t
s
 
d
o
 
n
o
t
 
p
a
r
t
i
c
i
p
a
t
e
 
i
n
 
t
r
a
n
s
a
c
t
i
o
n
,
 
t
h
i
s
 
m
a
y
 
b
e
 
d
e
s
i
r
a
b
l
e
 
b
u
t
 
t
h
e
 
w
a
r
n
i
n
g
s
 
w
i
l
l
 
a
t
 
l
e
a
s
t
 
r
a
i
s
e
 
i
s
s
u
e
s
 
w
h
e
t
h
e
r
 
t
h
e
 
«
P
e
r
s
i
s
t
e
n
c
e
:
:
P
e
r
s
i
s
t
e
n
c
e
»
 
o
b
j
e
c
t
s
 
s
h
o
u
l
d
 
b
e
 
p
r
o
m
o
t
e
d
 
t
o
 
«
P
e
r
s
i
s
t
e
n
c
e
:
:
E
n
t
i
t
y
»
 
e
n
t
i
t
i
e
s
.
 
W
e
 
w
i
l
l
 
u
s
e
 
t
h
e
 
e
-
c
o
m
m
e
r
c
e
 
o
r
d
e
r
 
s
y
s
t
e
m
 
i
n
 
t
h
e
 
m
o
t
i
v
a
t
i
n
g
 
s
e
c
t
i
o
n
 
a
s
 
o
u
r
 
c
a
s
e
 
s
t
u
d
y
.
 
 
W
e
 
d
e
v
e
l
o
p
e
d
 
t
w
o
 
t
r
a
n
s
f
o
r
m
e
r
s
 
f
o
r
 
U
o
W
;
 
o
n
e
 
f
o
r
 
H
i
b
e
r
n
a
t
e
 
(
H
i
b
e
r
n
a
t
e
U
n
i
t
O
f
W
o
r
k
T
r
a
n
s
f
o
r
m
e
r
)
 
a
n
d
 
t
h
e
 
o
t
h
e
r
 
f
o
r
 
E
 
(
J
T
A
U
n
i
t
O
f
W
o
r
k
T
r
a
n
s
f
o
r
m
e
r
)
.
 
 
F
i
g
u
r
e
 
9
 
s
h
o
w
s
 
a
 
p
a
r
t
i
a
l
 
P
I
M
 
o
f
 
t
h
e
 
J
P
e
t
S
t
o
r
e
 
s
a
m
p
l
e
 
a
p
p
l
i
c
a
t
i
o
n
.
 
 
T
h
e
 
m
e
t
h
o
d
 
u
p
d
a
t
e
s
 
t
h
e
 
O
r
d
e
r
 
a
n
d
 
I
t
e
m
 
o
b
j
e
c
t
s
 
v
i
a
 
O
r
d
e
r
D
a
o
 
a
n
d
 
I
t
e
m
D
a
o
 
r
e
s
p
e
c
t
i
v
e
l
y
.
 
 
T
h
e
 
u
p
d
a
t
e
s
 
m
u
s
t
 
b
e
 
a
t
o
m
i
c
 
s
o
 
t
h
e
 
m
o
d
e
l
e
r
 
m
a
r
k
s
 
t
h
e
 
m
e
t
h
o
d
 
w
i
t
h
 
t
h
e
 
«
U
n
i
t
O
f
W
o
r
k
»
 
s
t
e
r
e
o
t
y
p
e
.
 
 
I
t
e
m
 
a
n
d
 
O
r
d
e
r
 
a
r
e
 
t
r
a
n
s
a
c
t
i
o
n
a
l
 
p
e
r
s
i
s
t
e
n
c
e
 
o
b
j
e
c
t
s
 
a
n
d
 
a
r
e
 
m
a
r
k
e
d
 
w
i
t
h
 
«
E
n
t
i
t
y
»
.
 
 
 
F
i
g
u
r
e
 
9
.
 
t
h
e
 
J
P
e
t
S
t
o
r
e
 
P
I
M
 
W
e
 
w
i
l
l
 
a
d
d
r
e
s
s
 
t
h
e
 
f
o
u
r
 
i
s
s
u
e
s
 
i
n
 
S
e
c
t
i
o
n
a
s
 
f
o
l
l
o
w
s
:
 
L
o
c
a
l
/
G
l
o
b
a
l
 
t
r
a
n
s
a
c
t
i
o
n
 
b
o
u
n
d
a
r
y
.
 
 
T
h
e
 
m
o
d
e
l
e
r
 
i
n
d
i
c
a
t
e
s
 
t
h
e
 
d
a
t
a
 
s
o
u
r
c
e
s
 
o
f
 
t
h
e
 
O
r
d
e
r
 
a
n
d
 
I
t
e
m
 
i
n
 
t
h
e
 
s
t
e
r
e
o
t
y
p
e
 
a
t
t
r
i
b
u
t
e
 
o
f
 
«
E
n
t
i
t
y
»
.
 
 
T
h
e
 
a
n
n
o
t
a
t
i
o
x
m
l
 
i
n
 
L
i
s
t
i
n
g
b
e
l
o
w
 
d
e
f
i
n
e
s
 
t
w
o
 
d
a
t
a
 
s
o
u
r
c
e
s
.
 
"
"
>
<
<
"
"
>
<
L
i
s
t
i
n
g
 
D
a
t
a
S
o
u
r
c
e
 
d
e
f
i
n
i
t
i
o
n
 
 
N
e
x
t
,
 
t
h
e
 
m
o
d
e
l
e
r
 
s
p
e
c
i
f
i
e
s
 
t
h
e
 
d
a
t
a
 
s
o
u
r
c
e
s
 
f
o
r
 
t
h
e
 
O
r
d
e
r
 
a
n
d
 
I
t
e
m
.
 
 
I
f
 
b
o
t
h
 
O
r
d
e
r
 
a
n
d
 
I
t
e
m
 
a
r
e
 
s
t
o
r
e
d
 
i
n
 
t
h
e
 
s
a
m
e
 
d
a
t
a
b
a
s
e
,
 
t
h
e
 
d
a
t
a
 
s
o
u
r
c
e
 
a
n
n
o
t
a
t
i
o
n
 
o
f
 
e
a
c
h
 
e
n
t
i
t
y
 
w
i
l
l
 
b
e
 
t
h
e
 
s
a
m
e
 
a
s
 
i
n
 
F
i
g
u
r
e
 
F
i
g
u
r
e
 
O
r
d
e
r
 
a
n
d
 
I
t
e
m
 
a
r
e
 
s
t
o
r
e
d
 
i
n
 
t
h
e
 
s
a
m
e
 
d
a
t
a
 
s
o
u
r
c
e
.
 
O
n
 
t
h
e
 
o
t
h
e
r
 
h
a
n
d
,
 
i
f
 
t
h
e
 
I
t
e
m
 
d
a
t
a
 
i
s
 
s
t
o
r
e
d
 
i
n
 
a
n
o
t
h
e
r
 
d
a
t
a
b
a
s
e
,
 
t
h
e
 
d
a
t
a
 
s
o
u
r
c
e
 
a
n
n
o
t
a
t
i
o
n
 
i
s
 
m
o
d
i
f
i
e
d
 
a
s
 
i
n
 
F
i
g
u
r
e
 
 
ç
d
a
t
é
ç
d
a
t
é
F
i
g
u
r
e
 
O
r
d
e
r
 
a
n
d
 
I
t
e
m
 
a
r
e
 
s
t
o
r
e
d
 
i
n
 
d
i
f
f
e
r
e
n
t
 
d
a
t
a
 
s
o
u
r
c
e
s
 
D
u
r
i
n
g
 
t
h
e
 
m
a
p
p
i
n
g
,
 
M
e
r
c
a
t
o
r
 
f
i
n
d
s
 
O
r
d
e
r
 
a
n
d
 
I
t
e
m
 
f
r
o
m
 
t
h
e
 
d
e
p
e
n
d
e
n
c
y
 
g
r
a
p
h
 
r
e
a
c
h
a
b
l
e
 
f
r
o
m
 
t
h
e
 
m
e
t
h
o
d
 
v
i
a
 
O
r
d
e
r
D
a
o
 
a
n
d
 
I
t
e
m
D
a
o
 
r
e
s
p
e
c
t
i
v
e
l
y
 
(
F
i
g
u
r
e
 
9
)
.
 
 
I
t
 
o
b
t
a
i
n
s
 
t
h
e
i
r
 
d
a
t
a
 
s
o
u
r
c
e
 
n
a
m
e
s
 
f
r
o
m
 
t
h
e
 
a
n
n
o
t
a
t
i
o
n
 
t
o
 
d
e
t
e
r
m
i
n
e
 
w
h
e
t
h
e
r
 
t
h
e
 
t
r
a
n
s
a
c
t
i
o
n
 
s
h
o
u
l
d
 
b
e
 
l
o
c
a
l
 
(
F
i
g
u
r
e
 
o
r
 
g
l
o
b
a
l
 
(
F
i
g
u
r
e
 
.
2.

 12 )

3.

4.

 5)

PetStore
PetStore

- orderDao : OrderDao
- orderDao : OrderDao
- itemDao : ItemDao
- itemDao : ItemDao

´UnitOfWork ª
´UnitOfWork ª

+insertOrder(Order order ):void
+insertOrder(Order order ):void

´UnitOfW ork ª
´UnitOfW ork ª
´UnitOfW ork ª
isolationLevel = 
isolationLevel = 
isolationLevel = 
çreadCommittedé
çreadCommittedé
çreadCommittedé
çperRequesté
sessionScope = 
sessionScope = 
sessionScope = 
çperRequesté
çperRequesté
transactionAttribute = 
transactionAttribute = 
transactionAttribute = 
çnewé
çnewé
çnewé
 12 .

[23 ]

e2  

annotation 1.xml 

hibernate

ŽentityŽ
<Annotation id=
> 
 <mapping choice=
/Annotation > 
<Annotation id=
Žtransaction Ž
> 
 <mapping 
choice=
hibernateTransaction
/Annotation > 
 5.

> 

> 

PetStore.xmi 

annotation1.xml

insertOrder 

  10)
 6 

insertOrder 

session 

sessionFactory 

public void insertOrder(Order order ) 
throws DAOException  { 
  try  { 
   session = 
sessionFactory.openSession(
; 
   session.beginTransaction (
; 
   orderDao.insertOrder(order )
; 
   itemDao.updateQuantity (order )
; 
   session.commitTransaction(
; 
  } catch  (Exception e )  { 
   session.rollback(
; 
   throw new DAOException (e.toString(
; 
  } finally  { 
; 
   session.flush (
   session.close (
; 
  } 

 6.

insertOrder 

J2E
n1.
n2.

7.

 11 .

J2E

annotation2.xml: 

<Annotation id =
ŽtransactionŽ
> 
  <mapping choice =
/Annotation> 
 7 .
J2E

j2ee _jta

> 

context 
  8 
J2E
insertOrder 

public void insertOrder(Order order )  
  throw DAOException { 
UserTransaction ut = 
context.getUserTransaction(
; 
  try  { 

Proceedings of the 2005  Ninth IEEE International ED
 IEEE 
0-7695-2441-9/05 $20.00 © 2005

OC Enterprise Computing Conference (ED OC í05) 

 
C
o
n
c
u
r
r
e
n
c
y
 
C
o
n
t
r
o
l
.
 
 
A
 
s
e
r
i
a
l
i
z
a
b
l
e
 
i
s
o
l
a
t
i
o
n
 
l
e
v
e
l
 
e
n
s
u
r
e
s
 
t
h
a
t
 
t
h
e
 
u
p
d
a
t
e
s
 
i
n
 
t
h
e
 
m
e
t
h
o
d
 
c
a
n
 
b
e
 
c
a
l
l
e
d
 
s
i
m
u
l
t
a
n
e
o
u
s
l
y
 
b
y
 
d
i
f
f
e
r
e
n
t
 
c
u
s
t
o
m
e
r
s
.
 
 
H
o
w
e
v
e
r
,
 
t
h
e
 
i
s
o
l
a
t
i
o
n
 
l
e
v
e
l
 
c
a
n
 
b
e
 
r
e
l
a
x
e
d
 
s
i
n
c
e
 
t
h
e
r
e
 
i
s
 
n
o
 
s
e
c
o
n
d
 
r
e
a
d
 
i
n
 
t
h
e
 
t
r
a
n
s
a
c
t
i
o
n
;
 
t
h
e
 
u
n
r
e
p
e
a
t
a
b
l
e
 
a
n
d
 
p
h
a
n
t
o
m
 
r
e
a
d
s
 
a
r
e
 
n
o
t
 
p
o
s
s
i
b
l
e
.
 
 
T
h
e
r
e
f
o
r
e
 
t
h
e
 
m
e
t
h
o
d
 
i
s
o
l
a
t
i
o
n
 
l
e
v
e
l
 
i
s
 
s
e
t
 
t
o
 
r
e
a
d
C
o
m
m
i
t
e
d
 
(
S
e
e
 
F
i
g
u
r
e
.
 
 
T
r
a
n
s
a
c
t
i
o
n
 
G
r
a
n
u
l
a
r
i
t
y
.
 
 
S
i
n
c
e
 
t
h
e
 
t
r
a
n
s
a
c
t
i
o
n
 
c
o
v
e
r
s
 
o
n
l
y
 
o
n
e
 
m
e
t
h
o
d
 
i
n
v
o
c
a
t
i
o
n
,
 
i
t
s
 
g
r
a
n
u
l
a
r
i
t
y
 
i
s
 
s
p
e
c
i
f
i
e
d
 
i
n
 
t
h
e
 
s
e
s
s
i
o
n
 
s
c
o
p
e
 
a
s
 
p
e
r
R
e
q
u
e
s
t
.
 
 
T
h
e
 
s
e
s
s
i
o
n
 
s
t
e
p
 
i
s
 
o
m
i
t
t
e
d
 
s
i
n
c
e
 
t
h
e
 
t
r
a
n
s
a
c
t
i
o
n
 
d
o
e
s
 
n
o
t
 
s
p
a
n
 
m
u
l
t
i
p
l
e
 
m
e
t
h
o
d
s
.
 
F
i
g
u
r
e
 
U
n
i
t
O
f
W
o
r
k
 
a
t
t
r
i
b
u
t
e
s
 
 
N
e
s
t
e
d
 
T
r
a
n
s
a
c
t
i
o
n
.
 
 
T
h
i
s
 
m
e
t
h
o
d
 
i
s
 
n
o
t
 
p
a
r
t
 
o
f
 
a
n
o
t
h
e
r
 
t
r
a
n
s
a
c
t
i
o
n
 
o
r
 
c
o
n
t
a
i
n
s
 
n
e
s
t
e
d
 
t
r
a
n
s
a
c
t
i
o
n
.
 
 
T
h
e
r
e
f
o
r
e
 
t
h
e
 
t
r
a
n
s
a
c
t
i
o
n
 
a
t
t
r
i
b
u
t
e
 
i
s
 
s
e
t
 
a
s
 
n
e
w
.
 
 
 
A
f
t
e
r
 
t
h
e
 
m
o
d
e
l
e
r
 
f
i
n
i
s
h
e
s
 
m
a
r
k
i
n
g
 
a
n
d
 
a
n
n
o
t
a
t
i
n
g
 
t
h
e
 
P
I
M
,
 
h
e
 
n
e
e
d
s
 
t
o
 
s
p
e
c
i
f
y
 
a
 
m
o
d
e
l
-
w
i
d
e
 
m
a
p
p
i
n
g
 
c
h
o
i
c
e
 
f
o
r
 
m
a
p
p
i
n
g
 
p
r
o
c
e
s
s
.
 
 
T
h
e
 
f
i
r
s
t
 
i
m
p
l
e
m
e
n
t
a
t
i
o
n
 
u
s
e
s
 
H
i
b
e
r
n
a
t
e
 
p
e
r
s
i
s
t
e
n
c
e
 
t
e
c
h
n
o
l
o
g
y
 
 
H
i
b
e
r
n
a
t
R
e
f
e
r
e
n
c
e
]
.
 
 
H
e
 
s
p
e
c
i
f
i
e
s
 
t
h
e
 
c
h
o
i
c
e
 
w
i
t
h
 
a
n
n
o
t
a
t
i
o
n
s
 
(
L
i
s
t
i
n
g
.
 
ƒ
Ž
Ž
/
<
Ž
Ž
/
<
L
i
s
t
i
n
g
 
A
d
d
 
m
a
p
p
i
n
g
 
c
h
o
i
c
e
s
 
f
o
r
 
e
n
t
i
t
y
 
a
n
d
 
t
r
a
n
s
a
c
t
i
o
n
.
 
T
o
 
t
r
a
n
s
f
o
r
m
 
t
h
e
 
P
I
M
,
 
t
h
e
 
m
o
d
e
l
e
r
 
c
h
o
o
s
e
s
 
t
h
e
 
J
a
s
 
t
h
e
 
i
n
p
u
t
 
P
I
M
 
a
n
d
 
t
h
e
 
a
s
 
t
h
e
 
a
n
n
o
t
a
t
i
o
n
 
f
i
l
e
 
a
n
d
 
r
u
n
 
t
h
e
 
M
e
r
c
a
t
o
r
 
t
o
o
l
.
 
S
u
p
p
o
s
e
 
t
h
e
 
p
r
o
g
r
a
m
 
u
s
e
s
 
t
h
e
 
s
a
m
e
 
d
a
t
a
 
s
o
u
r
c
e
 
f
o
r
 
b
o
t
h
 
O
r
d
e
r
 
a
n
d
 
I
t
e
m
 
(
F
i
g
u
r
e
,
 
t
h
e
 
H
i
b
e
r
n
a
t
e
 
U
o
W
 
t
r
a
n
s
f
o
r
m
e
r
 
u
s
e
s
 
l
o
c
a
l
 
U
o
W
 
m
a
p
p
i
n
g
.
 
 
L
i
s
t
i
n
g
s
h
o
w
s
 
t
h
e
 
g
e
n
e
r
a
t
e
d
 
f
r
o
m
 
H
i
b
e
r
n
a
t
e
 
p
e
r
s
i
s
t
e
n
c
e
 
a
n
d
 
t
r
a
n
s
a
c
t
i
o
n
.
 
 
T
h
e
 
H
i
b
e
r
n
a
t
e
 
t
r
a
n
s
f
o
r
m
e
r
 
c
r
e
a
t
e
s
 
a
 
l
o
c
a
l
 
t
r
a
n
s
a
c
t
i
o
n
 
f
r
o
m
 
t
w
o
 
g
e
n
e
r
a
t
e
d
 
a
n
d
 
f
i
e
l
d
s
.
 
 
 
 
)
)
)
)
)
)
)
)
}
L
i
s
t
i
n
g
 
T
h
e
 
i
n
 
a
 
l
o
c
a
l
 
t
r
a
n
s
a
c
t
i
o
n
 
u
s
i
n
g
 
H
i
b
e
r
n
a
t
e
 
T
h
e
 
s
a
m
e
 
P
I
M
 
c
a
n
 
b
e
 
g
e
n
e
r
a
t
e
d
 
i
n
t
o
 
a
 
d
i
f
f
e
r
e
n
t
 
i
m
p
l
e
m
e
n
t
a
t
i
o
n
.
 
 
F
o
r
 
e
x
a
m
p
l
e
,
 
t
o
 
c
h
a
n
g
e
 
f
r
o
m
 
a
 
h
i
b
e
r
n
a
t
e
 
t
r
a
n
s
a
c
t
i
o
n
 
t
o
 
E
 
J
T
A
,
 
t
h
e
 
m
o
d
e
l
e
r
 
c
o
p
i
e
s
 
t
h
e
 
a
n
n
o
t
a
t
i
o
x
m
l
 
t
o
 
a
n
n
o
t
a
t
i
o
x
m
l
 
a
n
d
 
c
h
a
n
g
e
s
 
t
h
e
 
m
a
p
p
i
n
g
 
c
h
o
i
c
e
s
 
f
o
r
 
t
h
e
 
t
r
a
n
s
a
c
t
i
o
n
 
a
s
 
s
h
o
w
n
 
i
n
 
L
i
s
t
i
n
g
 
 
 
I
n
 
t
h
i
s
 
c
a
s
e
,
 
h
e
 
u
s
e
s
 
t
h
e
 
E
 
J
T
A
 
a
s
 
t
h
e
 
i
m
p
l
e
m
e
n
t
a
t
i
o
n
 
t
a
r
g
e
t
 
f
o
r
 
t
r
a
n
s
a
c
t
i
o
n
.
 
 
T
o
 
s
h
o
w
 
t
h
e
 
d
i
s
t
r
i
b
u
t
e
d
 
t
r
a
n
s
a
c
t
i
o
n
 
s
u
p
p
o
r
t
,
 
t
h
e
 
m
o
d
e
l
e
r
 
a
n
n
o
t
a
t
e
s
 
t
h
e
 
m
o
d
e
l
 
a
s
 
s
h
o
w
n
 
i
n
 
F
i
g
u
r
e
 
 
 
ƒ
Ž
Ž
/
<
L
i
s
t
i
n
g
 
U
s
e
 
E
 
t
o
 
i
m
p
l
e
m
e
n
t
 
p
e
r
s
i
s
t
e
n
c
e
 
a
n
d
 
t
r
a
n
s
a
c
t
i
o
n
 
S
i
n
c
e
 
t
h
e
 
d
a
t
a
 
s
o
u
r
c
e
s
 
f
o
r
 
O
r
d
e
r
 
a
n
d
 
I
t
e
m
 
a
r
e
 
d
i
f
f
e
r
e
n
t
,
 
t
h
e
 
J
T
A
 
U
o
W
 
t
r
a
n
s
f
o
r
m
e
r
 
u
s
e
s
 
d
i
s
t
r
i
b
u
t
e
d
 
t
r
a
n
s
a
c
t
i
o
n
 
m
a
p
p
i
n
g
 
a
n
d
 
c
r
e
a
t
e
s
 
a
 
u
s
e
r
 
m
a
n
a
g
e
d
 
t
r
a
n
s
a
c
t
i
o
n
 
f
r
o
m
 
t
h
e
 
g
e
n
e
r
a
t
e
d
 
f
i
e
l
d
.
 
 
L
i
s
t
i
n
g
s
h
o
w
s
 
t
h
e
 
g
e
n
e
r
a
t
e
d
 
f
r
o
m
 
S
u
n
 
E
 
r
e
f
e
r
e
n
c
e
 
i
m
p
l
e
m
e
n
t
a
t
i
o
n
.
 
 
 
)
   ut.begin (
; 
   orderDao.insertOrder(order)
; 
   itemDao.update Quantity(order)
; 
   ut.commit(
; 
   } catch (Exception e )  { 
   ut.rollback(
; 
  throw new DAOException (e.toString(
; 
  } 

 8.

J2E

insertOrder 

J2E

7.  Summary  and  future  work  

[20 ]

[18 ]

[26 ]

[24 ]

[25 ]

[1 ]

References

[1 ]

[2 ]
[3 ]

[4 ]

[5 ]

[6 ]

[7 ]

[8 ]

 2003.
/2001 -07 -01 .

v2 .0,
2003 .

 2001  

'01 )
 2001 ,
 327 -341.

for Model-Driven 
2002 .

Executa ble  
UM L
Architecture,

Foundation  

Generative  
 Tools ,
 Methods,
ming :
 and  
Applications,

Principle  of  Data bases  Syste ms ,

Progra m
 2000.

 1 980 .

Develop ment  without  

Expert One -on -One  
J2E
 2004 .
J2E
Patterns :
Core 
Best  
Practices and Design Strategies,
2001 .

[10 ]

 2  

j2 e

[11 ]

[12 ]

LD B

Journal

 1 (2 )

 1 9

92.

Concurrency  Control  and  Recovery in Database  
 1 987.
Syste ms,

Proceedings of the 2005  Ninth IEEE International ED
 IEEE 
0-7695-2441-9/05 $20.00 © 2005

OC Enterprise Computing Conference (ED OC í05) 

)
)
)
)
)
}
L
i
s
t
i
n
g
 
T
h
e
 
i
n
 
a
 
d
i
s
t
r
i
b
u
t
e
d
 
t
r
a
n
s
a
c
t
i
o
n
 
u
s
i
n
g
 
E
 
J
T
A
 
B
o
t
h
 
i
m
p
l
e
m
e
n
t
a
t
i
o
n
s
 
t
h
r
o
w
 
a
 
g
e
n
e
r
i
c
 
D
A
O
E
x
c
e
p
t
i
o
n
.
 
 
T
h
e
 
e
x
c
e
p
t
i
o
n
 
s
u
b
c
l
a
s
s
e
s
 
f
r
o
m
 
t
h
e
 
H
i
b
e
r
n
a
t
e
E
x
c
e
p
t
i
o
n
 
i
n
 
H
i
b
e
r
n
a
t
e
 
o
r
 
t
h
e
 
E
J
B
E
x
c
e
p
t
i
o
n
 
i
n
 
E
.
 
I
n
 
a
d
d
i
t
i
o
n
 
t
o
 
t
h
e
 
t
w
o
 
t
r
a
n
s
f
o
r
m
e
r
s
,
 
a
 
t
r
a
n
s
f
o
r
m
e
r
 
d
e
v
e
l
o
p
e
r
 
c
a
n
 
c
r
e
a
t
e
 
o
t
h
e
r
 
m
a
p
p
i
n
g
s
,
 
f
o
r
 
e
x
a
m
p
l
e
,
 
f
o
r
 
J
D
B
C
,
 
O
R
M
 
o
r
 
s
p
e
c
i
a
l
i
z
e
d
 
i
m
p
l
e
m
e
n
t
a
t
i
o
n
s
 
b
y
 
a
d
d
i
n
g
 
m
a
p
p
i
n
g
 
c
h
o
i
c
e
s
 
f
o
r
 
t
h
e
 
U
o
W
 
t
r
a
n
s
a
c
t
i
o
n
 
i
n
 
t
h
e
 
U
o
W
 
p
r
o
f
i
l
e
 
a
n
d
 
r
e
g
i
s
t
e
r
i
n
g
 
n
e
w
 
t
r
a
n
s
f
o
r
m
e
r
s
 
t
o
 
t
h
e
 
f
r
a
m
e
w
o
r
k
.
 
 
T
h
e
 
M
D
A
 
w
i
l
l
 
b
e
c
o
m
e
 
m
o
r
e
 
p
r
a
c
t
i
c
a
l
 
w
h
e
n
 
l
i
b
r
a
r
i
e
s
 
o
f
 
c
o
m
m
o
n
,
 
r
e
u
s
a
b
l
e
 
o
b
j
e
c
t
 
s
e
r
v
i
c
e
s
 
a
r
e
 
d
e
f
i
n
e
d
 
a
s
 
s
t
a
n
d
a
r
d
 
p
r
o
f
i
l
e
s
.
 
 
T
h
e
 
s
t
a
n
d
a
r
d
s
 
w
i
l
l
 
b
e
 
u
s
e
d
 
a
s
 
c
o
n
t
r
a
c
t
s
 
f
o
r
 
a
p
p
l
i
c
a
t
i
o
n
 
m
o
d
e
l
e
r
s
 
t
o
 
u
s
e
 
p
l
a
t
f
o
r
m
 
i
n
d
e
p
e
n
d
e
n
t
 
s
e
r
v
i
c
e
s
 
i
n
 
t
h
e
i
r
 
P
I
M
 
a
n
d
 
f
o
r
 
t
r
a
n
s
f
o
r
m
a
t
i
o
n
 
d
e
v
e
l
o
p
e
r
s
 
t
o
 
w
r
i
t
e
 
t
r
a
n
s
f
o
r
m
e
r
s
 
f
o
r
 
n
e
w
 
t
a
r
g
e
t
 
p
l
a
t
f
o
r
m
s
 
o
r
 
t
o
 
o
p
t
i
m
i
z
e
 
t
h
e
 
t
r
a
n
s
f
o
r
m
a
t
i
o
n
 
t
o
 
s
p
e
c
i
f
i
c
 
r
e
q
u
i
r
e
m
e
n
t
s
.
 
T
h
i
s
 
p
a
p
e
r
 
d
e
s
c
r
i
b
e
s
 
t
h
e
 
u
n
i
t
 
o
f
 
w
o
r
k
 
m
o
d
e
l
i
n
g
 
t
o
 
s
u
p
p
o
r
t
 
t
r
a
n
s
p
a
r
e
n
t
 
t
r
a
n
s
a
c
t
i
o
n
 
m
a
n
a
g
e
m
e
n
t
 
i
n
 
p
l
a
t
f
o
r
m
 
i
n
d
e
p
e
n
d
e
n
t
 
m
o
d
e
l
s
 
a
n
d
 
t
r
a
n
s
f
o
r
m
a
t
i
o
n
 
o
f
 
t
h
e
 
p
l
a
t
f
o
r
m
 
i
n
d
e
p
e
n
d
e
n
t
 
m
o
d
e
l
s
 
t
h
a
t
 
u
s
e
 
u
n
i
t
 
o
f
 
w
o
r
k
s
 
i
n
t
o
 
i
m
p
l
e
m
e
n
t
a
t
i
o
n
 
m
o
d
e
l
s
.
 
 
T
h
e
 
U
o
W
 
m
o
d
e
l
i
n
g
 
d
e
t
e
r
m
i
n
e
s
 
t
h
e
 
d
a
t
a
 
s
o
u
r
c
e
s
 
u
s
e
d
 
w
i
t
h
i
n
 
t
r
a
n
s
a
c
t
i
o
n
a
l
 
o
p
e
r
a
t
i
o
n
s
 
f
r
o
m
 
c
l
a
s
s
 
m
o
d
e
l
s
 
a
n
d
 
a
n
n
o
t
a
t
i
o
n
s
 
a
n
d
 
g
e
n
e
r
a
t
e
s
 
a
n
 
a
p
p
r
o
p
r
i
a
t
e
 
t
r
a
n
s
a
c
t
i
o
n
 
m
a
n
a
g
e
m
e
n
t
 
i
m
p
l
e
m
e
n
t
a
t
i
o
n
.
 
 
T
h
e
 
p
r
o
t
o
t
y
p
e
 
c
u
r
r
e
n
t
l
y
 
s
u
p
p
o
r
t
s
 
H
i
b
e
r
n
a
t
e
 
a
n
d
 
J
T
A
 
t
r
a
n
s
f
o
r
m
e
r
s
.
 
a
n
d
 
t
h
e
 
M
e
r
c
a
t
o
r
 
t
r
a
n
s
f
o
r
m
a
t
i
o
n
 
f
r
a
m
e
w
o
r
k
 
a
l
l
o
w
s
 
p
l
u
g
g
a
b
l
e
 
t
r
a
n
s
f
o
r
m
e
r
s
 
f
o
r
 
d
i
f
f
e
r
e
n
t
 
m
i
d
d
l
e
w
a
r
e
 
i
m
p
l
e
m
e
n
t
a
t
i
o
n
 
.
 
 
F
u
t
u
r
e
 
w
o
r
k
 
i
n
c
l
u
d
e
s
 
t
r
a
n
s
f
o
r
m
a
t
i
o
n
 
s
u
p
p
o
r
t
 
f
o
r
 
o
t
h
e
r
 
t
r
a
n
s
a
c
t
i
o
n
 
s
e
r
v
i
c
e
 
m
i
d
d
l
e
w
a
r
e
 
a
n
d
 
t
h
e
 
t
r
a
n
s
a
c
t
i
o
n
 
e
x
c
e
p
t
i
o
n
 
h
a
n
d
l
i
n
g
 
a
n
d
 
r
e
t
r
y
 
s
p
e
c
i
f
i
c
a
t
i
o
n
 
p
o
l
i
c
y
.
 
W
e
 
b
e
l
i
e
v
e
 
t
h
a
t
 
t
h
e
 
m
i
d
d
l
e
w
a
r
e
 
i
n
d
e
p
e
n
d
e
n
t
 
s
e
r
v
i
c
e
 
s
u
p
p
o
r
t
 
i
n
 
M
e
r
c
a
t
o
r
 
p
r
o
v
i
d
e
s
 
a
 
h
i
g
h
e
r
 
l
e
v
e
l
 
o
f
 
a
b
s
t
r
a
c
t
i
o
n
 
t
h
a
t
 
d
e
c
o
u
p
l
e
s
 
b
u
s
i
n
e
s
s
 
m
o
d
e
l
s
 
f
r
o
m
 
m
i
d
d
l
e
w
a
r
e
 
s
p
e
c
i
f
i
c
 
i
n
f
o
r
m
a
t
i
o
n
 
a
n
d
 
a
l
l
o
w
s
 
a
p
p
l
i
c
a
t
i
o
n
 
m
o
d
e
l
e
r
s
 
t
o
 
m
o
d
e
l
 
s
y
s
t
e
m
s
 
w
i
t
h
 
h
i
g
h
 
l
e
v
e
l
 
e
n
t
e
r
p
r
i
s
e
 
p
a
t
t
e
r
n
s
 
s
u
c
h
 
a
s
 
P
a
t
t
e
r
n
s
 
o
f
 
E
n
t
e
r
p
r
i
s
e
 
A
p
p
l
i
c
a
t
i
o
n
 
A
r
c
h
i
t
e
c
t
u
r
e
 
 
,
 
D
o
m
a
i
n
 
D
r
i
v
e
n
 
D
e
s
i
g
n
 
 
,
d
i
s
t
r
i
b
u
t
e
d
 
c
o
m
p
u
t
i
n
g
 
e
n
v
i
r
o
n
m
e
n
t
 
 
,
 
o
r
 
s
p
e
c
i
f
i
c
 
o
b
j
e
c
t
 
s
e
r
v
i
c
e
s
 
 
.
 
 
M
o
d
e
l
 
t
r
a
n
s
f
o
r
m
a
t
i
o
n
 
d
e
v
e
l
o
p
e
r
s
 
w
i
l
l
 
b
e
 
r
e
s
p
o
n
s
i
b
l
e
 
f
o
r
 
r
e
a
l
i
z
i
n
g
 
t
h
e
 
m
o
d
e
l
 
m
a
p
p
i
n
g
 
i
n
t
o
 
t
a
r
g
e
t
 
i
m
p
l
e
m
e
n
t
a
t
i
o
n
s
.
 
I
n
 
a
d
d
i
t
i
o
n
 
t
o
 
u
n
i
t
 
o
f
 
w
o
r
k
 
m
o
d
e
l
i
n
g
 
d
i
s
c
u
s
s
e
d
 
i
n
 
t
h
i
s
 
p
a
p
e
r
 
a
n
d
 
p
e
r
s
i
s
t
e
n
c
e
 
s
e
r
v
i
c
e
 
 
s
p
e
c
i
f
i
c
a
t
i
o
n
s
,
 
w
e
 
h
a
v
e
 
i
d
e
n
t
i
f
i
e
d
 
o
t
h
e
r
 
m
i
d
d
l
e
w
a
r
e
 
i
n
d
e
p
e
n
d
e
n
t
 
p
r
o
f
i
l
e
s
 
a
n
d
 
t
r
a
n
s
f
o
r
m
a
t
i
o
n
 
s
u
p
p
o
r
t
 
f
o
r
 
o
b
j
e
c
t
 
d
i
s
t
r
i
b
u
t
i
o
n
,
 
m
e
s
s
a
g
i
n
g
 
a
n
d
 
s
e
c
u
r
i
t
y
.
 
 
T
h
e
 
l
o
n
g
 
t
e
r
m
 
g
o
a
l
 
o
f
 
o
u
r
 
r
e
s
e
a
r
c
h
 
i
s
 
t
o
 
s
p
e
c
i
f
y
 
m
i
d
d
l
e
w
a
r
e
 
i
n
d
e
p
e
n
d
e
n
t
 
l
i
b
r
a
r
i
e
s
 
a
n
d
 
c
r
e
a
t
e
 
e
x
t
e
n
s
i
b
l
e
 
t
r
a
n
s
f
o
r
m
a
t
i
o
n
 
f
r
a
m
e
w
o
r
k
 
t
h
a
t
 
a
l
l
o
w
s
 
s
o
f
t
w
a
r
e
 
d
e
v
e
l
o
p
e
r
s
 
t
o
 
d
e
f
i
n
e
 
n
e
w
 
p
l
a
t
f
o
r
m
 
i
n
d
e
p
e
n
d
e
n
t
 
l
i
b
r
a
r
i
e
s
 
o
r
 
i
m
p
l
e
m
e
n
t
 
n
e
w
 
t
r
a
n
s
f
o
r
m
a
t
i
o
n
s
 
o
f
 
e
x
i
s
t
i
n
g
 
l
i
b
r
a
r
i
e
s
 
i
n
t
o
 
o
t
h
e
r
 
t
a
r
g
e
t
 
p
l
a
t
f
o
r
m
s
.
 
 
W
.
 
W
i
t
t
h
a
w
a
s
k
u
l
 
a
n
d
 
R
.
 
J
o
h
n
s
o
n
,
 
(cid:141)
S
p
e
c
i
f
y
i
n
g
 
P
e
r
s
i
s
t
e
n
c
e
 
i
n
 
P
l
a
t
f
o
r
m
 
I
n
d
e
p
e
n
d
e
n
t
 
M
o
d
e
l
s
,
Ž
 
I
n
 
W
o
r
k
s
h
o
p
 
i
n
 
S
o
f
t
w
a
r
e
 
M
o
d
e
l
 
E
n
g
i
n
e
e
r
i
n
g
,
 
t
h
e
 
S
i
x
t
h
 
I
n
t
e
r
n
a
t
i
o
n
a
l
 
C
o
n
f
e
r
e
n
c
e
 
o
n
 
t
h
e
 
U
n
i
f
i
e
d
 
M
o
d
e
l
i
n
g
 
L
a
n
g
u
a
g
e
,
 
 
M
o
d
e
l
 
D
r
i
v
e
n
 
A
r
c
h
i
t
e
c
t
u
r
e
,
 
o
r
m
s
c
 
 
O
b
j
e
c
t
 
M
a
n
a
g
e
m
e
n
t
 
G
r
o
u
p
,
 
I
n
c
.
,
 
U
n
i
f
i
e
d
 
M
o
d
e
l
i
n
g
 
L
a
n
g
u
a
g
e
 
S
u
p
e
r
s
t
r
u
c
t
u
r
e
 
S
p
e
c
i
f
i
c
a
t
i
o
n
,
 
 
A
u
g
u
s
t
 
 
D
.
 
R
i
e
h
l
e
,
 
e
t
.
 
a
l
.
,
 
"
T
h
e
 
A
r
c
h
i
t
e
c
t
u
r
e
 
o
f
 
a
 
U
M
L
 
V
i
r
t
u
a
l
 
M
a
c
h
i
n
e
,
"
 
I
n
 
P
r
o
c
e
e
d
i
n
g
s
 
o
f
 
t
h
e
C
o
n
f
e
r
e
n
c
e
 
o
n
 
O
b
j
e
c
t
-
O
r
i
e
n
t
e
d
 
P
r
o
g
r
a
m
m
i
n
g
 
S
y
s
t
e
m
s
,
 
L
a
n
g
u
a
g
e
s
,
 
a
n
d
 
A
p
p
l
i
c
a
t
i
o
n
s
 
(
O
O
P
S
L
A
 
,
 
A
C
M
 
P
r
e
s
s
,
 
p
p
.
 
 
S
.
 
M
e
l
l
o
r
,
 
M
.
 
B
a
l
c
e
r
,
 
:
 
A
 
 
A
d
d
i
s
o
n
 
W
e
s
l
e
y
,
 
 
K
.
 
C
z
a
r
n
e
c
k
i
,
 
U
.
 
E
i
s
e
n
e
c
k
e
r
,
 
A
d
d
i
s
o
n
 
W
e
s
l
e
y
,
 
 
J
.
 
D
.
 
U
l
l
m
a
n
,
 
C
o
m
p
u
t
e
r
 
S
c
i
e
n
c
e
 
P
r
e
s
s
,
 
 
R
.
 
J
o
h
n
s
o
n
 
a
n
d
 
J
.
 
H
o
e
l
l
e
r
,
 
E
 
E
J
B
,
 
W
r
o
x
,
 
[
9
]
 
D
.
 
A
l
u
r
,
 
J
.
 
C
r
u
p
i
 
a
n
d
 
D
.
 
M
a
l
k
s
,
 
E
 
 
 
P
r
e
n
t
i
c
e
 
H
a
l
l
,
 
 
J
a
v
a
P
l
a
t
f
o
r
m
,
 
E
n
t
e
r
p
r
i
s
e
 
E
d
i
t
i
o
n
,
 
h
t
t
p
:
/
/
j
a
v
a
.
s
u
n
.
c
o
m
/
e
/
i
n
d
e
x
.
j
s
p
.
 
 
Y
.
 
B
r
e
i
t
b
a
r
t
,
 
H
.
 
G
a
r
c
i
a
-
M
o
l
i
n
a
,
 
a
n
d
 
A
.
 
S
i
l
b
e
r
s
c
h
a
t
z
,
 
O
v
e
r
v
i
e
w
 
o
f
 
m
u
l
t
i
d
a
t
a
b
a
s
e
 
t
r
a
n
s
a
c
t
i
o
n
 
m
a
n
a
g
e
m
e
n
t
,
 
V
 
,
,
 
 
P
.
 
B
e
r
n
s
t
e
i
n
,
 
V
.
 
H
a
d
z
i
l
a
c
o
s
 
a
n
d
 
N
.
 
G
o
o
d
m
a
n
,
 
 
A
d
d
i
s
o
n
-
W
e
s
l
e
y
 
P
u
b
l
i
s
h
i
n
g
,
 
[13]

[14]

[15]

[16]

[17]

[18]

[1 9

[20]

[21]

[22]

[23]

e2  

[24]

[25]

[26]

Infor mation Systems

Hibernate In 
Action,

 13,

 2 ,

 1 981 ,
 185 -221.

7 ,

 1,
 1 982.

 1 9323 9415 X

 2004 .

 1 987,
249
…25 9

-260 ,
 1 981 .

Patterns  of  
 2003 .
Architecture,

Enterprise  

Application 

 2004 .

The  
 2005 .
Edition,

Third  

Java 
Language  Specification ,

Domain-Driven Design:
 Tackling 
Co mplexity  in  the  Heart  of  Software,
2003 .

2002 .

 8 t
 2004  
 2004 .

Proceedings of the 2005  Ninth IEEE International ED
 IEEE 
0-7695-2441-9/05 $20.00 © 2005

OC Enterprise Computing Conference (ED OC í05) 

 
P
.
 
B
e
r
n
s
t
e
i
n
 
a
n
d
 
N
.
 
G
o
o
d
m
a
n
,
 
"
C
o
n
c
u
r
r
e
n
c
y
 
C
o
n
t
r
o
l
 
i
n
 
D
i
s
t
r
i
b
u
t
e
d
 
D
a
t
a
b
a
s
e
 
S
y
s
t
e
m
s
,
"
 
A
C
M
 
C
o
m
p
u
t
i
n
g
 
S
u
r
v
e
y
s
,
 
V
o
l
.
 
N
o
.
 
J
u
n
e
 
p
p
.
 
 
D
.
 
A
.
 
M
e
n
a
s
c
e
 
a
n
d
 
T
.
 
N
a
k
a
n
i
s
h
i
,
 
"
O
p
t
i
m
i
s
t
i
c
 
v
e
r
s
u
s
 
p
e
s
s
i
m
i
s
t
i
c
 
c
o
n
c
u
r
r
e
n
c
y
 
c
o
n
t
r
o
l
 
m
e
c
h
a
n
i
s
m
s
 
i
n
 
d
a
t
a
b
a
s
e
 
m
a
n
a
g
e
m
e
n
t
 
s
y
s
t
e
m
s
,
"
 
 
 
C
.
 
B
a
u
e
r
,
 
G
.
 
K
i
n
g
,
 
 
M
a
n
n
i
n
g
 
P
u
b
l
i
c
a
t
i
o
n
s
,
 
I
S
B
N
,
 
 
 
H
.
 
G
a
r
c
i
a
-
M
o
l
i
n
a
 
a
n
d
 
K
.
 
S
a
l
e
m
,
 
(cid:141)
S
a
g
a
s
,
Ž
 
P
r
o
c
e
e
d
i
n
g
s
 
o
f
 
A
C
M
 
S
I
G
M
O
D
,
 
S
a
n
 
F
r
a
n
c
i
s
c
o
,
 
C
A
,
 
p
p
.
 
.
 
 
J
.
 
E
l
i
o
t
 
B
.
 
M
o
s
s
,
 
N
e
s
t
e
d
 
t
r
a
n
s
a
c
t
i
o
n
s
:
 
A
n
 
A
p
p
r
o
a
c
h
 
t
o
 
R
e
l
i
a
b
l
e
 
D
i
s
t
r
i
b
u
t
e
d
 
C
o
m
p
u
t
i
n
g
,
 
P
h
.
D
.
 
t
h
e
s
i
s
,
 
M
I
T
/
L
C
S
/
T
R
 
M
a
s
s
a
c
h
u
s
e
t
t
s
 
I
n
s
t
i
t
u
t
e
 
o
f
 
T
e
c
h
n
o
l
o
g
y
,
 
 
M
.
 
F
o
w
l
e
r
,
 
 
A
d
d
i
s
o
n
-
W
e
s
l
e
y
,
 
]
 
O
r
a
c
l
e
 
A
p
p
l
i
c
a
t
i
o
n
 
S
e
r
v
e
r
 
T
o
p
L
i
n
k
 
A
p
p
l
i
c
a
t
i
o
n
 
D
e
v
e
l
o
p
e
r
'
s
 
G
u
i
d
e
,
 
h
t
t
p
:
/
/
w
w
w
.
o
r
a
c
l
e
.
c
o
m
/
t
e
c
h
n
o
l
o
g
y
/
p
r
o
d
u
c
t
s
/
i
a
s
/
t
o
p
l
i
n
k
/
i
n
d
e
x
.
h
t
m
l
.
 
 
W
.
 
W
i
t
t
h
a
w
a
s
k
u
l
 
a
n
d
 
R
.
 
J
o
h
n
s
o
n
,
 
(cid:141)
A
n
 
O
b
j
e
c
t
 
O
r
i
e
n
t
e
d
 
M
o
d
e
l
 
T
r
a
n
s
f
o
r
m
e
r
 
F
r
a
m
e
w
o
r
k
 
b
a
s
e
d
 
o
n
 
S
t
e
r
e
o
t
y
p
e
s
,
Ž
 
I
n
 
W
o
r
k
s
h
o
p
 
i
n
 
S
o
f
t
w
a
r
e
 
M
o
d
e
l
 
E
n
g
i
n
e
e
r
i
n
g
,
 
t
h
e
 
S
e
v
e
n
t
h
 
I
n
t
e
r
n
a
t
i
o
n
a
l
 
C
o
n
f
e
r
e
n
c
e
 
o
n
 
t
h
e
 
U
n
i
f
i
e
d
 
M
o
d
e
l
i
n
g
 
L
a
n
g
u
a
g
e
,
 
 
X
D
o
c
l
e
t
:
 
A
t
t
r
i
b
u
t
e
d
-
o
r
i
e
n
t
e
d
 
P
r
o
g
r
a
m
m
i
n
g
 
i
n
 
J
a
v
a
,
 
h
t
t
p
:
/
/
x
d
o
c
l
e
t
.
s
f
.
n
e
t
/
.
 
 
J
.
 
G
o
s
l
i
n
g
,
 
e
t
.
 
a
l
.
,
 
 
 
A
d
d
i
s
o
n
-
W
e
s
l
e
y
 
P
r
o
f
e
s
s
i
o
n
a
l
,
 
 
H
i
b
e
r
n
a
t
R
e
f
e
r
e
n
c
e
 
D
o
c
u
m
e
n
t
a
t
i
o
n
,
 
h
t
t
p
:
/
/
h
i
b
e
r
n
a
t
e
.
b
l
u
e
m
a
r
s
.
n
e
t
.
 
 
E
.
 
E
v
a
n
s
,
 
 
A
d
d
i
s
o
n
-
W
e
s
l
e
y
,
 
 
 
U
M
L
 
P
r
o
f
i
l
e
 
f
o
r
 
E
n
t
e
r
p
r
i
s
e
 
D
i
s
t
r
i
b
u
t
e
d
 
O
b
j
e
c
t
 
C
o
m
p
u
t
i
n
g
 
S
p
e
c
i
f
i
c
a
t
i
o
n
,
 
O
b
j
e
c
t
 
M
a
n
a
g
e
m
e
n
t
 
G
r
o
u
p
,
 
 
 
R
.
 
S
i
l
a
g
h
i
,
 
F
.
 
F
o
n
d
e
m
e
n
t
 
a
n
d
 
A
.
 
 
S
t
r
o
h
m
e
i
e
r
,
 
"
T
o
w
a
r
d
s
 
a
n
 
M
D
A
-
O
r
i
e
n
t
e
d
 
U
M
L
 
P
r
o
f
i
l
e
 
f
o
r
 
D
i
s
t
r
i
b
u
t
i
o
n
,
"
 
I
n
 
t
h
e
h
 
I
n
t
e
r
n
a
t
i
o
n
a
l
 
E
n
t
e
r
p
r
i
s
e
 
D
i
s
t
r
i
b
u
t
e
d
 
O
b
j
e
c
t
 
C
o
m
p
u
t
i
n
g
 
(
E
D
O
C
)
c
o
n
f
e
r
e
n
c
e
,
 
Analyzing Multiple Con“gurations of a C Program

Alejandra Garrido and Ralph Johnson
University of Illinois at Urbana-Champaign
garrido@cs.uiuc.edu, johnson@cs.uiuc.edu

Abstract

sor conditionals are heavily
Preproces
sed in C pro-
grams
the source code to be con(cid:147)gured
since they allow
for different pla tforms or capabilities. However, preproces-
sor conditionals, a s
well as other preproces
sor directives,
are not part of the C language. They need to be evaluated
and removed, and so a single con(cid:147)guration selected, before
t analy
parsing can take place. Mos
sis and program under-
tanding tools run on this preproces
sed version of the code
s are based on a single con(cid:147)g uration.
so their res
ult
This paper describes
the approach of CRefactory, a
refactoring tool for C programs. A refactoring tool cannot
consider only a single con(cid:147)guration: changing the code for
t of the code. CRefac-
one con(cid:147)guration may break the res
sible con(cid:147)g urations
ses
tory analy
the program for all pos
sly. CRefactory also preserves preproces
sim ultaneou
sor di-
rec tives and integra tes
them in the internal representations.
The paper also present
to
udies
wo case s
s metrics from t
show
that CRefactory
s program representation is practi-
cal.

1. Introduction

The C preprocessor (Cpp) adds many useful features to
the C language, such as the ability to con“gure a program
for different platforms by way of preprocessor conditionals.
A con“guration can be de“ned as the initial value of macros
(a.k.a. con“guration variables) that Cpp receives as input to
preprocess a program. With this, a con“guration determines
which single branch of each preprocessor conditional will
be present in the output of Cpp. Others consider this output
of Cpp, the preprocessed code, to be a con“guration. The
de “nitions are isomorphic but we generally refer to the “rst.
Most projects written in C are highly con“gurable. For
example, Flex [4] has less than 20K lines of code among 21
“les, but has 5 con“guration variables that make up a space
of 25 possible con“gurations. The Linux kernel (version
2.6.7) has about 1,672 con“guration variables with binary
value. The number of possible con“gurations is huge.

The virtue of Cpp conditionals is lost once a program
is preprocessed. Since the syntax of Cpp directives is dif-
ferent than the syntax of the C language, they need to be
evaluated and removed before further processing [14]. This
is satisfactory when the goal is to compile the program to
be able to execute it: Cpp directives need to be removed
and the program needs to be targeted to a single platform.
But when the goal is to analyze or understand a program,
selecting a single con “guration loses information.
Although the problem has been recogni zed and partially
approached, it has remained unsolved. The section on Re-
lated Work describes these approaches, from which the one
in DMS [9] is the best approximation to handle multiple
con “gurations.
The problem cannot be ignored for a refactoring tool.
Refactoring tools have become popular for object-oriented
languages like Smalltalk [16] and Java [2, 5]. They let
programmers interactively and incrementally improve the
structure of large programs without introducing errors. We
are building a refactoring tool for C:CRefactory
, and a ma-
jor obstacle has been dealing with Cpp [12]. If refactorings
are applied on the preprocessed version of a program, it may
not be possible to recover the un-preprocessed version with
Cpp directives and macro calls. Moreover, changing the
code once it has been targeted to a speci“c con“guration
isolates that code from all the rest: if the changed code is
merged back, the source code for other con“gurations may
not compile anymore or the behavior may be altered.
Therefore, it is not acceptable to have the refactoring tool
work on a single con“guration of a program, nor to lose
any Cpp directives. A refactoring tool must ensure pro-
gram behavior is preserved for all possible con“gurations.
CRefactory solves the problem: it preserves Cpp directives
and represents the program for all possible con“gurations
simultaneously.
Our previous paper ([13]) gives an overview of the kind
of problems we had to face to be able to handle conditional
directives. This paper extends our previous paper with de-
tails of our solution and results of its applicability. Sec-
tion 2 shows how we integrate Cpp conditionals in the C
grammar and in the program representations that CRefac-

 21 s
(cid:144)05 )
1063-6773/05 

$20.00 

 2005 

I E

u
s
t
(cid:144)
P
r
o
c
e
e
d
i
n
g
s
 
o
f
 
t
h
e
t
 
I
E
E
E
 
I
n
t
e
r
n
a
t
i
o
n
a
l
 
C
o
n
f
e
r
e
n
c
e
 
o
n
 
S
o
f
t
w
a
r
e
 
M
a
i
n
t
e
n
a
n
c
e
 
(
I
C
S
M
 
©
E
E
 
It also provides a short description of how
tory creates.
CRefactory handles other Cpp directives: #define (used
to de“ne macros) and #include (for “le inclusion) in re-
lation to conditionals. Detailed discussion of these two di-
rectives will appear elsewhere. Section 3 describes the in-
ternal transformation CRefactory performs on Cpp condi-
tionals so they can be parsed, and how it later pretty prints
the abstract syntax tree so the transformation on condition-
als remains transparent. Section 4 shows how the program
representations are “nally used during refactoring. Section
5 shows measurements of CRefactory(cid:144)s program represen-
tation on two case studies: rm [1] and Flex [4]. Section
6 lists related work and Section 7 presents conclusions and
future work.

2. Including multiple con“gurations in a pro-
gram(cid:144)s representation

CRefactory preserves all possible con“gurations of a
program.
It does not use Cpp and does not remove any
Cpp directives. However, some processing is needed be-
fore parsing takes place, to tokenize the source code [18]
and gather information about Cpp directives. We call this
step pseudo-preproces
[13]. CRefactory has a pseudo-
sing
preprocessor calledP-Cpp that outputs a tokenized version
of the input source code plus some representations of Cpp
directives described in Section 3.
The C grammar used by CRefactory allows Cpp direc-
tives at the level of “ve syntactic constructs, which are listed
in Table 1. Although #define and #include direc-
tives may potentially break these constructs, we have not
found any examples in any of our test cases (open-source
packages like the Linux Kernel, the GNU library, q-mail,
Flex, make). However, conditional directives often break
these constructs. As explained below, CRefactory does not
restrict the position of conditional directives but internally
manipulates them to comply with the grammar. P-Cpp also
expands macro calls so that the program can be parsed [12].
For both, conditional directive manipulation and macro ex-
pansion, P-Cpp tags the tokens accordingly so the changes
can be reversed by the pretty-printer.

Table 1. Syntactic constructs allowed in be-
tween Cpp directives

Statement
Declaration
Structure “eld
Enumerator value
Array initializer value

CRefactory builds two main data structures to represent
C programs: the symbol table and the abstract syntax tree
(AST) [13]. Both data structures integrate Cpp directives
with C entities (variables, functions, etc.). For example, the
symbol table includes entries for macro de“nitions. More-
over, the symbol table allows a symbol to have different
de“nitions that depend on the con “guration, even allowing
a symbol to have both a macro de“nition and a de“nition as
a variable or some other C entity. The AST represents Cpp
directives as nodes and macro calls as node labels. This rep-
resentation allows programs to be analyzed and transformed
while preserving the un-preproces
source code.
sed
Cpp directives also cause problems during refactoring
[12, 13]. Therefore, refactoring preconditions in CRefac-
tory check for instances of Cpp directives invalidating the
refactoring. Transformations are applied by manipulating
the AST. Finally, the AST is pretty-printed by reversing the
internal manipulations that P-Cpp does on the source code
(moving conditionals and expanding macro calls), so the
source code appears just as the developer wrote it except
for the refactorings he applied. Exact pretty-printing is hard
to achieve but makes a refactoring tool much more usable.

2.1. Conditional directives

Conditional compilation directives de“ne separate code
branches, which are included or excluded from the “nal
compilation unit depending on the value of conditions eval-
uated by Cpp [14]. Figure 1 shows a piece of code ex-
tracted from Make-3.80 which contains some conditional
directives.

#ifndef alloca
#if _
_STDC_
typedef void *pointer ;
#else
typedef char *pointer;
#endif

Figure 1. Example of conditional directives

A conditional directive is one of the following: #if,
#ifdef, #ifndef, #elif, #else or #endif. The
#if, #ifdef and #ifndef directives start a Cpp con-
ditional construct, creating its “rst branch. The #elif
and #else directives create additional branches on the Cpp
conditional and the #endif ends the construct. The #if
and #elif tokens are followed by a constant expression
in terms of macro de“nitions. The lines (cid:141) #ifdef id (cid:142) and
(cid:141) #ifndef id (cid:142) are abbreviations of (cid:141) #if defined id (cid:142)
and (cid:141) #if !(defined id )(cid:142) respectively. The source text
inside a branch may include other Cpp directives. Conse-
quently, Cpp conditionals can also be nested.

 21 s
(cid:144)05 )
1063-6773/05 

$20.00 

 2005 

I E

_
P
r
o
c
e
e
d
i
n
g
s
 
o
f
 
t
h
e
t
 
I
E
E
E
 
I
n
t
e
r
n
a
t
i
o
n
a
l
 
C
o
n
f
e
r
e
n
c
e
 
o
n
 
S
o
f
t
w
a
r
e
 
M
a
i
n
t
e
n
a
n
c
e
 
(
I
C
S
M
 
©
E
E
 
We can say that every token in the source code is guarded
by a condition that depends on the conditional directives
that surround it. P-Cpp associates tokens and symbol table
entries with the condition that guards them. For example,
the condition associated with the token void in the third
line of Figure 1 is ( ¬ def ined(alloca) (cid:1) ST DC ) , which
in CRefactory(cid:144)s representation translates to:
AndC ondition(
N otC ondition (Def inedC ondition(alloca)) ,
C ondition( ST DC ))

Figure 2 shows the entry for symbol pointer in the
symbol table (the conditions have been abbreviated).

pointer

:
Guarding condition
And (Not  (Defined(alloca)),
         __STDC__)
Type: typedef void *

:
Guarding condition
And  (Not (Defined(alloca)),
         Not (__STDC__))
Type: typedef char *

Figure 2. Enhanced symbol table

One way to represent all possible con“gurations of a pro-
gram is to compute all possible combinations of con“gura-
tion variables, parse the program in multiple passes, one for
each combination, and create a different AST for each com-
bination. We could apply this solution with Flex but we
cannot possibly apply it for the more than 2.5M possible
con“gurations of the Linux kernel. In the average case, this
solution would be complex and expensive, and it would also
produce a large amount of duplication in the ASTs. Our ap-
proach, instead, is to parse the program in asingle pas
and
produce a single AST that includes all possible con“gura-
tions [13]. This solution creates a compact representation
and we think it can handle programs as large as the Linux
kernel (although we have not tested the whole kernel at this
time, only parts).
The problem with conditional directives is that they usu-
ally break statements and other C constructs as shown in
Figure 3. We can also think of it as the branches created by
a Cpp conditional being incomplete, i.e., they do not contain
complete syntactical units. DMS solves this problem by re-
stricting conditional directives to appear at certain places in
the grammar, and manually modifying the code that does
not comply [9]. This solution is simpler but not scalable to
large, open-source projects.
CRefactory does not restrict the places where conditional
directives may appear, but automatically and transparently

 21 s
(cid:144)05 )
1063-6773/05 

$20.00 

 2005 

I E

& strchr (name, ':'

) !

= 0)

>changed &

>changed &

MS
#ifdef V
      if (dep-
#else
      if (dep-
#endif
     {
            freerule (rule, lastrule)
            ƒ
     }

& *name =

= '

Figure 3. Incomplete conditional branches

transforms them, turning each branch of a Cpp conditional
into a complete s
, so it complies with the
yntactical unit
grammar. This transformation is explained in detail in Sec-
tion 3.
A macro can have different de“nitions in different con-
“gurations [13]. Moreover, a symbol can be a macro in one
con “guration and a C entity in another. When P-Cpp “nds a
call to a macro with multiple de“nitions (and therefore with
more than one possible expansion), or a symbol that can
be either a macro call or a reference to a C entity, P-Cpp
expands it to a preprocessor conditional with one branch
for each possible macro expansion or C symbol. This pre-
processor conditional introduced by P-Cpp may break the
statement or declaration that contains it. Therefore, those
conditionals introduced by P-Cpp will also need to be com-
pleted for parsing to work, and they turn out to be the hard-
est to complete. The reason is that there can be more than
one macro call in the same statement and the preproces-
sor conditionals in the macro expansions need to be com-
bined. For example, in the case of 3 macro calls in the same
statement, each macro with 2 possible de“nitions, the 3 pre-
processor conditionals in the macro expansions need to be
combined to create 8 conditional branches. In our testing so
far we have not seen more than 3 macro calls that expand to
a Cpp conditional in the same statement. Section 5 shows
the growth of our case studies after the completion of Cpp
conditionals.
In the case of “le inclusion, when a given “le is in-
cluded more than once in a compilation unit, Cpp prepro-
cesses it again every time, since different conditional direc-
tive branches may be selected in subsequent inclusions if
macro de“nitions changed. This is because Cpp selects a
single branch of each Cpp conditional. Conversely, P-Cpp
processes all branches of a conditional in a single pass. As
a result, P-Cpp does not need to process a “le more than
once, but it can reuse the previously generated representa-
tion. The only exception to this is when an included “le
uses macros de“ned previously in the compilation unit, and
those macro de“nitions changed since the previous time the
“le was included. Although we can handle this situation,
we have never encountered it in our testing.

s
/
'
)
;
P
r
o
c
e
e
d
i
n
g
s
 
o
f
 
t
h
e
t
 
I
E
E
E
 
I
n
t
e
r
n
a
t
i
o
n
a
l
 
C
o
n
f
e
r
e
n
c
e
 
o
n
 
S
o
f
t
w
a
r
e
 
M
a
i
n
t
e
n
a
n
c
e
 
(
I
C
S
M
 
©
E
E
 
3. Completing preprocessor conditionals

Preprocessor conditionals are completed in two passes
through the source code. In the “rst pass, P-Cpp tokenizes
the input and recogni zes incomplete Cpp conditionals, cre-
ating descriptors that contain information on how to com-
plete them. In the second pass, incomplete conditionals are
completed by moving and copying tokens as stated by the
descriptors created in the “rst pass. After this second pass,
all Cpp conditionals are complete syntactical units, i.e., they
can be integrated in the C grammar and the source code can
now be parsed.

3.1. First pass of P-Cpp

A Cpp conditional
is considered complete when its
branches enclose a whole syntactic construct, or a whole
list of them, from the constructs that appeared in Table 1.
P-Cpp needs to be able to recognize the beginning and
end of each of the syntactic constructs in Table 1 to rec-
ognize if a conditional is incomplete. In the “rst pass of P-
Cpp, while it tokenizes the input, it keeps track of the tokens
that mark the beginning or the end of any of the constructs
in the table, by maintaining a state stack (as a pushdown au-
tomata). The following description names the states used to
represent each construct.
Simple statement or declaration While scanning a sim-
ple statement or declaration, the top of the state stack
is In-construct. The appearance of a (cid:143);(cid:144) marks the end
of the construct and so P-Cpp replaces In-construct
by End-of-construct at the top of the stack. To pre-
vent confusing the use of (cid:143);(cid:144) inside the expressions
of a for statement (where conditional directives are
not allowed), the state In-for is at the top of the state
stack while scanning the expressions of a for state-
ment. This state ignores (cid:143);(cid:144) characters.
Composite statement When state In-construct is at the
top of the state stack, the appearance of a (cid:143) { (cid:144) makes
P-Cpp push state In-composite-statement.
Inside a
composite statement, the states In-construct or End-
of-construct will be pushed on top of the state stack to
represent inner statements or declarations.
Structure The keyword (cid:143)struct(cid:144) makes P-Cpp push state
In-Struct.
In-
Inside a struct de“nition, the states
construct or End-of-construct will be pushed on top
of the state stack to mark the beginning and end of a
“eld declaration.
Enumerator The keyword (cid:143)enum(cid:144) makes P-Cpp push state
In-Enum. While in this state, the scanning of an
enumerator value is represented by pushing In-Enum-
Elem or End-of-Enum-Elem on top.

Array initializer When the state In-construct is at the top
of the state stack, an (cid:143)=(cid:144) followed by a (cid:143) { (cid:144) mark the
beginning of an array initiali zer. P-Cpp pushes state
In-initializer in this case. The scanning of an initial-
izer value is represented by pushing In-Init-Value or
End-of-Init-Value on top of the state stack.

With this representation of states, a Cpp conditional is
complete if and only if its branches start and end when the
top of the state stack is End-of-construct. Conversely, if
while In-construct is at the top
a Cpp conditional s
tart
of the stack, the Cpp conditional is set to have a bad s
.
tart
Moreover, if a Cpp conditional ends when the top of the
state stack is In-construct, the Cpp conditional has a bad
ending . The pseudo-code for the “rst pass of P-Cpp appears
in Figure 5 in the Appendix.
When P-Cpp encounters conditional directives in its “rst
s from them.
pass, it constructs Cpp
Conditional
Descriptor
These descriptors form a tree that represents the nesting of
conditionals. Moreover, they contain enough information
to “x incomplete conditionals in the second pass. Some of
the information in a Cpp Conditional Descriptor appears in
Table 2.

Table 2. Data in a Cpp Conditional Descriptor

startPosition

endPosition
badStart

badEnding
startPosShouldBe

endPosShouldBe

branches

The position where the Cpp
conditional starts in the current “le
The position where it ends
True if the Cpp conditionals has a
bad start
True if it has a bad ending
The position where the conditional
should start to be complete
The position where it should
end to be complete
A sequence of Cpp
Branch
Descriptors

Conditional

When P-Cpp pushes a state in the state stack, it sets the
state(cid:144)s starting position to be the current source code posi-
tion. This value is used to set the “eld startP osShouldBe
of conditionals that start in the middle of the construct that
the top state represents.
When the end of a Cpp conditional is found in the mid-
dle of a construct, its descriptor is added to a list of con-
ditionals breaking the current construct in the state at the
top of the stack (this list is called condsW BadEndingin
the pseudo-code). Later on, when P-Cpp “nds the end of
the current construct, it sets the value endP osShouldBe
of all descriptors in the list condsW BadEndingto be the
current position.

 21 s
(cid:144)05 )
1063-6773/05 

$20.00 

 2005 

I E

s
P
r
o
c
e
e
d
i
n
g
s
 
o
f
 
t
h
e
t
 
I
E
E
E
 
I
n
t
e
r
n
a
t
i
o
n
a
l
 
C
o
n
f
e
r
e
n
c
e
 
o
n
 
S
o
f
t
w
a
r
e
 
M
a
i
n
t
e
n
a
n
c
e
 
(
I
C
S
M
 
©
E
E
 
3.2. Second pass of P-Cpp

Once the tree of Cpp Conditional Descriptors has been
created, all incomplete conditionals should be “xed by mov-
ing and copying tokens as dictated by their descriptors. Fig-
ures 6 and 7 in the Appendix have the pseudo-code for this
step.
First, if the conditional has a bad start, P-Cpp calculates
the tokens that complete the start of the conditional. Sec-
ond, P-Cpp checks if the next conditional is also incom-
plete and if it breaks the same construct as the current one
(the positions where they should start and end match). In
this case, the next conditional is completed in each branch
of the current conditional, creating this way all four combi-
nations. Following conditionals are checked recursively for
intersections with the previous ones.
If the next conditional does not break the same construct,
and if the current conditional has a bad ending, P-Cpp cal-
culates the tokens that complete the end of the conditional.
Here it is also possible that the next conditional, when being
complete, will become the child of the current one. Figure
4 shows an example where the “rst conditional breaks the
while statement and the second conditional breaks the as-
signment statement inside the body of the while .
In this
case, the next conditional is completed inside the stream of
tokens that complete the end of the current conditional.

= 0

while (
#if _C1
   n !
= 0
#else
   (n … 2) !
#endif
) {
  n = n
#if _C2
  - 3 ;
#else
  / 2 ;
#endif

= 0)  {

#if _C1
  while (n !
# if _C2
     n = n - 3 ;
# else
     n = n / 2 ;
# endif

= 0) {

(n … 2) !

#else
  while (
# if _C2
     n = n - 3 ;
# else
     n = n / 2 ;
# endif
#endif

Figure 4. The second conditional becomes
child of the ìrst

to the beginning of the other
of the “rst branch and copied
branches. If the conditional has a bad ending, the tokens
that complete the end of the conditional are moved
to the
end of the last branch and copied
to the end of the other
branches. Tokens are labelled accordingly so this manipu-
lation can be reversed as described in the next section.

3.3. Pretty-printing of Cpp conditionals

The pretty-printer visits the nodes in the AST and prints
the leaf nodes according to the tokens they represent and the
tokens(cid:144) labels. Figure 8 in the Appendix shows the pseudo-
code for pretty-printing a leaf node that does not come from
macro expansion.
The pretty-printer uses two queues: if s Queue stores the
start directive of Cpp conditionals with bad start. These
start directives go later in the output, after the tokens that
have been moved forward
to complete the “rst branch. The
other queue is the movedBack Queue, and this one is for
nodes representing tokens that have been moved backwards
to complete the end of a conditional. The nodes in the
movedBack Queueare printed after the #endif of the cur-
rent conditional. Nodes that representcopied
tokens are not
printed.

4. Applying refactorings

The program representation used by CRefactory could
also be used by a program analysis or understanding tool
like Genoa [10], Columbus [11] or Visual C# IntelliSense
[6] to provide information about the multiple con “gurations
of a program. We use this program representation for refac-
toring. This section shows two examples that illustrate the
power of the representation to analyze the preconditions of
refactorings and apply the transformations.

4.1 Delete unreferenced variable

After a program has been changed a number of times,
some variables may become unused. However, program-
mers may resist to delete their de“nitions if they are unsure
the variable is used under some particular con“guration.

Input values: variable V .

After the tokens that complete the start and the end of
each incomplete conditional have been calculated, P-Cpp
actually moves and copies those tokens, while it labels
them, in each branch of the conditional. Figure 7 in the
Appendix shows the pseudo-code for how P-Cpp completes
each branch. The basic idea is that the tokens that com-
plete the start of the conditional aremoved
to the beginning

Preconditions: Opdyke [15] describes the precondition of
this refactoring as: ref erencesT o( V
) = (cid:2) . When multi-
ple con“gurations of a program are considered, V
can have
more than one de“nition. CRefactory allows deleting those
de“nitions of
that have no references, even when other
de“nitions of
are used in other con “gurations. In terms
of CRefactory(cid:144)s analysis functions, the precondition of this

 21 s
(cid:144)05 )
1063-6773/05 

$20.00 

 2005 

I E

}
}
}
V
V
P
r
o
c
e
e
d
i
n
g
s
 
o
f
 
t
h
e
t
 
I
E
E
E
 
I
n
t
e
r
n
a
t
i
o
n
a
l
 
C
o
n
f
e
r
e
n
c
e
 
o
n
 
S
o
f
t
w
a
r
e
 
M
a
i
n
t
e
n
a
n
c
e
 
(
I
C
S
M
 
©
E
E
 
refactoring is expressed as:
(cid:3) D i (cid:4) all var def initions( V
) : uses( V , D i ) = (cid:2)
The function all var def initions( V
) looks up the en-
try for V
in the symbol table and returns all the de“nitions
of V
as a variable (note thatV
could be de“ned as a macro
in some con“guration, so the macro de“nition would not
be returned by this function). The function uses( V , D i )
returns the set of uses of de“nition D i of V
, again di-
rectly looking it up in the symbol table. So as long as
one de“nition of
has no uses, the refactoring can proceed.

Mechanics: If V
has more than one de“nition under dif-
ferent con“gurations, the refactoring must check which of
those de“nitions have no references and can be safely re-
moved. The following pseudo-code describes the mechan-
ics of this refactoring:

)

1. conds:= { guardingcondition(D i ) :
D i (cid:4) all var def initions( V
(cid:1) uses( V , D i ) = (cid:2) }
2. Search AST for nodes representing a de“nition or
declaration of V
. Upon a match:
if (guardingcondition(node) (cid:4) conds)
delete(node)
Step 1 creates a set condswith the conditions that guard
the de“nitions of
that have no uses. This result is again
directly returned by the symbol table, which attaches to
each de“nition the condition in which it applies.
This refactoring may leave a Cpp conditional branch
V was
empty, if the deleted de “nition or declaration of
the only thing in the branch. We leave the decision to the
user to apply the refactoring (cid:141)Delete empty branches of Cpp
conditional(cid:142), which, given a Cpp conditional, removes the
branches that are left empty.

4.2 Move variable into structure

A variable de“ned outside any structure is moved so that
it becomes a “eld of a structure. This refactoring is useful
when creating a structure out of global variables. The next
steps are to add a pointer reference to this structure and to
pass the pointer as argument to the functions, thus reducing
the use of global variables in the program.

Input values: variable V

and structure declarationS.

T rueC onditionmeans that the de“nition D S is not inside
a Cpp conditional.

guarding cond( DV
) = T rueC ondition)

sing le def inition( S )
(1)
( guarding cond( DS
) =
(2)
(cid:2) guarding cond( DS
(3)
(cid:1) V /(cid:3) f ields( DS
(4)
scope( DV
(cid:1) scope( DS
(5)
(cid:6) SV ar : ref ers( type ( SV ar ) , S )
(cid:3) uses( V )
(cid:5) u i
(cid:1) guarding cond( SV ar ) =
guarding cond( ui
(cid:1) scope( SV ar )
scope( DV

(6)

and D S is the single

where D V is the single de“nition of
de“nition of S.
The expression numbered (6) in the above equation
means that at each use of V
, there is a way to refer to
an instance of S, i.e., the type of S V ar is (cid:143) struct S(cid:144),
(cid:143) struct S *(cid:144), or similar.

Case 2. sing ledef inition( V
ing is allowed if:

) = f alse. The refactor-

( sing le def inition( S )
(cid:1) guarding condition( DS
) = T rueC ondition
(cid:3) all var def initions( V )
(cid:5) DV
( sing le def inition( S ) =
f alse
all var def s( V )
) = #
(cid:3) all var def s( V )
(cid:5) DV
guarding cond( DS
) =

all struct def s( S )
(cid:3) all struct def s( S )
(cid:6) DS
guarding cond( DV

That is, either there is a single de“nition of S and for each
de“nition of
, the sub-equations numbered (4), (5) and
(6) in Case 1 hold, or there are as many de“nitions of
as there are of S, and for each pair of de“nitions with the
same condition, the sub-equations (4), (5) and (6) hold.

Mechanics: the mechanics of Case 1 serve as a base case,
and S. Case
that is, when there is a single de“nition of
2 applies the mechanics of Case 1 for each appropriate
combination of variable-structure de“nitions.

Case 1. Given a de“nition of
S, D S :

, D V , and a de“nition of

Preconditions: the preconditions of this refactoring are di-
vided in two cases: 1. There is a single de“nition of
and
2. There are multiple de“nitions of
.
true.
sing ledef inition( V
Case 1.
In
) =
the preconditions given below, guardingcond(D S ) =

1. ASTS := {AST in scope of D S } .
2. Search ASTS for the node N DS representing D S .
3. Search ASTS for the node N DV representing D V .
if ( guardingcond(D S ) = guardingcond(D V ) )
4. Move N DV to the right-most leaf in N DS .

 21 s
(cid:144)05 )
1063-6773/05 

$20.00 

 2005 

I E

V
V
V
V
(cid:1)
)
)
)
(cid:4)
)
(cid:1)
(
:
)
(cid:4)
)
)
V
(cid:1)
(
:
(
4
)
(cid:1)
(
5
)
(cid:1)
(
6
)
)
)
(cid:2)
(cid:1)
#
(
(
)
(cid:1)
(
:
:
)
(cid:1)
(
4
)
(cid:1)
(
5
)
(cid:1)
(
6
)
)
)
V
V
V
V
P
r
o
c
e
e
d
i
n
g
s
 
o
f
 
t
h
e
t
 
I
E
E
E
 
I
n
t
e
r
n
a
t
i
o
n
a
l
 
C
o
n
f
e
r
e
n
c
e
 
o
n
 
S
o
f
t
w
a
r
e
 
M
a
i
n
t
e
n
a
n
c
e
 
(
I
C
S
M
 
©
E
E
 
else if (guardingcond(D S ) = T rueC ondition)
5.Move N DV to the right-most leaf in N DS and
surround it with a Cpp conditional with only one
branch for condition guardingcond(D V ) .
6. Search ASTS for uses of D V and replace each match
by a subtree representing ( tempSvar) . V
.
Step 1 creates a set with all trees in the scope of D S . This set
may have more than one element if D S is global, because
CRefactory builds one AST for each “le that composes the
program. If D S is local, CRefactory maintains indexes to
the trees so that it can directly reach the sub-tree for that
local scope.
In Step 6, tempSvaris a template that represents the
way to refer, directly or indirectly, to an instance of S, i.e.,
var (cid:144) or (cid:143)
*ptr)
it may have the form (cid:143)
(cid:144) or similar.

Case 2.

if (sing ledef inition(S) )
for each D V (cid:4) all var def initions( V
)
1. Apply Case 1 with D V and the single de“nition
of S.

else
for each D V (cid:4) all var def initions( V
) {
2. Find D S (cid:4) all structdef s(S) such that
guardingcond(D S ) = guardingcond(D V ) .
3. Apply Case 1 with D V and D S . }

5. Case studies

The previous section shows some of the analysis func-
tions that CRefactory uses to check the preconditions of
refactorings. This section provides a quantitative analysis
of the program representations built when two programs
were loaded in CRefactory: rm , the (cid:143)remove “le(cid:144) function
in GNU core utilities [1], andFlex , the lexical analyzer gen-
erator [4]. These metrics help us to show that, in practice,
conditional completion does not appear to produce an expo-
nential growth of the representation of programs.
CRefactory
is
implemented
in
VisualWorks
Smalltalk T M .
The refactoring engine mimics the de-
sign of
the Smalltalk Refactoring Browser [16].
To
load a program, CRefactory needs to know the source
“les,
include directories,
read-only directories (those
that contain non-modi“able “les,
like standard library
headers), command line macros and false conditions.
The set of (cid:141)false conditions(cid:142) is used by CRefactory to
exclude some Cpp conditional branches that
it should
not or cannot process. For example,
the set of false
conditions
includes defined(__cplusplus) and
defined(__GNUC__) because CRefactory cannot parse

C++ code and does not currently support some GCC exten-
sions [3] used in the code under defined(__GNUC__).

5.1. Results on rm

The source code for rm is contained in a single source
“le: (cid:141)rm.c(cid:142). When this source “le was loaded in CRefac-
tory, it included 94 header “les, although only 20 of them
belong to the same package and are therefore modi“able
(the others are GCC library headers). Note that this num-
ber of headers are included when considering all possible
con “gurations, only excluding false conditions. The results
that appear in Table 3 were obtained on the 20 “les in the
rm package, i.e., they “lter out GCC library headers.

Table 3. Metrics on rm

Number of Cpp conditionals
Number of Cpp conditionals introduced by
macro expansion
Number of incomplete Cpp conditionals
Perc. of code growth after completing
conditionals
Maximum level of nesting of Cpp conditionals
Percentage of conditional de“nitions

262
30

30
18%

3
24%

There is one header “le in the package: system.h, that
alone contains 166 out of the 262 Cpp conditionals. It con-
tains many macro de“nitions (31% of all macro de“nitions
in the package). We can infer that this “le is highly con“g-
urable and so, dif“cult to maintain.
From the total of 262 Cpp conditionals, 30 were intro-
duced by P-Cpp due to macro expansion (i.e., because of
calls to macros with more than one de“nition). All of these
Cpp conditionals and only those were incomplete. There-
fore, all Cpp conditionals present in the source code of the
rm package are complete, which speaks very well of the
readability of the source code. Moreover, 27 out of the 30
Cpp conditionals introduced by P-Cpp appear in a single
“le: rm.c. Since all of these conditionals had to be com-
pleted, the tokeni zed representation of rm.c grew 57% af-
ter conditional completion.
The depth of nesting of Cpp conditionals is low, so the
source code is not complex in that sense. However, the per-
centage of symbol de“nitions that depend on con“guration
variables (i.e., conditional de “nitions) is rather high. Con-
sidering all possible con “gurations simultaneously is there-
fore very important to be able to modify this code.
We found one symbol: getopt, de“ned as a function
under one con“guration and as a macro under another con-
“guration in a different header “le. Refactoring this sym-
bol or the code that uses it would be dif“cult without a tool

 21 s
(cid:144)05 )
1063-6773/05 

$20.00 

 2005 

I E

(
P
r
o
c
e
e
d
i
n
g
s
 
o
f
 
t
h
e
t
 
I
E
E
E
 
I
n
t
e
r
n
a
t
i
o
n
a
l
 
C
o
n
f
e
r
e
n
c
e
 
o
n
 
S
o
f
t
w
a
r
e
 
M
a
i
n
t
e
n
a
n
c
e
 
(
I
C
S
M
 
©
E
E
 
that can spot these double de“nitions and check for possible
problems.

5.2. Results on Flex

The source code for Flex is contained in 13 source “les.
However, 2 of them are automatically generated from gram-
mar speci“cations. Although loading Flex involved loading
54 “les, Table 4 shows the results obtained on the 11 source
“les that are not auto-generated plus the 4 headers in the
Flex package (i.e., all the modi“able “les).

Table 4. Metrics on Flex

Number of Cpp conditionals
Number of Cpp conditionals introduced by
macro expansion
Number of incomplete Cpp conditionals
Perc. of code growth after conditional completion
Maximum level of nesting of Cpp conditionals
Percentage of conditional de “nitions

36
9

9
1%
1
2%

The table above shows that the Flex package is not too
complex in terms of Cpp conditionals. As with the previous
case, all incomplete Cpp conditionals were introduced by
P-Cpp due to macro expansion.
The “les that have the most conditional directives are
flexdef.h, main.c and misc.c. File flexdef.h
has 15 Cpp conditionals, all present in the source code and
all complete. In the case of misc.c, 5 out of 7 Cpp con-
ditionals come from macro expansion. The tokenized rep-
resentation of misc.c grew 4% after conditional comple-
tion. The “le that grew the most was yylex.c, with a
growth of 7%.
There is no nesting of the Cpp conditionals in the Flex
package, although the maximum level of nesting is 23 when
counting library “les.
The total number of macros de“ned in the package is
134. There is one unreferenced variable in the package:
copyright, de“ned under condition ¬ def ined( lint) .

6. Related work

Som ·e and Lethbridge argue that program understand-
ing tools should provide information about each con“gu-
ration in which an entity can be considered [17]. They pro-
pose some heuristics to detect the con“gurations that can be
parsed in the same pass, therefore minimizing the number
of passes needed.
The framework PCp 3 [8] allows the analysis of C source
code with Cpp directives by providing (cid:141)hooks(cid:142) in the pre-
processor or in the parser. That is, the code is preprocessed

but the user can de“ne callbacks in Perl scripting language,
making use of those hooks in the preprocessor. PCp3 can
provide useful information about Cpp directives. However,
the program representations that PCp3 can produce would
still be based on a single con “guration and so inappropriate
for refactoring.
Tokuda and Batory propose a refactoring tool on class
diagrams of C++ programs [19]. Their tool also works on a
single con“guration. Xrefactory is a refactoring tool for C
and C++. It provides some support for Cpp directives, like
allowing macro renaming [7]. Xrefactory preprocess the
source code but saves the original position of each element
in the un-preprocessed code [20].
The best approximation to handle multiple con“gura-
tions is the one provided by DMS [9]. DMS is able to parse
conditional directives by allowing them at certain, prede-
“ned places in the grammar. With this approach, DMS can
parse 85% of un-preprocessed C “les [9]. DMS performs
code restructuring like removing dead branches of Cpp con-
ditionals by running a set of prede“ned rewrite rules on
appropriate program representations. Our goal is instead
to support interactive code manipulation through smaller
refactorings that are selected by the user with a drop-down
menu while visuali zing the code.

7. Conclusions

Integrating conditional directives during refactoring is
hard, for both the analysis of the code required before refac-
toring and the transformation functions themselves. The
same applies to other Cpp directives, like macros and “le
inclusion. This is a major factor that hinders the develop-
ment of refactoring tools for C or C++ code. Our work suc-
cessfully integrates Cpp directives in the C grammar and the
program representation.
Although CRefactory focuses on C and Cpp, our work
applies to other languages that use Cpp, like C++, and prob-
ably to other preprocessors with similar directives, whose
syntax is independent of the syntax of the underlying lan-
guage. Moreover, analysis tools should be able to apply the
same ideas for parsing and representation of Cpp condition-
als.
Future work includes loading all the source code of the
Linux kernel, for all possible con“gurations, and measure
memory requirements. For this, we will need to add all
GCC extensions to the C language. Also, other refactor-
ings will be added to CRefactory. Our ultimate goal is to
reach a stable version of CRefactory that we can release to
the public.

 21 s
(cid:144)05 )
1063-6773/05 

$20.00 

 2005 

I E

P
r
o
c
e
e
d
i
n
g
s
 
o
f
 
t
h
e
t
 
I
E
E
E
 
I
n
t
e
r
n
a
t
i
o
n
a
l
 
C
o
n
f
e
r
e
n
c
e
 
o
n
 
S
o
f
t
w
a
r
e
 
M
a
i
n
t
e
n
a
n
c
e
 
(
I
C
S
M
 
©
E
E
 
Acknowledgements

We would like to thank Prof. Samuel Kamin for his valu-
able comments on an earlier version of this paper.

References

[1] Coreutils - GNU Project - Free Software Foundation (FSF).
http://www.gnu.org/software/coreutils/coreutils.html.
[2] Eclipse.org main page. http://www.eclipse.org.
[3] Extensions to the C language family.
http://gcc.gnu.org
/onlinedocs/gcc/C-Extensions.html.
[4] Flex - GNU project - Free Software Foundation (FSF).
http://www.gnu.org/software/ ”ex/ ”ex.html.
[5] IntelliJ IDEA:
intelligent Java IDE around.
the most
http://www.intellij.com/idea/.
[6] Visual C# IntelliSense. http://msdn.microsoft.com/library
/default.asp?url=/library/en-
us/vsintro7/html/vxoriintellisensefeatures.asp.
[7] Xrefactory - A C/C++ development tool with refactoring
browser. http://xref-tech.com/xrefactory.
[8] G. J. Badros and D. Notkin. A framework for preprocessor-
aware C souce code analyses. Soft
ware Practice and Expe-
rience , 30(8), 2000.
[9] I. Baxter and M. Mehlich. Preprocessor conditional removal
by simple partial evaluation. In Workshop on Analy
sis, Slic-
the Eighth Working Conference
ing, and Transformation a t
, 2001.
on Reverse Engineering (WCRE(cid:144)01)
[10] P. Devanbu. Genoa - a customizable, front-end retargetable
source code analysis framework. ACM Transaction s on Soft-
, 9(2), 1999.
ware Engineering and Me thodology
[11] R. Ferenc, I. Siket, and T. Gyim ·othy. Extracting facts from
open source software. In 20th IEEE Int. Conf. on Soft
ware
, pages 60(cid:133)69, Chicago, Illinois, 2004.
Maintenance (ICSM)
[12] A. Garrido and R. Johnson. Challenges of refactoring C pro-
grams.
In M. Aoyama, K. Inoue, and V. Rajlich, editors,
Proc. of the Fifth Interna tional Workshop on Principles of
, pages 6(cid:133)14, Orlando, 2002.
Soft
ware E volu
tion (IWPSE)
ACM.
[13] A. Garrido and R. Johnson. Refactoring C with conditional
In Proceedings of the IEEE Au
compilation.
tomated Soft-
, pages 323(cid:133)326, Mon-
ware Engineering Conference (ASE)
treal, Canada, 2003.
[14] B. W. Kernighan and D. M. Ritchie.
The C Programming
. Prentice Hall, second edition, 1988.
Language
[15] W. Opdyke. Refactoring Object-Oriented Frameworks
. PhD
thesis, University of Illinois at Urbana-Champaign, 1992.
[16] D. Roberts, J. Brant, and R. Johnson. A refactoring tool
for Smalltalk. Theory and Practice of Object Sy
, 3(4),
tems
1997.
[17] S. Som ·e and T. Lethbridge. Parsing minimization when
extracting information from code in the presence of con-
In Six
ditional compilation.
th International Workshop on
, Ischia, Italy, 1998. IEEE.
Program Comprehension
[18] R. Stallman and Z. Weinberg. The C preprocessor. GNU On-
line documentation. http://gcc.gnu.org/onlinedocs/, 2001.
[19] L. Tokuda and D. Batory. Evolving object oriented designs
with refactoring. In Proc. IEEE Conference on Au
tomated
, 1999.
Soft
ware Engineering (ASE)

[20] M. Vittek. Refactoring browser with preprocessor.
7th European Conference on Soft
ware Main tenance and
, Benevento, Italy, March 2003.
Reengineering

In

Appendix

This Appendix shows the pseudo-code of the conditional
completion algorithm in P-Cpp and the pretty-printing that
reverses this completion. Figure 5 has the pseudo-code for
the “rst pass of P-Cpp through the code. Figures 6 and 7
show the second pass of P-Cpp. Finally, Figure 8 describes
pretty-printing.

case (current token = #if, #ifdef or #ifndef) {
desc:= new CppConditionalDescriptor.
desc . startP osition:= current position.
if( top(stateS tack) = End-of-construct)
desc . badS tart:= f alse
else {
desc . badS tart:= true.
desc . startP osShouldBe:=
(top(stateS tack)).startP osition.

} }
case (current token = #elif or #else) {
branch:= new CppConditionalBranchDescriptor.
branch. startPosition := current position.
Add branchto branchesof curr. Cpp conditional.

}
case (current token = #endif) {
desc:= current Cpp conditional.
desc . endP osition:= current position.
if( top(stateS tack) = End-of-construct)
desc . badEnding:= f alse.
else {
desc . badEnding:= true.
Add descto
(top(stateS tack)) . condsW BadEnding.

} }
case (curr. token marks beginning of construct) {
Push corresponding state intostateS tackwith
newS tate . startP osition:= current position.

}
case (curr. token marks end of curr. construct) {
for each desc(cid:4)
((top(stateS tack)) . condsW BadEnding)
desc . endP osShouldBe:= curr. position.
Push appr. construct ending state intostateS tack

}

Figure 5. Pseudo-code for ìrst pass of P-Cpp

 21 s
(cid:144)05 )
1063-6773/05 

$20.00 

 2005 

I E

s
P
r
o
c
e
e
d
i
n
g
s
 
o
f
 
t
h
e
t
 
I
E
E
E
 
I
n
t
e
r
n
a
t
i
o
n
a
l
 
C
o
n
f
e
r
e
n
c
e
 
o
n
 
S
o
f
t
w
a
r
e
 
M
a
i
n
t
e
n
a
n
c
e
 
(
I
C
S
M
 
©
E
E
 
completeConditional Branch (desc, branchDesc) {
if (desc . badS tart)
if (isFirstBranch(desc, branchDesc))
Move desc . tokensC ompletingS tart
to
beginning of branch while labelling these
tokens as (cid:143) moved forward(cid:144).

else
Copy desc . tokensC ompletingS tart
to
beginning of branch while labelling these
tokens as (cid:143) copied(cid:144).

for each childDesc(cid:4) children(desc, brachDesc)
completeConditional(childDesc).

if (desc . badEnding)
if (isLastBranch(desc, branchDesc))
Move desc . tokensC ompletingEndto
end of branch while labelling these
tokens as (cid:143) moved backwards(cid:144).

else
Copy desc . tokensC ompletingEndto
end of branch while labelling these
tokens as (cid:143) copied(cid:144). }

Figure 7. Second pass of P-Cpp: completing
Cpp conditional branches

pretty-print(node) {
case (noderepresents #if, #ifdef or #ifndef)
if ((assocCppConditional(node)).badS tart)
queue(if s Queue, node).
else Print node.
case (label(node) (cid:143) not moved(cid:144) or (cid:143) moved forward(cid:144))
Check if top( if s Queue ) should be printed.
Print node.
case (label(node) = (cid:143) copied(cid:144))
/* do nothing */
case (noderepresents #elif or #else)
Print node.
case (label(node) = (cid:143) moved backwards (cid:144))
queue(movedBack Queue, node).
case (noderepresents #endif) {
Print node.
Print nodes in movedBack Queue} }

Figure 8. Pseudo-code for pretty-printing

completeConditional(desc) {
if (desc . badS tart)
desc . tokensC ompletingS tart
:=
tokens from desc . startP osShouldBeto
desc . startP osition.
nextDesc:= nextConditional(desc).
if (breakSameConstruct(desc, nextDesc))
for each branch(cid:4) desc . branches
Complete nextDescinside branch.
else if (desc . badEnding) {
if (¬ intersect(desc, nextDesc))
desc . tokensC ompletingEnd:=
tokens from desc . endP ositionto
desc . endP osShouldBe.

else
Complete nextDescinside
desc . tokensC ompletingEnd
.
for each branch(cid:4) desc . branches
completeConditionalBranch (desc, branch).

} }

Figure 6. Second pass of P-Cpp: completing
Cpp conditionals

 21 s
(cid:144)05 )
1063-6773/05 

$20.00 

 2005 

I E

P
r
o
c
e
e
d
i
n
g
s
 
o
f
 
t
h
e
t
 
I
E
E
E
 
I
n
t
e
r
n
a
t
i
o
n
a
l
 
C
o
n
f
e
r
e
n
c
e
 
o
n
 
S
o
f
t
w
a
r
e
 
M
a
i
n
t
e
n
a
n
c
e
 
(
I
C
S
M
 
©
E
E
 
The Role of Refactorings in API Evolution

Danny Dig and Ralph Johnson
Department of Computer Science
University of Illinois at Urbana-Champaign
201 N. Goodwin
Urbana, IL 61801, USA
{ dig, johnson } @cs.uiuc.edu

Abstract

Framework s and librarie s change their API s. Migra t-
ing an applica tion to the new API is
s and disrup t
tedio u
s. Altho ugh some tools and idea s
the developmen t proce s
tion of API s, mo s
ha ve been propo sed to solve the evolu
upda te s are done man ually. To be t
ter unders
tand the re-
q uiremen t
we s
s for migra tion tools
udied the API change s
of three framework s and one library. We di scovered tha t
tha t break exis
the change s
ting applica tion s are no t ran-
dom, bu
they
tend to fall in to particular ca tegories. Over
ugge s
80% of the se change s are refac toring s. This
tha t
refac toring-ba sed migra tion tools
sho uld be u
sed to upda te
applica tion s.

1. Introduction

Part of maintaining a software system is updating it to
use the latest version of its components. Developers like to
reuse software components because it lets them build a sys-
tem more quickly, but then the system depends on the com-
ponents that they reused. Ideally, the interface to a com-
ponent never changes. In practice, new versions of soft-
ware components often change their interfaces and so re-
quire systems that use the components to be changed before
the new versions can be used.
Software evolution has long been a topic of study [17].
Others [5, 20] have focused on wh y
software changes; we
want to discover ho w
it changes. Our goal is to red uce the
on maintenance. This requires either reduc-
burden of re u
se
ing the amount of change or reducing the cost of adapting
to change.
Component developers do not want to learn a new lan-
guage or write extra speci“cations for a component. Ap-
plication developers want an easy (push-button) and safe
(behavior-preserving) way to update component-based ap-
plications. This paper is our quest to meet the needs of both

component and application developers. What is a suitable
representation for the changes that happened in a compo-
nent? Can it be gathered automatically? Does this represen-
tation carry both the syntax and the semantics of changes?
Can it lead to safe, automatic updating of component-based
applications? How much of the effort spent on updating
component-based applications can be saved?
Although there are principles of software evolution that
are true for software in any language, programming lan-
guages have an impact on software evolution. We are par-
ticularly interested in the evolution of object-oriented com-
ponents (we refer to both library and framework as com-
ponent, unless a distinction is necessary). Classes contain a
mixture of private and public methods. The public methods
are the ones that are meant to be used by application pro-
grammers. The set of public methods of a class library make
up its API (Application Programmer Interface). Changes to
private methods and classes do not pose a problem to appli-
cation developers; they only care about changes to the API.
An important kind of change to object-oriented software
is a refactoring[9]. Refactorings are program transforma-
tions that change the structure of a program but not its be-
havior. Refactorings include renaming classes or methods,
moving methods or variables between classes, and splitting
methods or classes. A refactoring that changes the interface
of an object must change all its clients to use the new in-
terface. When a class library that is reused in many systems
is refactored, the systems that reuse it must change. But of-
ten those developing the library do not know all the systems
that reuse it. The new version of the library is a refactor-
ing from their point of view, but not from the point of view
of the application developers who are their customers.
The original work on refactoring was motivated by
framework evolution. Opdyke [22] looked at the Choices
operating system and the kind of refactorings that occurred
as it evolved. Graver [13] studied an object-oriented com-
piler framework as it went through three iterations. Tokuda
and Batory [26] describe the evolution of
two frame-

Proceedings  of  the  21st  IEEE  International  Conference  on  Software  Maintenance  (ICSM (cid:144)05)  
1063-6773/05 $20.00 
 2005 

s
t
t
t
s
t
s
©
I
E
E
E
 
works, focusing on how large architectural changes can be
accomplished by a sequence of refactorings.
However, none of these studies determined the fraction
of changes that are refactorings. Of the changes that cause
problems for maintainers, what fraction are refactorings?
Are refactorings as important in practice as these authors
imply? The authors all discuss tool support, though usually
from the point of view of a component developer, not of
a component reuser. However, CatchUp [14] is a tool that
uses descriptions of refactorings to help application devel-
opers migrate their applications to a new version of a com-
ponent. How much of the component evolution can be ex-
pressed in terms of refactorings? The only way to tell is to
look at changes in a component over time and categorize
them.
In this paper, we look at three frameworks and one li-
brary (see Table 1 and Section 2) developed by four dif-
ferent groups. Three are commonly used open source and
one is a proprietary framework. All the case studies are ma-
ture software, namely components that have been in pro-
duction for more than three years. By now they have proven
themselves to be useful and therefore acquired a large cus-
tomer base. At this stage, API changes have the potential to
break compatibility with many older applications.

Si ze(KLOC)
API Classes
BreakingChanges
ChangeLogs

Eclipse Mortgage
3.0
1,923
2,579
51
24

52
174
11
-

Struts
1.2.4
97
435
136
16

log4j
1.3
62
349
38
4

Table 1. Size of the studied components.
The number of classes in API denote only
those classes that are meant to be reused.
ChangeLogs give the size (in pages ) of docu-
ments describing the API changes. The logs
were provided by the component developers.

We analy ze and classify the API changes in the four
systems (Section 3). Some API changes like expansion of
the component through addition of new classes and meth-
ods will not affect existing users. We discard these type
of API changes and only focus on the API changes that
break compatibility with older applications. We learned that
for the four systems we studied, respectively 84%, 81%,
90% and 97% of the API breaking changes are refactor-
ings. Most API changes occur as responsibility is shifted
between classes (e.g., methods or “elds moved around) and
collaboration protocol changes (e.g., renaming or changing

method signature). These results made us believe that refac-
toring plays an important role as mature components evolve.

2.

Overview of the Case Studies

This section describes brie ”y the components that we
used as case studies. We chose well known frameworks and
libraries from both proprietary and open source realm in or-
der to check whether the production environment affects the
type of API changes. We were unbiased in the selection of
the case studies, only concern being that the systems have
decent documentation.
For each component we chose for comparison two major
releases that span large architectural changes. There are two
bene “ts to choosing major releases as comparison points.
First, it is likely that there will be lots of changes in between
the two versions. Secondly, it is likely that those changes
will be documented thus providing some starting point for
a detailed analysis of the API changes.

2.1. Eclipse Platform

Eclipse [eclipse.org] was initially developed by IBM and
later released to the open source community. The Eclipse
Platform provides many APIs and many different smaller
frameworks. The key framework in Eclipse is a plug-in
based framework that can be used to develop and integrate
software tools. This framework is often used to develop In-
tegrated Development Environments (IDEs). The Eclipse
Platform is written in Java.
We chose two major releases of Eclipse, namely 2.1
(March 2003) and 3.0 (June 2004). Eclipse 3.0 came with
some major themes that affected the APIs. The re spon sive-
theme ensured that more operations run in the back-
ne s
ground without blocking the user. New APIs allow long-
running operations like builds and searches to be performed
in the background while the user continues to work.
Another major
theme in 3.0 is rich-clien t
pla t-
forms . Eclipse was designed as a universal IDE. However
many components of Eclipse are not particularly spe-
ci “c to IDEs and can be reused in other rich-client ap-
plications (e.g. plug-ins, help system, update manager,
window-based GUIs). This architectural theme involved
factoring out IDE-speci “c elements. APIs heavily af-
fected by this change are those that made use of the “lesys-
tem resources. For instance I Wor k
bench Page
is an
interface used to open an editor for a “le input. All meth-
ods that were resource speci “c (those that dealt with
opening editors over “les) were removed from the inter-
face. A client who opens an editor for a “le should con-
vert it “rst to a generic editor input. Now the interface can
be used by both non-IDE clients (e.g. a mail client that ed-
its the message body) as well as IDE clients.

Proceedings  of  the  21st  IEEE  International  Conference  on  Software  Maintenance  (ICSM (cid:144)05)  
1063-6773/05 $20.00 
 2005 

s
©
I
E
E
E
 
2.2. Mortgage Framework

A large banking corporation in the Midwest has been
building a Mortgage framework to leverage existing “nan-
cial expertise when writing new applications.
The Mortgage framework allows various banking appli-
cations developed within the company to communicate with
each other and with the existing legacy systems. The frame-
work receives requests from front-end systems or services,
evaluates their requirements and redirects the request to a
speci “c destination, or destinations such as a pricing engine
or closing cost engine. After receiving an appropriate re-
sponse, the framework re “nes it for a speci “c request chan-
nel and then forwards it back to the requestor.
When we visited the banking institution, they were “nal-
i zing the integration between th e mortgage framework and
another middleware framework developed independently at
another branch of the bank. Frameworks are designed for
extension not for integration [18]. As a result of the mar-
riage between the two frameworks, the application devel-
opers had to migrate the existing services. The company
reported that the whole integration and upgrading process
lasted a summer. At the time we write this, there are about
50 services that use the framework.

2.3. Struts Framework

Struts [struts.apache.org] is an open source frame-
work for building Java web applications. The framework
is a variation of the Model-View-Controller (MVC) de-
sign paradigm. Struts provides its own Controller compo-
nent and integrates with other technologies to provide the
Model and the View.
For the Model, Struts can interact with standard data
access technologies, like JDBC and EJB, as well as most
any third-party packages, like Hibernate, iBATIS, or Ob-
ject Relational Bridge. For the View, Struts works well with
JavaServer Pages, as well as Velocity Templates, XSLT, and
other presentation systems. Because of this separation of
concerns, Struts can help control change in a Web project
and promote job speciali zation.
We chose for comparison version 1.1(June 2003), a ma-
jor past release, and 1.2.4 (September 2004), the latest sta-
ble release. All the API changes reveal consolidation work
that was done in between the two releases. The frame-
work developers eliminated duplicated code and removed
unmaintained or buggy code.

2. 4.

log4

Library

log4j [logging.apache.org/log4j/] is a popular Java li-
brary for enabling logging without modifying the applica-
tion binary. It allows the developer to control which log

statements are output with arbitrary granularity by using ex-
ternal con “guration “les. Logging does have its drawbacks.
It can slow down an application. If too verbose, it can cause
scrolling blindness. To alleviate these concerns, log4j is de-
signed to be reliable, fast and extensible.
log4j uses a logger hierarchy to control which log state-
ments are output. This helps reduce the volume of logged
output and minimize the cost of logging. The target of the
log output can be a “le, an OutputStream, a java.io.Writer,
a remote log4j server or a remote Unix Syslog daemon log-
ger among many other output targets.
We chose for comparison version 1.2 (May 2002) and
version 1.3alpha6 (January 2005). The library passed
through an expansionary phase and it grew from 30KLOC
to 62KLOC. The library grew by improving on exist-
ing components (like Chainsaw, a visualization toolkit for
loggers) or adding new components (like support for plug-
ins as a way to extend the library).

2.5. Collecting the Data

Our case study components are considered medium to
large size (Mortgage is 50 KLOC, Eclipse is roughly 2 mil-
lion LOC). To tackle the API changes in such large sys-
tems we could have used tools. For instance, Demeyer et al.
[8] describe how they used metrics tools to discover refac-
torings. However, because of preserving backward compat-
ibility, most API changes don (cid:144)t happen overnight but follow
a long deprecate-replace-remove cycle. Therefore an obso-
lete API can coexist with the new API for a long time. This
introduces enough noise that tools might mislead us about
the exact kind of change that happened.
Consider for instance a change such as renaming class
Category to class Logger
in log4j. In order to main-
tain compatibility with old clients, class Logger
(the new
name) inherits from class Category . The constructor of
Category became protected so that users can (cid:144)t create cat-
egories directly but invoke instead the creational method
getInstance (
. This method returns instances of the
new class Logger . Any method in Category that re-
turned an object of type Category became deprecated.
Clients should replace all the references toCategory with
references to Logger . The two classes still coexist, but
Category will be deleted eventually. Such a three-step
change would have been misinterpreted by a tool, but a hu-
man expert can easily spot this as a renaming.
For these reasons, we chose instead to do a manual anal-
ysis of the API changes. Even for the larger components,
this was feasible because we started from the change logs
that describe the API changes for each release. For Eclipse
we used its help system 1 , the documents called (cid:141)Incompat-

1

Section: Eclipse 3.0 Plugin Migration Guide

Proceedings  of  the  21st  IEEE  International  Conference  on  Software  Maintenance  (ICSM (cid:144)05)  
1063-6773/05 $20.00 
 2005 

j
)
©
I
E
E
E
 
ibilities between Eclipse 2.1 and 3.0 (cid:142) and (cid:141)Adopting 3.0
mechanisms and API (cid:142). For Struts we studied the (cid:141)Release
Notes(cid:142) for version 1.2.4 2. For Log4J we studied (cid:141)Prepar-
ing for log4j version 1.3 (cid:142) 3 .
Sometimes the documents would be vague, reading for
example (cid:141)method M in class X is deprecated (cid:142). Because of
the deprecate-replace-remove cycle many types of changes
are masked by the deprecation mechanism. In those cases
we read and compared the two versions of the source code
in order to discover the intent behind the deprecation. When
a method is deprecated it merely delegates to its replace-
ment method. By reading the code we learned whether the
new method is just a renaming of the deprecated method,
whether the intent was to move the method to another class
or whether the deprecated method was replaced by a seman-
tically equivalent method that offers better performance.

For the Mortgage framework we interviewed the frame-
work and application developers and then studied the source
code. We classi “ed all the breaking API changes from the
case studies into structural and behavioral changes (qualita-
tive analysis), then we recorded how many times each type
of change occurred (quantitative analysis).

The current tool support [8, 28, 1, 12] for detecting and
classifying structural evolution is very limited: only a few
types of refactorings (mostly merging and splitting) were
attempted to be detected. Therefore, to do a comprehensive
qualitative analysis of the breaking changes, manual method
seems the only alternative. We double-checked our quanti-
tative analysis by using a tool (Van [11]) and heuristics (like
in [8]). For each type of refactoring, we wrote queries in Van
that return those structures suspected of that speci “c refac-
toring. For instance, to detect changes in method param-
eters(cid:144) types, we searched for methods that have the same
name in both versions of a class, have the same number of
arguments, have the same return type but have different sig-
nature. After analy zing and eliminating the false positives,
the remaining candidates were found among those that were
already detected from the change logs. Van found a few
other places suspected of refactoring, but the number is less
than 4% of those detected by starting from the change logs.
Also Van failed to detect some places where a certain refac-
toring took place. This happened because of the noise in-
troduced by the deprecate-replace-remove cycle described
above. We could only cross reference our results for Struts
and log4j. The tool did not scale up for Eclipse and we do
not own the source code of the proprietary Mortgage frame-
work.

3.

How APIs Change

This section describes the API changes that occurred in
the four case studies. The “rst subsection talks about APIs
and what does it mean for an API change to break compat-
ibility with applications. The subsection B RE AK ING AP I
CHANGE S presents the empirical data gathered from the
breaking changes we noticed in the case studies. The fol-
lowing subsections analy ze in detail two kinds of break-
ing changes, namely semantics-preserving changes (struc-
tural changes) and semantics-modifying changes (behav-
ioral modi“cations).

3.1. API Changes and Compatibility

An API is the interface that a component provides to ap-
plication developers and its description is part of the compo-
nent (cid:144)s documentation. The term has been extended to mean
any component that is supposed to be reused by clients and
thus is expected to be stable.
APIs make use of the visibility rules of the language
in which the component was implemented. For instance in
Java or C++ only members that are declared public or pro-
tected can be part of the API. However, not all classes or
class members that are public are intended to appear in
client code.
Usually there are no language features that distinguish
between public entities that are intended to be part of the
API and public entities that are not. Naming conventions
can be used to identify those components that are (cid:141)pub-
lished (cid:142) (to be reused) from those components that are (cid:141)pub-
lic (cid:142) but are not intended to be reused [7]. For instance,
Eclipse places a public class that is not API in a pack-
age with (cid:141)internal (cid:142) as a pre “x. Such a class is fair game
to change without notice.
Over time, changes are made to APIs or APIs(cid:144) behav-
ior. Depending on whether or not they are backwards com-
patible, API changes can be classi“ed as N ON - BRE AK ING
AP I C HANGE S or BRE AK ING AP I C HANGE S .
A breaking change is not backwards compatible. It
would cause an application built with an older version of
the component to fail under a newer version. If the prob-
lem is immediately visible, the application fails to compile
or link. Or the application might compile “ne, but behave
differently at runtime. By behavior we mean functional be-
havior, e.g. the set of observable outputs for a given set of
inputs. If the only observable difference is that an applica-
tion is slightly faster or slower or has a different memory
footprint, we do not consider it a breaking change4.
A non-breaking change is backwards compatible. Such
a change can be an enhancement like addition of new mod-

2
3

http://struts.apache.org/userGuide/release-notes-1.2.4.html
http://www.qos.ch/logging/preparingFor13.jsp

4 We go with a loose de“nition of failure but in domains like embedded
systems, our notion of reliability might not be suf“cient

Proceedings  of  the  21st  IEEE  International  Conference  on  Software  Maintenance  (ICSM (cid:144)05)  
1063-6773/05 $20.00 
 2005 

©
I
E
E
E
 
ules to extend the functionality of the component. Or it can
be a performance optimi zation or an error removal.
A seemingly non-breaking change such as “xing a bug in
the component might be a breaking change. If the applica-
tion developers worked around the bug, then when the bug
is removed from the component, the application might be-
have differently.
Although there are a number of techniques used to facil-
itate component changes without breaking the clients[23],
breaking API changes happen all the time. Our goal is
to provide migration tools that can incorporate breaking
changes. The next section focuses on these changes.

3.2.

Breaking API Changes

From anecdotal experience with components we noticed
that breaking changes are perceived as extremely disturb-
ing in the development life cycle of component-based ap-
plications. The application engineers might be in the mid-
dle of development when the introduction of an updated
component could adversely affect costs and schedules. Un-
less there is a high return-on-investment, application devel-
opers will not want to migrate to the new version of the
component[16].
Table 2 lists the types of B RE AK ING AP I CHANGE S
that we observed in the components that we studied. The
“rst column identi“es the type of change. Those changes in
italic font are refactorings. The remaining columns give the
number of times each type of change occurred in the com-
ponents. Columns Eclipse* (E*) and Struts* (S*) deal with
(cid:141)recommended (cid:142) changes. Component designers marked
these as changes that will be enforced in the next ma-
jor release. Even though technically these are not break-
ing changes for the current release (they were insulated
by the deprecation mechanism), we included them to of-
fer the trend of breaking changes that are coming in next
versions. Based on how many times each type of change oc-
curred, we sorted the rows so that most popular changes
appear “rst.
The next two sections categori ze the changes in Ta-
ble 2 according to how they affect the semantics of the
component. The structural transformations are semantic-
preserving changes (refactorings) while the behavioral
changes are semantic-modifying.

3.3. Structural Transformations

Next we describe the types of structural changes that we
noticed in the studied components (Table 2). We describe
the changes that occurred in the component instead of giv-
ing prescriptions about how one developer should migrate
to the new version.

Type of change
Moved Method
Moved Field
Dele ted Me thod
ChangedArg umen tType
Renamed Me thod
Replaced Me thod Call
New Hook Me thod
E x
tra Arg umen t
Deleted Cla s
Renamed Field
Changed Re t
urn Type
Renamed Cla s
Me thod Objec t
shed Do wn Me thod
Moved Cla s
P ulled Up Me thod
New Method Contract
Impl.New Interface
Changed Event Order
New Enum Constant

P u

E
16
-
2
5
4
1
4
3
-
-
2
-
3
3
-
-
3
1
3
1

E* M S
11
-
13
18
-
45
2
-
24
18
4
-
16
-
-
8
-
20
7
2
2
2
2
1
9
-
-
6
-
-
2
1
-
1
-
2
-
-
-
-
-
-
-
-
2
-
-
1
8
1
12
5
1
-
-
-
-
-
-
-

S*
28
2
32
4
5
4
-
1
-
1
-
-
-
-
-
-
-
-
-
-

9
5
-
11
8
-
-
-
-
-
2
2
-
-
-
-
1
-
-
-

Table 2. Types of
B RE AK ING AP I CHANGE S
and the number of these changes in Eclipse
, Struts (S) and log4j (L ).
, Mortgage (M)
(E)
Eclipse*
(E*
) and Struts*
(S*
) denote recom-
mended changes , that is changes that will
become breaking changes in future releases.
Those changes in italic font (upper half of the
table) are refactorings.

To improve reusability and maintainability of the com-
ponent, the code is restructured (refactored). Refactorings
affect only the structure of the code and are meant to pre-
serve the functional behavior of the component. Consider
for instance what happens when a method is renamed.
Component designers rename an instance method in the
component. They “nd and update all the callers and imple-
mentors of the method to re ”ect the new name. For the
component itself this change is safe and does not mod-
ify its behavior. However, remote applications that call the
renamed method are broken. Thus a behavior-preserving
change (refactoring) for the component might lead to a
breaking change for the application.
Most times application code is not available to compo-
nent developers when they make structural changes. The
result is that applications might not compile with the new
version of the component. Once the application developer
solves the compile errors, the application (cid:144)s behaviour is the
same (structural changes do not introduce new behavior).

Proceedings  of  the  21st  IEEE  International  Conference  on  Software  Maintenance  (ICSM (cid:144)05)  
1063-6773/05 $20.00 
 2005 

L
s
s
s
©
I
E
E
E
 
M OVED M E THOD . The most common way that instance
methods moved in Eclipse is by becoming static methods.
The rationale was to move the layer breaking methods into
utility classes to preserve the convenience of the old meth-
ods. Usually the moved method will take the old home
class as an extra argument. This will ensure that the moved
method can access public members in the old home class.
In Struts, instance methods remain instance methods af-
ter they move to other classes. Old callers of the method ask
a factory method for an instance of the new home class and
then call the moved method. Other ways that methods got
moved are variations of the Move Method refactoring de-
scribed by Fowler[9].
M OVED FIE LD . Encapsulation requires that the variables
that characteri ze the state of an object are not exposed.
However, sometimes “elds are publicly exposed either be-
cause of convenience or because they represent constants.
When “elds are placeholders for global constants usually
they are declared as static “elds. In Eclipse, Struts and log4j
only “elds that were constants moved to another home class.
DE L E T ED M E THOD . Typically this happens after a method
is renamed or moved to another class. For compatibility rea-
sons, component producers support both the old and new
method for a while. After all the references to old method
were replaced, the method is deleted since it (cid:144)s a remnant of
the obsolete API.
CHANGED A RGUMEN T T Y P E . We observed several kinds
of argument type changes.

1. The type of a method argument is replaced with its su-
pertype to make the method more general. This change
may or may not break an existing application depend-
ing on whether the application calls any methods that
are not visible through the supertype (cid:144)s interface.
2. The type of method argument is replaced by another
type while the relationship between the two is ag-
gregation. This is often the case when replacing a
primitive type with an object type (e.g. in Java re-
place in t with In teger ). Another special case is re-
placing a type with a collection that contains sev-
eral elements of the previous type. In order to regard
these changes as automated refactorings, one needs to
know how to access the member from the wrapper and
how to get the proper wrapper for a member. In the
Mortgage framework the method process (String
message )
changed to process (
Envelope e )
encapsulating the message
with Envelope
. Callers
of process (
will have to pass an Envelope instead
which is obtained from a factory method. The imple-
mentors of process (
should augment their imple-
mentation to match the new type. They will “rst obtain
the String message out of the Envelope.

R ENAMED M E THOD , R ENAMED CL A S S and RENAMED
FIE LD are used to give intention revealing, self-explanatory
names to methods, classes and class “elds. These refactor-
ings are well described in refactoring catalogs (see [9]).
R E P L ACED M E THOD CA L L . The clients of a method
should call another method that is semantically equiv-
alent and is offered in the same class. When there
to the original method,
are no more callers
it
is
usually deleted.
In Struts
for
example, clients of
FieldChec ks.validateRange (... )
should call
instead FieldChec ks.validateIntRange (... )
.
N EW HOOK M E THOD . Component producers factor out
a method to provide (cid:141)hot spots(cid:142) that are to be speciali zed
by subclasses (see Template Method in [10]). They add
a new hook method in the super class (usually as an ab-
stract method) that all non-abstract subclasses must over-
ride. We illustrate this with an example from Struts. Method
validate (
in class Validator For m
calls the newly
introduced method get Validation Key (
:

pu blic Action Errors validate (
ActionMapping mapping ,
HttpServletRe quest re quest )

...
String validation Key =
get Validation Key (
mapping , re quest )

...

pu blic String get Validation Key (
ActionMapping mapping ,
HttpServletRe quest re quest )
return mapping.get Attri bute (

Subclasses override get Validation Key (
to pro-
vide the desired behavior. It might happen that an existing
subclass already has a method with the same signature as
the newly introduced hook method. In this case the method
provided by the inheritor gets captured by the parent class
even though the inheritor did not intend this (see Method
Capture in [25]). Using a refactoring tool to perform this
change would warn one when method capture happens.
E X T RA A RGUMEN T . Often two methods signatures are
very similar, they only differ by an argument. The two meth-
ods do similar things but one method can do extra things
by making use of the extra argument. When eliminating
duplicated code, usually the method with fewer arguments
will be replaced by the one with more arguments. For the
call sites of the displaced method, this change appears as if
the method gained one more argument. The callers of the
old method with fewer arguments will have to call the new
method and pass a default value for the extra parameter.

Proceedings  of  the  21st  IEEE  International  Conference  on  Software  Maintenance  (ICSM (cid:144)05)  
1063-6773/05 $20.00 
 2005 

)
)
)
)
{
;
}
{
)
;
}
)
©
I
E
E
E
 
Developers of the Mortgage framework decided that
database connections should be reused from a connection
pool rather then being created every time a database oper-
ation was required. In order to persist an object one would
call the following method in the framework:
boolean persist (
ject )
BusinessO b
Inside persist method a database connection would
be created. The later version of this method looks like:
ject ,
BusinessO b
boolean persist (
D BConnection )
When a web service calls this method it will pass along
an existing database connection (in case that it owns one).
When the null object is passed, the persist method will
create a connection on the ”y.
D E L E T ED CL A S S . Component producers delete a class
when it is no longer supported or maintained due to lack
of resources or because the implementation is too buggy.
In Struts several classes acted like containers for particu-
lar objects. The container (cid:144)s name would suggest that it con-
tains objects of a certain kind(e.g. ActionMappings holds
a collection of ActionMapping objects). In a later version
the containers are superseded by general-purpose collection
classes and then deleted.
CHANGED R E TURN T Y P E . This change is very simi-
lar to CHANGED A RGUMEN T T Y P E . We observed one in-
teresting type change in Eclipse. The return type of
I Java Brea kpoint Listener. brea kpointHit (
was changed from boolean to integer to allow listen-
ers to vote (cid:141)don (cid:144)t care (cid:142) in addition to (cid:141)suspend (cid:142) and
(cid:141)don (cid:144)t suspend (cid:142). A refactoring tool can only swap primi-
tive types if there is a translation map between the values
of the two different types.
M E THOD O B J EC T . This is a variation on Method Object
described by Beck [4] and we (cid:144)ll illustrate it with an example
bstractDocu ment Provider
from Eclipse. In class A
the modi“er of saveDocu ment (
method changed to (cid:147)-
nal so that subclasses cannot override it anymore. A new
method called doSaveDocu ment (
was introduced
and all the code from saveDocu ment (
moved to the
new method. A Docu ment ProviderOperation
object offers an execute (
method
that
dele-
to doSaveDocu ment (
new imple-
. The
gates
saveDocu ment (
mentation
of
creates
an
in-
the Docu ment ProviderOperation
stance
of
its execute (
and then calls
method. All previ-
ous implementors of saveDocu ment (
must override
doSaveDocu ment (
instead.
PU SH ED DOWN M E THOD . A service is no longer offered
by the superclass but only by subclasses. Thus we say that
the corresponding method was pushed down in the class hi-
erarchy.

,

What changes
Precondition
Precondition
Postcondition
Postcondition

How
weaken
strengthen
weaken
strengthen

Callers
compatible
broken
broken
compatible

Implementors
broken
compatible
compatible
broken

Table 3. Effects of Changing Method Contract
on Callers and Implementors

M OVED CL A S S . A class is moved to a different package in
order to increase the cohesiveness of that package.
PU L L ED U P M E THOD . A method is moved in the parent
class so that everyone can take advantage of the superclass
logic.

3. 4.

Behavioral Modi“cations

We saw that structural transformations preserve the be-
havior of the component but might cause applications to
fail to compile. In contrast, behavioral modi“cations in the
component might cause the application to compile “ne with
the new version. However, the application won (cid:144)t behave the
same since the new version uses different assumptions.
N EW M E THOD CON T RAC T . A contract is an agreement
between the method provider and its clients [21]. The pre-
condition is what the method assumes to be true before ex-
ecution. A postcondition is what a method guarantees to be
true after the method body has executed successfully (pre-
suming that the precondition holds). In frameworks, due to
extensive usage of callbacks (hook methods), with regard
to contracts we must consider two types of method clients:
callers and implemen tors
.
Des Rivieres [23] shows the effect of strengthening or
weakening preconditions and postconditions on clients of
a method in Table 3. The “rst column identi “es what part
of the contract changes. The second column gives the di-
rection of change: strengthening or weakening the contract.
The next two columns show whether the change is back-
wards compatible or it breaks existing method clients.
Consider the following method offered by the Collection
interface:
@para m coll a non -null Collection
pu blic boolean add All (Collection coll )

Designers think about weakening the precondition so
that it is acceptable to pass a null object. The callers of this
method are not affected. However, an implementor like the
one below will throw a Null Pointer Exception
when
it sends si ze (
message to a null object:
pu blic boolean add All (Collection coll )

Proceedings  of  the  21st  IEEE  International  Conference  on  Software  Maintenance  (ICSM (cid:144)05)  
1063-6773/05 $20.00 
 2005 

)
)
)
)
)
)
)
)
)
)
/
*
*
*
/
;
)
{
©
I
E
E
E
 
/an i mple mentation
int si ze = coll.si ze (
....

If the precondition were strengthened (e.g. passed col-
lection should not be shorter than a threshold), some exist-
ing callers of the method might not ful“ll the requirements
thus causing some faulty behavior. The existing implemen-
tors will not be affected since they assumed less than what
is offered now.
IMP L EMEN T N EW IN T E RFACE . Developers of the compo-
nent replace the interface implemented by a class with a dif-
ferent interface (with different contracts). Or they add a
new interface to the ones a class already implements. In
Struts, the latest version of class La bel Value Bean
im-
plements a new interface, namely Co mpara ble
. The
class now overrides methods co mpareTo (O b
ject )
,
e quals (O b
and hashCode (
ject )
. Older appli-
cations that compared instances of this class for equal-
ity might behave differently now that the class provides its
own way for equality checks.
CHANGED E VEN T S O RDE R . Similar to orchestra conduc-
tors, frameworks control the code contributed by applica-
tions. Usually the applications just respond when the con-
ductor gives them the signal to participate. When the ap-
plication make assumptions about the order in which the
events are generated it is fallible to any change in the se-
quence of events. For instance in Eclipse 3.0, selection
of items in tables and trees generates the event sequence
MouseDown-Selection-MouseUp. In version 2.1 the event
order was different under some platforms with Selection
event being generated “rst, i.e. the sequence Selection-
MouseDown-MouseUp.
N EW ENUME RAT ION
change af-
CON S TAN T . This
fects clients that rely on the set of all possible “elds in
an enumeration. In Eclipse 2.1, IStatus is an enumera-
tion with four constants: OK, INFO, WARNING and ER-
ROR. Some clients used a switch case statement to check
all the values of an enumeration. They treated the ER-
ROR case in the defa ult
branch of
the switch state-
ment. Eclipse 3.0 adds a new constant, namely CAN-
CEL. When CANCEL is passed around, the old clients will
trap the new constant in their defa ult
branch thus treat-
ing it like the ERROR case.
M I SCE L L ANEOU S . Besides API changes there are other
types of changes that may cause component-based appli-
cations to malfunction. Some of these changes might be:
deployment changes, classloader order changed, changes
to build scripts and other con “guration “les, data format
and interpretation changes. We noticed changes in the XML
con “guration and metadata “les in all three studied frame-
works. However, these are beyond the scope of this paper.

Component
Eclipse
Eclipse*
Mortgage
Struts
Struts*
Log4J

Breaking Changes
51
99
11
136
77
38

Refactorings
84%
87%
81%
90%
100%
97 %

Table 4. Ratio of refactorings to all breaking
API changes. Eclipse* and Struts* denote rec-
ommended changes.

Refactorings
All Other API Changes
Percentage of Refactorings
Impact of Refactorings

Struts
Log 4
123
37
325
920
27.4% 3.8%
90%
97%

Table 5. The impact of refactorings upon
backwards compatibility

Table 4 is a summary of Table 2. The “rst column lists
the components we studied. As we did in Table 4, Eclipse*
and Struts* denote recommended changes, that is changes
that will become breaking changes in the next release. The
second column gives the total number of breaking API
changes (both structural and behavioral). The last column
shows how many of the breaking API changes are refactor-
ings.
Our “ndings suggest that most API breaking changes are
small structural changes. This makes sense because large
scale changes lead to clients abandoning the component.
For a component to stay alive, it should change through a
series of rather small steps, mostly refactorings.
For Struts and log4j we analy zed what percentage of all
API changes (including addition of new API) are repre-
sented by refactorings (see Table 5). We used Van [11] to
learn the number of addition and deletion of API classes
and methods. Second row sums the API methods that were
added or deleted from classes that exist in both versions,
the number of API classes that were added or deleted in
between the two versions, and the number of breaking
API changes that are not refactorings. Row (cid:143)Percentage of
Refactorings(cid:144) depicts how many of all API changes (in-
cluding non-breaking changes like addition of new APIs)
are refactorings. Row (cid:143)Impact of Refactorings(cid:144) depicts how
many of all changes that break existing customers are refac-
torings. Table 5 shows that even though refactorings are a
small percentage of all API changes (including addition of

Proceedings  of  the  21st  IEEE  International  Conference  on  Software  Maintenance  (ICSM (cid:144)05)  
1063-6773/05 $20.00 
 2005 

/
)
;
}
)
#
%
J
©
I
E
E
E
 
API), they have a large impact upon backwards compatibil-
ity. Therefore, migration tools should focus on carrying out
these types of changes.

4.

Related Work

To our knowledge no quantitative study has been pub-
lished about the kind of API changes that occur in com-
ponents. Several categories of related work can be distin-
guished and are provided below.
Bansiya [3] and Mattson [19] used metrics to assess the
stability of frameworks. Their metrics can only detect the
effect of changes in the framework and not the exact type of
change (e.g. they observed that method argument types have
been changed between subsequent versions whereas we ob-
serve whether they changed because of adding/removing of
parameters or because of changing the argument types).
Mattson and Bosch [20] identi“ed four evolution cat-
egories in frameworks: internal reorganization, changing
functionality, extending functionality and reducing func-
tionality. Our “ndings con “rm all four of the evolutions they
have been describing.
There exists some limited tool support for detecting and
classifying structural evolution. Detection of class split-
ting and merging was the main target of tools described in
[8, 28, 1, 12]. Clone detection can be used to detect some
refactorings like renaming or moved method. Since none of
these tools attempted to “nd all types of structural evolu-
tion, we had to analy ze the changes manually.
Tool support for upgrading applications has been a long
time interest. [6, 15, 24] discuss different annotations within
the component(cid:144)s source code that can be used by tools to
upgrade applications. However, writing such annotations
is cumbersome. Balaban et al.[2] aim to automatically re-
place obsolete library classes with their newer counterparts.
Component developers have to provide mappings between
legacy classes and their replacements. A more appealing ap-
proach would be if tools could generate this information.
Henkel and Diwan [14] describe CatchUp, a research
prototype of a refactoring-based migration tool. We are col-
laborating with our colleagues from University of Colorado
to turn CatchUp into a full-featured, reliable tool. CatchUp
is integrated with the Eclipse development environment and
uses a record and playback technique. As component de-
velopers refactor their code, CatchUp records the refactor-
ings. Along with the new version of the component, its de-
velopers ship this log of refactorings. When an application
developer upgrades to a new version, CatchUp will play-
back on the client code all the refactorings that were shipped
with the component. Our paper provides the motivation that
refactoring-based migration tools are likely to be useful in
the migration task due to the large number of refactorings
that occur during component evolution.

As an alternative to refactorings, Steyaert et. all [25] in-
troduce the notion of Reuse Contracts to guarantee struc-
tural and behavioral compatibility between frameworks and
instantiations. On the same base line, Tourwe and Mens[27]
introduce metapatterns and their associated transformations
to document the framework changes. Because of the rich
semantics carried in such documentation, automated sup-
port for application migration can be possible. We agree
that refactoring alone cannot solve all the migration prob-
lems. However, automated refactoring is supported by most
recent IDEs. We showed that refactorings can effectively
describe over 80% of the breaking API changes that actu-
ally occur in component evolution.

5. Conclusions and Future Work

API changes have an impact on applications. One might
argue that library engineers should maintain old versions of
the library so that applications built on those versions con-
tinue to run. However, this results in version proliferation
and high maintenance costs for the producer. In practice, it
is application engineers who adapt to the changes in the li-
brary.
We looked at one proprietary and two open source frame-
works and one library and studied what changed in between
versions. Then we analy zed those changes in detail and
found out that in the four case studies, respectively 84%,
81%, 90%, and 97% of the API breaking changes are struc-
tural, behavior-preserving transformations (refactorings).
There are several implications of our “ndings. First, they
con “rm that refactoring plays an important role in the evo-
lution of components. Second, they offer a ranking of refac-
torings based on how often they were used in four sys-
tems. Refactoring vendors should prioriti ze to support the
most frequently used refactorings. Third, they suggest that
component producers should document the changes in each
product release in terms of refactorings. Because refactor-
ings carry rich semantics (besides the syntax of changes)
they can serve as explicit documentation for both manual
and automated upgrades. Fourth, migration tools should fo-
cus on support to integrate into applications those refactor-
ings performed in the component. Our future work aims to
produce such migration tools based on refactorings.
Refactoring engines guarantee that the structural changes
they perform won (cid:144)t break the applications. A migration tool
based on refactoring engines (like CatchUp[14]) should be
able to do most of the tedious job of upgrading to a new ver-
sion. Application developers will have to carry only a small
fraction (less than 20%) of the remaining changes. These
are changes that require human expertise. Future work will
evaluate how much of the migration effort is saved by us-
ing a refactoring-based migration tool.

Proceedings  of  the  21st  IEEE  International  Conference  on  Software  Maintenance  (ICSM (cid:144)05)  
1063-6773/05 $20.00 
 2005 

©
I
E
E
E
 
Our “ndings cannot prove without a doubt that the ma-
jority of breaking API changes are refactorings, but they
give us the con “dence that this is the trend. More research
and case studies are needed to formally prove our position.
The availability of powerful migration tools will change
things for the component designers as well. Without fear
that they break the clients, the designers will be bolder in
the kind of changes they can make to their designs. Given
this new found freedom, designers won (cid:144)t have to carry bad
design decisions made in the past. They will purge the de-
sign to be easier to understand and reuse.

6. Acknowledgements

We thank many people who reviewed drafts: Darko
Marinov, Johannes Henkel, Amer Diwan, Oscar Nier-
stras z, Erich Gamma, Serge Demeyer, Doru Girba, Adam
Kie zun, Frank Tip, Riley White, Danny Soroker, anony-
mous reviewers, and the members of Software Archi-
tecture Group at UIUC. Your feedback made a differ-
ence.

References

[1] G. Antoniol, M. Di Penta, and E. Merlo: An Au
tomatic Ap-
, in Pro-
proach to Identif y Clas
s E vol u
tion Di scontinui tie s
ceedings of the 7th International Workshop on Principles of
Software Evolution (IWPSE (cid:144)04).
[2] I. Balaban, F. Tip, and R. Fuhrer:Refactoring Support for
, to appear in Proceedings of OOP-
Clas
s Library Migration
SLA(cid:144)05
[3] J. Bansiya: E val uating Application Framework Archi tec t
ure
, in Object-Oriented Appli-
Struct
ural and F unctional Stabilit
cation Frameworks: Problems and Perspectives, M. E. Fayad,
D. C. Schmidt, R. E. Johnson (eds), Wiley & Sons, 1999.
[4] K. Beck:Small talk Be s
, Prentice Hall, 1997
t Practice Pat
terns
[5] N. Chapin, J. Hale, K. Khan, J. Ramil, and W.-G. Than: Types
, in Journal of
of sof t
ware evol u
tion and sof t
ware maintenance
Software Maintenance 13(1): 3-30 (2001)
[6] K. Chow and D. Notkin: Semi-Au
tomatic Update of Appli-
, in Proceedings of
cations in Response to Library Changes
ICSM (cid:144)96, pp 359-368
[7] S. Demeyer, S. Ducasse, and O. Nierstrasz: Object-Oriented
, Morgan Kaufmann Publishers, 2003
Reengineering Pat
terns
[8] S. Demeyer, S. Ducasse, and O. Nierstrasz: Finding Refac-
, in Proceedings of OOPSLA(cid:144)00,
torings
via Change Metrics
pp166-177
[9] M. Fowler, K. Beck, J. Brant, W. Opdyke, and D.
Roberts: Refactoring: Improving the Design of E xi s
,
ting Code
Addison-Wesley, 1999
[10] E.Gamma, R. Helm, R. Johnson, and J. Vlissides: Design
Pat
ware
s of Reu
terns: Element
sable Object-Oriented Sof t
Addison-Wesley, 1995

,

si s

, in

[11] T. Girba , S. Ducasse, and M.Lanza: Yes
terday
s Weather:
Guiding Earl y Reverse Engineering Effort
s by Summari zing
, in Proceedings of ICSM (cid:144)04, pp
the E vol u
tion of Changes
40-49
[12] M. Godfrey and L. Zou: U sing Origin Anal y
to De tec t
, in IEEE Trans-
Merging and Split
ting of Source Code Entities
actions on Software Engineering, vol 31(2), 2005, pp. 166-181
[13] J. Graver: The E vol u
tion of an Objec t-oriented compiler
in Software, Practice & Experience archive 22(7):
framework
519-535 (1992) published by Wiley & Sons
[14] J. Henkel and A. Diwan:CatchUp! Capt
uring and Replay-
, in Proceedings of
ing Refactorings
to Support API E vol u
tion
ICSE (cid:144)05, pp 274-283
[15] R. Keller and U. Hl zle: Binary Component Adaptation
Proceedings of ECOOP (cid:144)98
[16] M. Laitinen:Framework Maintenance: Vendor Viewpoint
, in
Object-Oriented Application Frameworks: Problems and Per-
spectives, M. E. Fayad, D. C. Schmidt, R. E. Johnson (eds),
Wiley & Sons, 1999.
[17] B.P. Lient z and E.B. Swanson:
ware maintenance man-
Sof t
ter application sof t
agement: a s
udy of the compu
ware in 487
, Addison-Wesley, 1980.
data proces
sing organi zations
[18] M. Mattsson, J. Bosch, and M. Fayad: Framework Inte-
, in Communications of
gration. Problems, Cau
ses, Sol u
tions
ACM 42(10): 80-87 (1999)
[19] M. Mattson and J. Bosch: Three E val uation Methods for
Objec t-Oriented Framework s E vol u
tion - Application, A s
se s
s-
, Research report 1999:20, Department
ment and Compari son
of Software Engineering and Computer Science, University of
Karlskrona/Ronneby, Sweden, 1999
[20] M. Mattson and J. Bosch: Frameworks as Component
s: A
, in Proceedings of
Clas
si (cid:147)cation of Framework E vol u
tion
NWPER98 Nordic Workshop on Programming Environment
Research, Ronneby, Sweden, August 1998, pp. 16-74
[21] B. Meyer: Design by Contract
, Prentice Hall, 2005
[22] W. F. Opdyke and R.E. Johnson: Refactoring: An Aid in
Designing Application Frameworks and E vol ving Object-
, in Proceedings of Symposium on Object-
Oriented Sy
tems
Oriented Programming Emphasi zing Practical Applications
(SOOPPA (cid:144)90)
[23] J. Des Rivieres:
, O.T.I,
API s
Java-based
E vol ving
http://www.eclipse.org/eclipse/development/java-api-
evolution.html
[24] S. Roock and A. Havenstein: Refactoring Tags for au
tomatic
, in Proceedings of Extreme Pro-
refac toring of framework
gramming Conference (cid:144)02
[25] P. Steyaert, C. Lucas, K. Mens, and T. D(cid:144)Hondt: Reu
se Con-
, in Pro-
tract
se t
tion of Re u
s: Managing the E vol u
sable A s
ceedings of OOPSLA (cid:144)96, 268-285
[26] L. Tokuda and D. Batory: E vol ving Object-Oriented Designs
, in Journal of Automated Software Engi-
wi th Refactorings
neering 8: 8-20 (2001)
[27] T. Tourwe and T. Mens: Au
tomated s
upport for framework-
, in Proceedings of ICSM (cid:144)03, pp 148- 157
based sof t
ware
[28] F. Van Rysselberghe and S. Demeyer: Recons
truction of Suc-
, in Pro-
ce s
sf ul Sof t
ware E vol u
tion U sing Clone De tec tion
ceedings of the International Workshop on Principles of Soft-
ware Evolution (IWPSE (cid:144)03), pp 126-130

Proceedings  of  the  21st  IEEE  International  Conference  on  Software  Maintenance  (ICSM (cid:144)05)  
1063-6773/05 $20.00 
 2005 

y
(cid:143)
t
s
s
©
I
E
E
E
 
Using Re-factoring to Reduce the Pain of Component Evolution 

Ralph Johnson 
Department of  Computer Science 
University of Illinois-Urbana-Champaign, USA 

Abstract

Refactoring is usually described as a way to keep software as simple as possible, or as a 
way to reuse parts of a software system that were not designed to be reusable.  But it has 
other uses. 

One of the problems with using software components is that new versions of the 
components require changes in the systems that use them. If the change from one version 
of a component to another is described as a set of refactorings then the parts of the system 
that use them can be automatically changed to use the new versions of the component.  
This makes it much easier for developers to use the latest versions of components. 

Proceedings of the 2005 Third ACIS Int'l Conference on Softwa
 IEEE 
0-7695-2297-1/05  $20.00  © 2005

re Engineering Research, Management

 and Applications (SERA’05) 

Using Aspects to Make Adaptive Ob ject-Models Adaptable

Ayla Dantas1 , Joseph Yoder 2 , Paulo Borba1 , Ralph Johnson2
1Software Productivity Group – Informatics Center
Federal University of Pernambuco
Recife, PE - Brazil - PO Box 7851
{add,phmb}@cin.ufpe.br
2Software Architecture Group Department of Computer Science
University of Illinois at Urbana-Champaign
Urbana, IL 61801, USA
yoder@refactory.com, johnson@cs.uiuc.edu

Abstract

The unrelenting pace of change that confronts contem-
porary software developers compels them to make their
applications more conﬁgurable, ﬂexible, and adaptive.
In order to achieve this, software designers must pro-
vide ﬂexible architectures that can more quickly adapt
to changing requirements. Adaptive-Ob ject Model
(AOM) is an architectural style intended to provide
this ﬂexibility by providing a meta-architecture that
allows requirements changes to be performed and im-
mediately reﬂected at runtime. However, AOMs in-
ternal structures are sometimes diﬃcult to extend and
maintain. In this case, we can say AOM systems are
not adaptable, although they are adaptive [1]. This pa-
per proposes the use of Aspect-Oriented Programming
in order to make AOM systems simpler to evolve, spe-
cially regarding the inclusion of new adaptive require-
ments.

1

Introduction

Adaptability is an increasingly important requirement
of software systems. To achieve this requirement, soft-
ware designers must provide ﬂexible architectures that
can quickly adapt to changing requirements. Some-
times, user requirements are such that the system will
even need to adapt at runtime.
In those cases, ar-
chitectures are designed to adapt to new user require-
ments by retrieving descriptive information that can
be interpreted at runtime. Those are sometimes called
“reﬂective architectures” or “meta-architectures”.
This paper focuses on a way to enhance a partic-
ular kind of reﬂective architecture, called Adaptive
Ob ject-Model (AOM) architecture [2, 3], through the
use of Aspect-Oriented Programming (AOP) [4]. We
can make AOMs more ﬂexible by modularizing the
adaptation part of the architecture. This modulariza-
tion through the use of AOP can make AOMs more
maintainable and adaptable, especially in relation to
adaptability requirements. Adaptability here means

the ability to change or be changed to ﬁt varying cir-
cumstances, such as requirements changes. By using
AOM, we organize the code in a way that makes it
easier to adapt to such changes. After this organiza-
tion, a requirement change can be performed, for ex-
ample, by simply replacing the interpreted metadata,
which can be stored on the database or in an XML
ﬁle. However, AOM systems’ code is usually diﬃcult
to understand and maintain [3]. In this case, we can
say AOM systems are not adaptable because it is not
easy to include unanticipated adaptive requirements on
them. This happens because the code, not the meta-
data, should change in this case.

The maintainability problems with AOM’s code hap-
pen because the adaptive behavior is often mixed with
the business logic and GUI code of the application.
Business classes that provide dynamic properties or
behavior usually contain the code to obtain and in-
terpret the data from a ﬁle or database that speciﬁes
the new properties or behavior. This is called code
tangling. Besides that, such code, sometimes related
to the same adaptability requirement, may be scat-
tered throughout many classes, a phenomenon known
as code scattering. When this happens, it is hard to
understand and change in the code the points where
new dynamic data or metadata should be obtained.

Aspect-Oriented Programming is a better way to
structure Adaptive-Ob ject Models and implement
adaptive applications. For better observing the adapt-
ability implementation problem using only AOM, and
how it can be solved combining AOM and AOP, we
have gradually implemented some possible adaptive be-
haviors on a dictionary application.

The remainder of this paper is organized as follows.
The two following sections brieﬂy present AOM and
AOP respectively. In Section 4, we present the bene-
ﬁts of extending the AOM application by using AOP.
Then, Section 5 summarizes this paper, giving some
conclusions about using AOP to improve AOM.

1

2 AOM Overview

3 AOP

Many systems are developed to solve a speciﬁc prob-
lem and ﬂexibility is not included as one of the re-
quirements. Extending or maintaining these types of
systems can be a diﬃcult task. Simple changes can be
made by parameterizing system’s properties that can
be read at runtime from initialization ﬁles or databases.
However, parameterizing properties will not work for
complex adaptations such as adding new types of enti-
ties or properties. Adaptations can be even more com-
plex if the system needs to add new behavior in re-
sponse to a given property change, or dynamically de-
cide which algorithm to use depending on the property
type. For such adaptations, Adaptive-Ob ject Models
has been shown to be a good solution.
AOM architectures are usually made up of several
smaller design patterns, such as the Composite, Inter-
preter, Builder, and Strategy [5], along with other dy-
namic patterns such as TypeOb ject [6], Property [7],
and RuleOb jects [8, 9]. Most AOM architectures apply
the TypeOb ject and Property patterns together, which
results in an architecture called TypeSquare [2].
By organizing an application using these patterns,
we can represent application features, attributes and
rules (or strategies) as metadata that can be inter-
preted in a running system. Since classes, attributes
and relationships (which can be a kind of property)
are represented as metadata in AOM systems, they
have an underlying model based on instances rather
than classes. Then, adaptations to the ob ject-model
are made by changing metadata, which can then be
reﬂected into a running system by instantiating new
EntityTypes, PropertyTypes, and Rules.
The main advantage of AOM systems is ease of
change. They can even evolve to where they allow
users to conﬁgure and extend their systems “without
programming” and make the process of changing them
quickly. However, there may be a higher initial cost in
developing this kind of system, because it must be as
general as possible in order to improve extensibility and
making possible many sorts of adaptations. Generally,
these systems are also diﬃcult to understand because
several classes do not represent business abstractions
; the ob ject-model is represented in metadata. How-
ever, auxiliary Graphical User Interface (GUI) tools
and editors can be used to alleviate this problem. An-
other problem presented by the AOM architecture is
performance, since it is based on the interpretation of
metadata.
So, before deciding to use AOM or not, an analysis of
the degree of adaptability must be done. This analysis
should consider which parts of the system really need
to be highly adaptive. For instance, if the developed
system has to be a highly conﬁgured one, or if the rules
or properties of this system might change often, AOM
can be a good choice, even considering the problems
presented above.

Aspect-Oriented Programming (AOP) is a technology
intended to provide clear separation of crosscutting
concerns [4].
Its main goal is to make design and
code more modular, meaning the concerns are localized
rather than scattered and have well-deﬁned interfaces
with the rest of the system. In this way, AOP solves the
issues raised by some design decisions that are diﬃcult
to cleanly capture in code [10]. Those issues are called
aspects, and AOP is intended to provide appropriate
isolation, composition and reuse of the code used to
implement those aspects.
This programming paradigm proposes that com-
puter systems are better programmed by separately
specifying the various concerns (properties or areas of
interest) of a system and some description of their rela-
tionships and then, by using AOP environment, these
concerns are composed or weaved together into a co-
herent program [11]. This is especially useful when
the concerns considered are crosscutting. Crosscutting
concerns are those that correspond to design decisions
that involve several ob jects or operations, and that,
without AOP, would lead to diﬀerent places in the
code that do the same thing, or do a coordinated sim-
ple thing. Some examples of crosscutting concerns are:
logging, distribution, persistence, security, authentica-
tion, performance, transactions integrity, etc.
AspectJ is one of the most widely used AOP lan-
guages. It is a general-purpose aspect-oriented exten-
sion to Java [12]. This language supports the concept of
join points, which are well-deﬁned points in the execu-
tion ﬂow of the program [13]. It also has a way of iden-
tifying particular join points (pointcuts) and change
the application behavior at join points (advice).

4 Using AOP to improve AOMs

In this section, we describe how AOP can solve some
of the problems noticed in the AOM implementation
of some adaptive requirements in a dictionary appli-
cation.
In order to do that, we have implemented
some adaptabilities purely using AOM and then, im-
plemented them again combining AOM with AOP,
through the Adaptability Aspects [14] pattern. By do-
ing that, we could verify when the AOP use was appro-
priate and when it was not. The Adaptability Aspects
is an architectural pattern for structuring adaptive ap-
plications using aspects. It was used here in order to
make a better use of AOP.

4.1 Using AOM in the Dictionary
The dictionary application is a cellular phone applica-
tion that is capable of translating words from English
into Portuguese. It that presents ﬁve screens: presenta-
tion, main menu, instructions, info and search screens.
The main menu presents three options: Query, Instruc-
tions and More info...; info screen displays the source

2

and destination translation languages of the dictionary;
and in search screen the search is requested and the
translation results are shown.
Considering this simple dictionary application, we
have implemented some adaptability requirements.
One of them intends to provide dynamic source and
target translation languages. Another one is able of
providing dynamic search engines for the dictionary,
making it able of changing the way it performs a
search (e.g.
if on memory, on a server, etc). Another
adaptability requirement is responsible for providing
dynamic properties for the dictionary, which can be
shown in info screen or in another application screen
where they can be edited. The property types may
change frequently, changing the way they are shown
on the application or even their ability to be edited or
not.
To illustrate AOM’s use, we show the implemen-
tation of one of the dynamic requirements presented
above, which we call “Dynamic Dictionary Properties”.
In order to implement an adaptation with AOM, we
must evaluate which patterns should be used to reor-
ganize the application.
As we have previously seen, the info screen presents
two properties of the application:
the source and
the destination translation languages. These prop-
erties are implemented as ﬁelds of a class called
InputSearchData, which is part of the model of the
application considering the MVC pattern. If the user
requests a new property, the developer may add a
new ﬁeld to this class. However, the application may
need dynamic properties, that may exist or not and
even those the developer cannot anticipate. To pro-
vide these properties and to avoid codiﬁcation rework
when a new property is requested, we can apply the
Property [7] pattern on the dictionary application as
shown in Figure 1. Then, instead of many ﬁelds rep-
resenting diﬀerent properties, the InputSearchData
class presents a collection of properties that may be
stored in a hashtable, for example.

Figure 1: Property pattern used in the dictionary ap-
plication

The TypeOb ject [6] and Strategy [5] patterns can
also be used in addition to the Property pattern in or-
der to validate the values of the dictionary properties.
Therefore, for each Property, there is a PropertyType
instance associated with it and there are also Strategies
for validating dictionary properties. This validation
can be used for determining whether a given Property

3

is editable or not and whether it should be presented in
a given screen, such as a screen for getting user prefer-
ences. Part of the new organization of the application
in order to deal with dynamic properties and strategies
related to those properties is illustrated by Figure 2.
In the case of the dictionary application, we have
implemented an interface, PropertyValidator, and
classes implementing the isValid method, which eval-
uates if a property is valid according to its type.
With such hierarchy, we can use the Strategy pat-
tern to easily change the property validator, by us-
ing the StrategyObject class. Then,
for dynami-
cally changing the validation of the properties shown
on a giving screen (such as info screen), we may sim-
ply change the specificInstanceName attribute of the
StrategyObject responsible for that.

Figure 2: Using the Properties, TypeOb ject and Strat-
egy Pattern on the dictionary

Following the organization presented by Figure 2,
dynamic dictionary properties are obtained from the
InputSearchData class. The strategies, properties,
and their types are represented in XML ﬁles that
change from time to time and must be interpreted.
There are at least two classes we have imple-
mented that would use the dynamic properties man-
aged by the InputSearchData class: the InfoScreen
class, which displays all dictionary properties; and the
UserDataScreen, a new screen responsible for showing
dictionary properties that can be edited, such as user
name and password.
Reading in the dynamic data from the XML ﬁle is
done by using an Adaptation Data Provider module
implemented using AOM. This module is part of the
Adaptability Aspects pattern, but can also be used by
adaptive systems that do not use aspects (see [14]).
It is responsible for obtaining the dynamic proper-
ties, types and strategies that represent part of the
application. The main class in this module is the
AppAOMManager class. Any adaptation data is obtained
through this class.
In
order
to
build
or
the
InfoScreen
UserDataScreen,
the dictionary dynamic proper-
ties must be obtained from the AppAOMManager and
validated, according to their types, which can be

dynamically deﬁned. According to this implemen-
tation, by simply changing the type of a property,
or by including a new property in the metadata
that is interpreted, we can dynamically change the
application.
This metadata might change frequently and the ap-
plication might behave diﬀerently according to these
changes. Therefore, the Adaptation Data Provider ob-
jects should be reloaded from time to time. Besides
that, the dynamic parts of the application should ac-
cess this module at certain execution points. For exam-
ple, before showing InfoScreen or UserDataScreen,
we must rebuild them. To do so, we may request an
update of dictionary properties shown by these screens.
The adaptability data is requested when some dy-
namic information is necessary for the application.
This can be done during the dictionary application
startup or can be a frequent action performed in sev-
eral parts of the code. This is especially true when we
remember that AOM systems are also known for their
ability to immediately adapt to metadata changes [3].
The Observer pattern can also be used to notify an ap-
plication that updates to the ob ject-model have been
made.
In our pure AOM implementation of the adaptive
dictionary application, several points of the code call
methods to update the application ob jects due to
changes in the adaptability data. This is a problem
known as code scattering. For example, in order to up-
date dictionary properties according to dynamic data,
we may have to include reload invocations and appli-
cation ob ject updates before the InfoScreen or the
UserDataScreen are displayed. We might also have to
make calls to the reload invocations after the applica-
tion startup, at the moment some classes are instanti-
ated, etc.
As we can see, the DictionaryController class
calls methods intended to obtain new dynamic data
and reorganize the application ob jects and the screens
to be shown. However, this behavior is not directly re-
lated to this class business logic, and can lead to poor
maintainability.
For reload operations at certain execution points, we
invoke methods from the InputSearchData class that
request data from the Adaptation Data Provider mod-
ule. This request also synchronizes some properties and
associates validation strategies to these properties. Af-
ter the InputSearchData class initialization, we must
also perform some kinds of reloads.
In fact, several problems arise while implementing
adaptability requirements using AOMs or similar tech-
niques and they are not speciﬁc of dictionaries. One
of them is code tangling. This happens in the dic-
tionary because the InputSearchData, or any other
class that is supposed to obtain dynamic data, has
to know about synchronization mechanisms that may
vary according to the Adaptability Data Provider mod-
ule implementation. Besides that, what must change
or not change when dynamic data is obtained may also

vary according to new requirements. Adaptive appli-
cations, especially very dynamic ones, may change a
lot the execution points where they must adapt (ob-
tain new data and change). Consequently, if we want
to change those points, we need to modify adaptation
code scattered throughout many classes and for many
versions. Therefore, code tangling and scattering make
the adaptability implementation hard to change and
thus less adaptable. As the adaptability concern gen-
erally crosses many parts of the code, we can say it is
a crosscutting concern.
In order to solve those problems and provide a higher
degree of reuse and the ability to easily plug in/out
adaptation features, we propose the use of aspects. As-
pects help isolate the conﬁguration of dynamic adap-
tations and thus make AOMs more adaptable. To il-
lustrate this, we show in the following how we have ex-
tended the dynamic dictionary properties concern im-
plementation using the AspectJ [12] language.

4.2 AOP Use

In this section we describe how AOP can solve some
of the problems noticed in the AOM implementation
pointed out in the previous section.
In order to do
that, we use some ideas of the Adaptability Aspects pat-
tern. We primarily deal with the Dynamic Dictionary
Properties adaptability requirement, pointing out the
utility of AOP in improving its AOM implementation.
By using aspects we can modularize adaptations and
the application execution points that should trigger
them (for example, a given method call or execution, a
ﬁeld get or set, etc.). An aspect in AspectJ is a mod-
ular unit of crosscutting implementation. As we have
previously seen, the conﬁguration of the adaptations
is a crosscutting concern, because it generally crosses
many parts of the code and can make that code diﬃcult
to understand. For implementing this concern in the
case of the dynamic properties, we have used an adapt-
ability aspect called DynamicProperties. It is part of
the Adaptability Aspects module of the Adaptability
Aspects pattern.
It is responsible for verifying if an
adaptation should be performed and then performing
the necessary changes, using for both tasks elements of
other pattern modules.
By deﬁning pointcuts, aspects identify collections
of points in the execution ﬂow of a program where
behavior changes must happen.
In the case of the
DynamicProperties aspect, some of the pointcuts
we have deﬁned are called showingInfoScreen and
inputSearchDataCreation.
In the ﬁrst one, we identify the execution of the
showScreen method, from the DictionaryController
class, when the screen to be shown is InfoScreen. A
similar deﬁnition is also done for the UserDataScreen.
In order to perform some actions when these execution
points are achieved, we must deﬁne some advice.
In
the advice, as in the pointcut deﬁnition, there must be
some parameters, which are used to expose the applica-

4

tion context at those execution points. With a before
advice that corresponds to the showingInfoScren
pointcut we may deﬁne what must be done before
this execution point. The second pointcut deﬁni-
tion illustrated above corresponds to the execution of
the InputSearchData class constructor. By using an
after advice, we may deﬁne the actions to be per-
formed after this execution. The auxiliary methods
called inside these advice reload the source of adapt-
ability data and synchronize the current application
ob jects, or part of them, according to the new data.
If we want to change the adaptation points, or what
must be done at those points, we simply change the
pointcuts or the advice declarations respectively. Both
are deﬁned in a modular unit, and the access to the
source of dynamic data is conﬁned in the aspect code
(or auxiliary classes used by it).
In AspectJ, as in other AOP languages, there is a
process for composing the base source code or even
compiled code with the aspects code. This process is
known as weaving. If the user does not want dynamic
data for the dictionary properties, the aspect respon-
sible for that is simply not provided as input for the
weaving process. If this aspect is provided, the conﬁgu-
ration of the adaptability is localized. So, with aspects,
it becomes easier to conﬁgure the adaptation. There-
fore, the adaptation itself is adaptable.
There is also an additional beneﬁt: the AOM code
and the ways to integrate it with the normal code are
separated. Therefore, we can more easily change the
way we want a system to adapt. We can also more eas-
ily change or evolve the non-AOM part of the system.

5 Conclusions

As we could see, adaptability is becoming a com-
mon requirement, and implementing it can be hard.
Adaptive-Ob ject Models have been, to some extent,
successfully used to implement dynamic systems. Un-
derstanding AOMs can help developers more quickly
build systems that are highly ﬂexible, because part of
these systems is represented in metadata that can be
easily changed. However, AOMs sometimes lead to so-
lutions that can be hard to maintain in order to in-
clude new adaptive capabilities or change the code of
the existing ones. This happens because besides re-
organizing the application by using some patterns, it
also suggests that the system behavior and dynamic
elements must be represented using metadata, which
is interpreted at runtime. This interpretation of meta-
data and associated actions are scattered throughout
many classes. This makes the business logic code and
GUI code become mixed with the code for providing
the adaptability.
There may also be some business rules which do not
need to be adaptive. By mixing adaptability code with
ﬁxed code, code tangling arises. This can lead to prob-
lems while maintaining the system; speciﬁcally if an

extension to the AOM is needed.
In order to minimize those problems, and make
AOMs more adaptable, we use Aspect-Oriented Pro-
gramming. From the previous sections, we could see
that AOP can be useful for introducing adaptability
with AOMs. It brings two main advantages:
• Makes it easier to change the execution points
where dynamic data must be obtained;
• Isolates the adaptability actions from the applica-
tion business logic and GUI code.

This is a result of the modularization property pro-
vided by AOP through the use of aspects. In AspectJ,
we change the “adaptability points” by giving new
pointcut deﬁnitions that generally expose application
ob jects (the pointcut parameters). Then, we deﬁne the
adaptability actions by using advice (before, after or
around), which explore the exposed instances in order
to change the application behavior.
By using AOM, we make our applications able to
adapt at runtime to users’ or developers’ new require-
ments. This happens because we represent the parts of
the systems intended to be dynamic in metadata that is
interpreted and we organize the system using some pat-
terns. However, retrieving dynamic data and updating
application ob jects is a crosscutting concern related to
many adaptability requirements. Implementing it us-
ing pure OO programming may lead to code that is
diﬃcult to understand and evolve. Therefore, we pro-
pose the use of aspects for modularizing this concern
in each adaptability requirement.
Besides improving AOM implementations, AOP can
also be used to implement some of AOM patterns
avoiding direct changes in the application code. How-
ever,
in some cases, this may bring maintainability
problems, because the code may become more diﬃcult
to understand, as we could see in other adaptability
requirement implementation.
pattern,
By
using
the Adaptability Aspects
lightweight aspects are used in order
to avoid
problems that may result from a bad use of aspects.
The aspects should only be used to avoid code tangling
and scattering while implementing adaptability, and
where they allow a better comprehension of the code.
After this work, we conclude that AOM and AOP
are a good combination in order to provide ﬂexible ap-
plications that are easy to evolve both by interpreting
metadata or by changing source code.
In the latter
case, this will happen because the adaptability conﬁg-
uration will be better isolated.

References

[1] Lieberherr, K.: Workshop on Adaptable and
Adaptive Software.
In: Addendum to the Pro-
ceedings of the 10th annual Conference on Ob ject-
Oriented Programming Systems, Languages, and
Applications, ACM Press (1995) 149–154

5

[2] Yoder, J.W., Balaguer, F., Johnson, R.: Architec-
ture and Design of Adaptive Ob ject-Models. ACM
SIGPLAN Notices 36 (2001) 50–60

Porto de Galinhas, Brazil (2003) Temporary ver-
sion at http://www.cin.ufpe.br/˜sugarloafplop/-
acceptedPapers.htm.

The Adaptive
[3] Yoder, J.W., Johnson, R.:
Ob ject-Model Architectural Style.
In: Working
IEEE/IFIP Conference on Software Architecture
2002(WICSA), Montral, Qubec, Canada (2002)

[4] Elrad, T., Aksit, M., Kiczales, G., Lieberherr, K.,
Ossher, H.: Discussing Aspects of AOP. Commu-
nications of the ACM 44 (2001) 33–38

[5] Gamma, E., Helm, R., Johnson, R., Vlissides, J.:
Design Patterns: Elements of Reusable Ob ject-
Oriented Software. Addison-Wesley (1994)

[6] Johnson, R., Wolf, B.: “Type Ob ject”. Pattern
Languages of Program Design 3. Addison-Wesley
(1998)

[7] Foote, B., Yoder, J.: Metadata and Active
Ob ject-Models. Collected papers from the PLoP
’98 and EuroPLoP ’98 Conference Technical Re-
port wucs-98-25, Dept. of Computer Science,
Washington University (1998)

[8] Arsanjani, A.: Rule Ob ject Pattern Language.
In: Proceedings of PLoP2000. Technical Report
wucs-00-29, Dept. of Computer Science, Washing-
ton University Department of Computer Science.
(2000)

[9] Arsanjani, A.:
Using Grammar-oriented Ob-
ject Design to Seamlessly Map Business Models
to Component-based Software Architectures. In:
Proceedings of The International Association of
Science and Technology for Development, Pitts-
burgh, PA (2001)

[10] Kiczales, G., Lamping, J., Mendhekar, A.,
Maeda, C., Lopes, C.V., Loingtier, J.M., Irwin,
J.: Aspect–Oriented Programming.
In: Euro-
pean Conference on Ob ject–Oriented Program-
ming, ECOOP’97. LNCS 1241, Finland, Springer–
Verlag (1997) 220–242

[11] Elrad, T., Filman, R.E., Bader, A.: Aspect-
Oriented Programming. Communications of the
ACM 44 (2001) 29–32

[12] Kiczales, G., Hilsdale, E., Hugunin, J., Kersten,
M., Palm, J., Griswold, W.: Getting Started with
AspectJ. Communications of the ACM 44 (2001)
59–65

[13] Team, A.: The AspectJ Programming Guide. At
http://www.eclipse.org/aspectj (2003)

[14] Dantas, A., Borba, P.:
Adaptability As-
pects: An Architectural Pattern for Struc-
turing Adaptive Applications.
In:
Third
Latin American Conference on Pattern Lan-
guages of Programming, SugarLoafPLoP’2003,

6

978-1-4577-16

9-3

/11/

$26.00

303

c(cid:13) 2011 IEEE

ASE 2011, Lawrence, KS, USA

DifferentialPreconditionChecking:ALightweight,ReusableAnalysisforRefactoringToolsJeffreyL.OverbeyandRalphE.JohnsonDepartmentofComputerScienceUniversityofIllinoisatUrbana-Champaignfoverbey2,johnsong@cs.illinois.eduAbstract(cid:151)Oneofthemostdif(cid:2)cultpartsofbuildingautomatedrefactoringsisensuringthattheypreservebehavior.Thispaperproposesanewtechniquetocheckforbehaviorpreservation;wecallthistechniquedifferentialpreconditionchecking.Itissimpleyetexpressiveenoughtoimplementthemostcommonrefactorings,andthecorealgorithmrunsinlineartime.However,themainadvantageisthatadifferentialpreconditioncheckercanbeplacedinalibraryandreusedinrefactoringtoolsformanydifferentlanguages;thecorealgorithmcanbeimplementedinawaythatiscompletelylanguageindependent.WehaveimplementedadifferentialpreconditioncheckeranduseditinrefactoringtoolsforFortran(Photran),PHP,andBC.Keywords-programrepresentation;refactoringI.INTRODUCTIONWhatmakeswritinganewrefactoringtoolhard?Whatarethepartsofsuchatool?Onepartistheuserinterface;refactoringisinteractiveandrequiresagoodUI.ButIDEslikeEclipseprovideagoodframeworkforbuildingaUIforarefactoringtool,andmostoftheUIforanewrefactoringtoolcanbereusedfromothertools.Anotherpartistheparserandthegenerallanguageinfrastructure.Peoplehavetriedtoreusetheinfrastructurefromcompilersandothertoolswithmixedresults,butourpreviouswork[1]showsthatitispossibletogenerateaninfrastructurethatisperfectlysuitedforrefactor-ing,sothisisasolvedresearchproblem,too.Theremainingpartsaretherefactoringsthemselves.Automatedrefactoringshavetwoparts:thetransformation(cid:151)thechangemadetotheuser’ssourcecode(cid:151)andasetofpreconditionswhichensurethatthetransformationwillproduceaprogramthatcompilesandexecuteswiththesamebehaviorastheoriginalprogram.Authorsofrefactoringtoolsagreethatpreconditioncheckingismuchharderthanwritingtheprogramtransformations.Thispapershowshowtoconstructareusable,genericpreconditioncheckerwhichcanbeplacedinalibraryandreusedinrefactoringtoolsformanydifferentlanguages.Thismakesiteasiertoimplementarefactoringtoolforanewlanguage.Wecallourtechniqueforcheckingpreconditionsdifferentialpreconditionchecking.Adifferentialpreconditioncheckerbuildsasemanticmodeloftheprogrampriortotransforma-tion,simulatesthetransformation,performssemanticchecksonthemodi(cid:2)edprogram,computesasemanticmodelofthemodi(cid:2)edprogram,andthenlooksfordifferencesbetweenthetwosemanticmodels.Therefactoringindicateswhatdiffer-encesareexpected;iftheactualdifferencesinthesemanticmodelsareallexpected,thenthetransformationisconsideredtobebehaviorpreserving.Thechangesareappliedtotheuser’scodeonlyafterthedifferentialpreconditioncheckerhasdeterminedthatthetransformationisbehaviorpreserving.Thistechniqueissimple,practical,andminimalistic.Itdoesnotguaranteesoundness,anditisnotageneralmethodfortestingprogramequivalence.Rather,itisdesignedtobestraightforward,fast,scalable,andjustexpressiveenoughtoimplementpreconditionsforthemostcommonrefactorings.Mostimportantly,thecorealgorithmcanbeimplementedinawaythatiscompletelylanguageindependent,soitcanbeoptimized,placedinalibrary,andreusedinrefactoringtoolsformanydifferentlanguages.Thispapermakes(cid:2)vecontributions.(Relevantsectionnum-bersarenotedparenthetically.)1)Itcharacterizespreconditionsasguaranteeinginputva-lidity,compilability,andpreservation(xIII).2)Itintroducestheconceptofdifferentialpreconditionchecking(xIII)andshowshowitcansimplifypre-conditioncheckingbyeliminatingcompilabilityandpreservationpreconditions(xV).3)Itobservesthatsemanticrelationshipsbetweenthemod-i(cid:2)edandunmodi(cid:2)edpartsoftheprogramtendtobethemostimportantand,basedonthisobservation,proposesaveryconcisemethodforrefactoringstospecifytheirpreservationrequirements(xV).4)Itdescribeshowthemaincomponentofadifferentialpreconditionchecker(calledapreservationanalysis)canbeimplementedinawaythatisbothfastandlanguageindependent(xVII).5)Itprovidesanevaluationofthetechnique(xVIII),con-sideringitssuccessfulapplicationto18refactoringsanditsimplementationinrefactoringtoolsforFortran(Photran),PHP,andBC.II.PRECONDITIONCHECKINGInmosttools,eachrefactoringhasitsownsetofprecondi-tions.Thesearetested(cid:2)rst,andthetransformationproceeds3
304

onlyiftheypass.Unfortunately,designingasuf(cid:2)cientsetofpreconditionsforanewrefactoringisextremelydif(cid:2)cult.Theauthoroftherefactoringmustexhaustivelyconsidereveryfeatureinthetargetlanguageandsomehowguaranteethatthetransformationisincapableofproducinganerror.ConsiderJava:Evena(cid:147)simple(cid:148)refactoringlikeRenamemustconsidernamingcon(cid:3)icts,namespaces,quali(cid:2)ers,shadowing,reservedwords,inheritance,overriding,overloading,constructors,vis-ibility,innerclasses,re(cid:3)ection,externally-visiblenames,and(cid:147)special(cid:148)namessuchasmain.Onepromisingalternativetotraditionalpreconditioncheck-ingistoanalyzetheprogramafterithasbeentransformed,comparingittotheoriginalprogramtodeterminewhetherornotthetransformationpreservedbehavior.Thishasbeenusedforsomedependence-basedcompilertransformations(e.g.,afusionpreventingdependence[2,p.258]ismosteasilydetectedaftertransformation),butresearchershaveappliedittorefactoringtoolsonlyrecently.Althoughthistechniqueisnotyetusedinanycommercialtools,researchindicatesthatittendstomakeautomatedrefactoringssimplerandmorerobust[3].So,howcanarefactoringtoolanalyzeaprogramaftertransformation?Refactoringspreservecertainrelationshipsinthesourceprogram.TheRenamerefactoringpreservesanamebindingrelationship:Itensuresthateveryidenti(cid:2)erreferstothe(cid:147)same(cid:148)declarationbeforeandaftertransformation.ExtractMethodandExtractLocalVariablepreservecontrol(cid:3)owanddef-usechainsattheextractionsite.Aswewillseelaterinthispaper,PullUpMethodpreservesanamebindingrelationship,aswellasarelationshipbetweenclassesandmethodstheyoverride.Inourexperience,themostcommonrefactoringspreserveinvariantrelationshipsrelatedtonamebindings,inheritance,overriding,control(cid:3)ow,anddef-usechains.Analyzingaprogramaftertransformationmeansen-suringthattheseinvariantrelationshipsarepreservedacrossthetransformation.Sch¤aferetal.havesuggestedonewaytorefactorusinginvariantslikethese.ToimplementaRenamerefactoringforJava,theystoredtheoriginalnamebindings,changednames,thencheckedtheresultingbindings,addingquali(cid:2)ersasnecessarytoguaranteethatthenamebindingswouldresolveidenticallyafterthetransformationwascomplete[4].TheyusedasimilarapproachtoimplementExtractMethod:Theystoredtheoriginalcontrol(cid:3)ow,performedthetransformation,thenaddedcontrol(cid:3)owconstructsasnecessarytorestoretheoriginal(cid:3)ow[5].Theyhaveappliedthisapproachtomanyotherrefactoringsaswell[3,6].Inshort,theirapproachmaintainsinvariantsbyconstruction(cid:151)i.e.,whileperformingthetransformation,therefactoringcheckstheinvariantand,ifpossible,adjustsitsbehaviortopreserveit.TheapproachtakeninthispaperisbasedonsomeofthesameideasasthatofSch¤aferetal.,butthereisasubstantialdifferenceinhowweperformthepreservationcheck.Themaindifferenceisthatourtechnique,whenimplementedappropriately,islanguageindependent;themechanismforspecifyingpreservationrequirementsandthealgorithmforperformingthepreservationanalysisarethesame,regardlessofwhatrefactoringisbeingcheckedandregardlessofwhatlanguageisbeingrefactored.Thismeansthat,unliketheapproachofSch¤aferetal.,ourpreservationanalysiscanbeimplementedinalibraryandreusedverbatiminrefactoringtoolsformanydifferentlanguages.III.DIFFERENTIALPRECONDITIONCHECKINGPreconditionsdeterminetheconditionsunderwhichtheprogramtransformationwillpreservebehavior.Logically,thismeansthattheyguaranteethreeproperties:1)Inputvalidity.Allinputfromtheuserislegal;itispos-sibletoapplythetransformationtothegivenprogramwiththegiveninputs.2)Compilability.Ifthetransformationisperformed,theresultingprogramwillcompile;itwillmeetallthesyn-tacticandsemanticrequirementsofthetargetlanguage.3)Preservation.Ifthetransformationisperformedandtheresultingprogramiscompiledandexecuted,itwillexhibitthesameruntimebehaviorastheuntransformedprogram.Clearly,inputvalidationneedstobeperformedbeforetheprogramistransformed,sinceitmaynotevenbepossibletoperformatransformationiftheuserprovidesinvalidinput.Butcompilabilityisactuallyeasiertodetermineaftertrans-formation;essentially,itmeansrunningtheprogramthroughacompilerfrontend.Itturnsoutthatpreservationcanoftenbecheckedaposterioriaswell.Whendifferentialpreconditioncheckingisemployed,refac-toringsproceedasfollows:1)Analyzesourcecodeandproduceaprogramrepresen-tation.2)Constructasemanticmodel,calledtheinitialmodel.3)Validateuserinput.4)Simulatemodifyingsourcecode,andconstructanewprogramrepresentation.Detectcompilabilityerrors,andifappropriate,abandontherefactoring.5)Constructasemanticmodelfromthisnewprogramrepresentation.Thisisthederivativemodel.6)Performapreservationanalysisbycomparingthederivativemodelwiththeinitialmodel.7)Ifthepreservationanalysissucceeds,modifytheuser’ssourcecode.Otherwise,abandontherefactoring.Whatdistinguishesdifferentialpreconditioncheckingishowitensurescompilabilityandpreservation.ThesetopicswillbediscussedindetailinSectionsIVandV,respectively.Itensurescompilabilitybyperformingessentiallythesamechecksthatacompilerfrontendwouldperform.Itensuresbehaviorpreservationbybuildingsemanticmodelsoftheprogrambeforeandafteritistransformed.Therefactoringinformsthedifferentialpreconditioncheckerofwhatkindsofsemanticdifferencesareexpected;thecheckerensuresthattheactualdifferencesinthesemanticmodelsareallexpected305

differences(cid:151)hencethenamedifferentialpreconditioncheck-ing.1Notethatadifferentialpreconditioncheckercontraststheprogram’ssemanticmodelaftertransformationwithitsseman-ticmodelbeforetransformation.Thisisdifferentfromprogrammetamorphosissystems[7],whichprovidean(cid:147)expected(cid:148)semanticmodelandthendeterminewhetherthetransformedprogram’ssemanticmodelisequivalenttotheexpectedmodel.AswewillseeinxxV-D(cid:150)V-F,themechanismforspecifyingexpecteddifferencesinadifferentialpreconditioncheckerisfairlycoarse-grained;itdoesnotuniquelycharacterizethesemanticsofaparticulartransformedprogrambutratheridenti(cid:2)es,ingeneral,howarefactoringisexpectedtoaffectprograms’semantics.IV.CHECKINGCOMPILABILITYCheckingforcompilabilitymeansensuringthattherefac-toredprogramdoesnotcontainanysyntacticorsemanticerrors,i.e.,thatitisalegalprograminthetargetlanguage.Theseerrorswouldusuallybedetectedbythecompiler’sfrontend.Typically,thesecheckconstraintslike(cid:147)notwolocalvariablesinthesamescopeshallhavethesamename(cid:148)and(cid:147)aclassshallnotinheritfromitself.(cid:148)Whendifferentialpreconditioncheckingisemployed,thesechecksareperformedinStep4(above),andtheyareusedinlieuoftraditionalpreconditionchecks.Forexample,arefactoringrenamingalocalvariableAtoBwouldnotexplicitlytestforacon(cid:3)ictinglocalvariablenamedB;instead,itwouldsimplychangethedeclarationofAtoB,and,ifthisresultedinacon(cid:3)ict,itwouldbedetectedbythecompilabilitycheck.Infact,mostrefactoringtoolsalreadycontainmostoftheinfrastructureneededtocheckforcompilability.Itisvirtuallyimpossibletoperformanycomplicatedrefactoringswithoutaparser,abstractsyntaxtree(AST),andnamebindinginformation(symboltables).Atypecheckerisusuallyneededtoresolvenamebindingsformembersofrecordtypes,aswellasforrefactoringslikeExtractLocalVariable.So,refactoringtoolsgenerallycontain(mostof)acompilerfrontend.Steps1and4(above)involverunningsourcecodethroughthisfrontend.SocheckingforcompilabilityinStep4isnatural.Theliteraturecontainsfairlycompellingevidenceforin-cludingacompilabilitycheckinarefactoringtool.Compilabil-itycheckingsubsumessomehighlynontrivialpreconditions(cid:151)preconditionsthatdevelopershave(cid:147)missed(cid:148)intraditionalrefactoringimplementations.Verbaereetal.[8]identifyabuginseveraltools’ExtractMethodrefactoringsinwhichtheextractedmethodmayreturnthevalueofavariablewhichhasnotbeenassigned(cid:151)aproblemwhichwillbeidenti(cid:2)edbyacompilabilitycheck.Sch¤aferetal.[4]describeabuginEclipseJDT’sRenamerefactoringwhichamountstoafailuretopreservenamebindings.Danieletal.[9]reported211Whydifferential(cid:147)precondition(cid:148)checking?ArefactoringtakesuserinputIandusesittodetermineaprogramtransformationT(I).However,apreconditionfortheapplicationofT(I)totheuser’ssourcecodeisthatitsatis(cid:2)esthepropertiesofcompilabilityandpreservation.bugsonEclipseJDTand24onNetBeans.Ofthe21Eclipsebugs,19wouldhavebeencaughtbyacompilabilitycheck.Sevenoftheseidenti(cid:2)edmissingpreconditions;2theotherswereactuallyerrorsinthetransformationthatmanifestedascompilationerrors.Compilabilitycheckingalsoservesasasanitycheck.Inthepresenceofabuggyorincompletetransformation,itanalyzeswhatthetransformationactuallydid,notwhatitwassupposedtodo.Ifthecodewillnotcompileafterrefactoring,thetransformationalmostcertainlydidsomethingwrong,andtheusershouldbenoti(cid:2)ed.V.CHECKINGPRESERVATIONCompilabilitycheckingisimportantbutsimple.Checkingforpreservationismorechallenging.Itinvolveschoosinganappropriatesemanticmodeland(cid:2)ndingapreservationanalysisalgorithmthatbalancesspeed,correctness,andgenerality.Inthissection,wewilluseaprogramgraphasthesemanticmodel.InSectionVII,wewilluseaslightlydifferentsemanticmodelbasedonthesameideas.Intheremainderofthissection,wewilldiscusswhatprogramgraphsare(xV-A)andhowtheycanbeusedasananalysisrepresentationforarefactoringtool(xV-B).Then,wewilldiscusswhatpreservationmeansinthecontextofaprogramgraph(xV-C)andhowitcanbeusedinsteadoftraditionalpreconditionchecks,usingSafeDeleteandPullUpMethodasexamples(xxV-D(cid:150)V-F).Thediscussionhereisconceptualinnature;amoredetailed,formaltreatmentwillappearinthe(cid:2)rstauthor’sdissertation[10].A.ProgramGraphsOneprogramrepresentationwhichhasenjoyedsuccessintherefactoringliterature[8,11]iscalledaprogramgraph.Aprogramgraph(cid:147)maybeviewed,inbroadlines,asanabstractsyntaxtreeaugmentedbyextraedges(cid:148)[11,p.253].These(cid:147)extraedges(cid:148)(cid:151)whichwewillcallsemanticedges(cid:151)representsemanticinformation,suchasnamebindings,control(cid:3)ow,inheritancerelationships,andsoforth.Alternatively,onemightthinkofaprogramgraphasanASTwiththegraphstruc-turesofacontrol(cid:3)owgraph,du-chains,etc.superimposed;thenodesoftheASTserveasnodesofthevariousgraphstructures.AnexampleofaJavaprogramandaplausibleprogramgraphrepresentationareshowninFigure1.Theunderlyingabstractsyntaxtreeisshowninoutlineform;thedottedlinesaretheextraedgesthatmaketheASTaprogramgraph.Wehaveshownthreetypesofedges.Namebindingedgeslinktheuseofanidenti(cid:2)ertoitscorrespondingdeclaration.Withinthemethodbody,controlﬂowedgesformthe(intraprocedural)control(cid:3)owgraph;themethoddeclarationnodeisusedastheentryblockandnullastheexitblock.Similarly,therearetwodu-chains,givenbydef-useedges.Programgraphsareappealingbecausetheysummarizethe(cid:147)interesting(cid:148)aspectsofboththesyntaxandsemanticsof2Bugs177636,194996,194997,195002,195004,194005,and195006306

!"#$$    !"#$% "Test2"    &'()%        %&'()*+",             *)+$%,int             !"#$%,"ﬁeld"             -!-*-"./".0$%(((((((((((((((((-./!0.$/#./                     1".0$%,0        %1'(2+/30,             2$*02!3)+$% void             !"#$%,"fun"             "240#$!*5%,(none)             &'()%                %*'(405#"6#7*#8"+                    *)+$%,int                    !"#$%,"i"                    -!-*-"./".0$%                        -./!0.$/#./                            1".0$%,0                %**'(90$/-.57+:+./                      1"2-"&.$%,"i"                %***'(90$/-.57+:+./                      1"2-"&.$%,"ﬁeld"                %*;'(2+/30,-.;05#/*0.                      !"#$% "System.out.println"                      "240#$!*5%                         6#7*#8"+<55+$$                            1"2-"&.$%,"i"bindingbindingbindingcontrol ﬂowcontrol ﬂowcontrol ﬂowcontrol ﬂowdef-use (1)def-use (2)class Test2 {  int field = 0;  void fun() {    int i = 0;    i++;    field++;    System.out.println(i);  }}Fig.1.ExampleJavaprogramandcorrespondingprogramgraphaprograminasinglerepresentation,obviatingtheneedtomaintainamappingbetweenseveraldistinctrepresentations.Moreover,theyarede(cid:2)nedabstractly:thedeﬁnitionofaprogramgraphdoesnotstatewhattypesofsemanticedgesareincluded.Apersondesigningaprogramgraphisfreetoinclude(orexclude)virtuallyanytypeofedgeimaginable,dependingonthelanguagebeingrefactoredandneedsoftherefactoringsthatwillbeimplemented.Forthe18refactoringsweconsidered(seexVIII),wefound(cid:2)vetypesofedgestobeuseful:namebinding,control(cid:3)ow,def-use,overrideedges(whichlinkanoverridingmethodtotheoverriddenimple-mentationinasuperclass),andinheritanceedges(whichlinkaclasstotheconcretemethodsitinheritsfromasuperclass).B.ProgramGraphsandASTManipulationIntheend,refactoringtoolsmanipulatesourcecode.How-ever,whenbuildingarefactoring,itishelpfultothinkofmanipulatingtheASTinstead.Addinganodemeansinsertingsourcecode.Replacinganodemeansreplacingpartofthesourcecode.Andsoon.Thisdoesnotchangewhenaprogramgraphisusedinarefactoringtool.AprogramgraphisalwaysderivedfromanAST.ThecontentoftheASTdetermineswhatsemanticedgeswillbesuperimposed.Semanticedgescannotbemanipulateddirectly;theycanonlychangeasasideeffectofmodifyingtheAST.Infact,thatobservationwillserveasthebasisofourpreservationanalysis.WhenwemodifyanAST,wewillindicatewhichsemanticedgesweexpecttobepreservedandwhichonesweexpecttochange.Then,afterthesourcecodehasbeenmodi(cid:2)ed,wewilldeterminewhatsemanticedgeswereactuallypreservedandcomparethiswithourexpectations.C.PreservationinProgramGraphsThisraisesaquestion:Whatdoesitmeanforasemanticedgetobe(cid:147)preserved(cid:148)whenanASTismodi(cid:2)ed?Wewouldliketosay:Ifboththemodi(cid:2)edandunmodi(cid:2)edASTscontainanedgewiththesametypeandthesameendpoints,thatedgehasbeenpreserved.Unfortunately,itisnotclearwhatthe(cid:147)same(cid:148)endpointsare,sincetheASThasbeenmodi(cid:2)ed,andtheendpointsareASTnodes.Considerarefactoringwhichreplacestheexpressionx(cid:0)xwiththeconstant0.Whenappliedtotheexpression3+(x(cid:0)x),thiscorrespondstothefollowingtreetransformation.+−3xx+03Whenasubtreeischanged(i.e.,added,moved,removed,orreplaced)inanAST,wewillcallthattheaffectedsubtree.Agraytrianglesurroundstheaffectedsubtreesinthe(cid:2)gureabove.Usingthat(cid:2)gureasanexample,considerhowASTnodesintheunmodi(cid:2)edASTcorrespondwithnodesinthemodi(cid:2)edAST:(cid:15)ThereisanobviouscorrespondencebetweenASTnodesoutsidetheaffectedsubtrees,sincethosepartsoftheASTwereunaffectedbythetransformation.(cid:15)Asawhole,theaffectedsubtreebeforethetransformationcorrespondstotheaffectedsubtreeafterthetransforma-tion.(cid:15)Ingeneral,thereisnocorrespondencebetweennodesinsidetheaffectedsubtrees.Recallthatourgoalistodetermineifasemanticedgehasthe(cid:147)same(cid:148)endpointsbeforeandafteranASTtransformation.Thisiseasyifanendpointisoutsidetheaffectedsubtree,orifthatendpointistheaffectedsubtreeitself.Butiftheendpointisinsidetheaffectedsubtree,wecannotdetermineexactlywhichnodeitshouldcorrespondto...exceptthat,ifitcorrespondstoanything,thatnodewouldbeintheotheraffectedsubtree.SincewecannotdetermineacorrespondencebetweenASTnodesinsidetheaffectedsubtree,wewillcollapsetheaffectedsubtreesintosinglenodes.ThismakestheASTbeforetrans-formationisomorphictotheASTaftertransformation.!"##$%&’(!"##$%&’(+"!"Now,supposewehavesuperimposedsemanticedgestoformaprogramgraph.Whenwecollapsetheaffectedsubtreetoasinglenode,wewillalsoneedtoadjusttheendpointsofthesemanticedgesaccordingly:307

(cid:15)Whenanaffectedsubtreeiscollapsedtoasinglenode,ifanysemanticedgeshaveanendpointinsidetheaffectedsubtree,thatendpointwillinsteadpointtothecollapsednode.Note,inparticular,thatifanedgehasbothendpointsinsidetheaffectedsubtree,itwillbecomeaself-looponthecollapsednode.Also,notethataprogramgraphisnotamultigraph:Ifseveraledgeshavethesametypesandendpointsinthecollapsedgraph,theywillbemergedintoasingleedge.Collapsingtheaffectedsubtreeinaprogramgraphactuallyhasafairlyintuitiveinterpretation:Ifwereplaceonesubtreewithadifferentsubtreethatsupposedlydoesthesamething,thenthenewsubtreeshouldinterfacewithitssurroundingsin(mostly)thesamewaythattheoldsubtreedid.Thatis,alloftheedgesthatextendedintotheoldsubtreeshouldalsoextendintothenewsubtree,andalloftheedgesthatemanatedfromtheoldsubtreeshouldalsoemanatefromthenewsubtree.Theremaybesomedifferenceswithintheaffectedsubtree,butthe(cid:147)interface(cid:148)withtherestoftheASTstaysthesame.Insomecases,wewill(cid:2)ndithelpfultoreplaceonesubtreewithseveralsubtrees(or,conversely,toreplaceseveralsub-treeswithone).Forexample,EncapsulateVariableremovesapublicvariable,replacingitwithaprivatevariable,anaccessormethod,andamutatormethod.Inotherwords,wearemodifyingseveralsubtreesatthesametime.Inthesecases,wehaveanaffectedforestratherthanasingleaffectedsubtree.However,thepreservationruleisessentiallythesame:Allofsubtreesintheaffectedforestarecollapsedintoasingleunit.Soifanedgeextendedintosomepartoftheaffectedforestbeforetransformation,itshouldalsoextendintosomepartoftheaffectedforestaftertransformation.InthecaseofEncapsulateVariable,thiscorrectlymodelstheideathateverynamebindingthatpointedtotheoriginal(public)variableshould,instead,pointtoeitherthenew(private)variable,theaccessormethod,orthemutatormethod.(WewillseeanexampleofanaffectedforestwhenwediscussPullUpMethodinxV-F.)D.SpecifyingPreservationRequirementsNowthatwehaveestablishedhowtodeterminewhetherasemanticedgehasbeenpreservedacrossatransformation,weturntoadifferentquestion:Howcanweexpresswhichsemanticedgesweexpecttobepreservedandwhichonesweexpecttochange?1)EdgeClassiﬁcations:Fromtheabovedescription,wecanseethatwhetherwewanttopreserveanedgedependsonitstypeaswellasitsrelationshiptotheaffectedsubtree.Therefore,itishelpfultoclassifyeverysemanticedgeaseitherinternal(bothendpointsofthesemanticedgeoccurwithintheaffectedsubtree),external(neitherendpointoccurswithintheaffectedsubtree),incoming(theheadofthesemanticedgeisoutsidetheaffectedsubtreebutthetailisinsideit),oroutgoing(theheadisinsidetheaffectedsubtreeandthetailisoutsideit).2)Notation:Now,wecanestablishsomenotation.Toindicatewhatedgeswe(donot)expecttopreserve,wemustindicatethreethings:1)Thetype(s)ofedgestopreserve.WewillusethelettersN,C,D,O,andItodenotenamebinding,control(cid:3)ow,def-use,override,andinheritanceedges,respectively.(Note,however,thatprogramgraphsmaycontainothertypesofedgesaswell,dependingonthelanguagebeingrefactoredandtherequirementsoftherefactoringsbeingimplemented.)2)Theclassiﬁcation(s)ofedgestopreserve.Wewilluse ,!,(cid:9),and(cid:2)toindicateincoming,outgoing,inter-nal,andexternaledges,respectively.Wewilluse$asashorthandfordescribingbothincomingandoutgoingedges.3)Whetherweexpectthetransformationtointroducead-ditionaledgesorremoveexistingedges.Ifadditionaledgesmaybeintroduced,wedenotethisusingthesymbol(cid:19)(i.e.,thetransformedprogramwillcontainasupersetoftheoriginaledges).Ifexistingedgesmaybeeliminated,wedenotethisby(cid:18).Ifedgesmaybebothaddedandremoved,thenwecannoteffectivelytestforpreservation,sothoseedgeswillbeignored;weindicatethisusingthesymbol=?.Otherwise,weexpecta1(cid:150)1correspondencebetweenedges,i.e.,edgesshouldbepreservedexactly.Weindicatethisby=.E.Example:SafeDelete(Fortran95)Tomaketheseideasmoreconcrete,letus(cid:2)rstconsideraSafeDeleterefactoringforFortranwhichdeletesanunrefer-encedinternalsubprogram.3Thetraditionalversionofthisrefactoringhasonlyoneprecondition:Theremustbenoreferencestothesubprogramexceptforrecursivereferencesinitsde(cid:2)nition.Whatwouldthedifferentialversionlooklike?Todetermineitspreservationrequirements,itisoftenusefulto(cid:2)lloutatablelikethefollowing(notethatFortran95isnotobjectorientedandthuscannothaveO-orI-edges):NCD ===!(cid:18)==(cid:9)(cid:18)(cid:18)(cid:18)(cid:2)===Whenasubprogramisdeleted,allofthesemanticedgesinsidethedeletedsubroutinewill,ofcourse,disappear,andifthesubprogramreferencesanynamesde(cid:2)nedelsewhere(e.g.,othersubprograms),thoseedgeswilldisappear.Otherwise,nosemanticedgesshouldchange.Notatingpreservationrequirementsintabularformissome-whatspace-consuming,sinceinpracticemostcellscontain=.Therefore,wewilluseamorecompactnotation.Foreachedgetype,wewillusesubscriptstoindicatewhichcellsarenot=,3Aslightlymorecompleteandmuchmoredetailedspeci(cid:2)cationforthisrefactoringisgiveninthetechnicalreport[12]describedintheEvaluationsectionofthispaper.308

i.e.,whatedgesshouldnotbepreservedexactly.Ifallcellsare=,wewillomitthesubscript.Usingthisnotation,thepreservationrequirementsintheabovetablewouldbenotatedN!(cid:18)(cid:9)(cid:18)C(cid:9)(cid:18)D(cid:9)(cid:18):Thus,wecandescribethedifferentialversionofthisrefactoringinasinglestep:Deletethesubprogramdeﬁnition,ensuringpreservationaccordingtotheruleN!(cid:18)(cid:9)(cid:18)C(cid:9)(cid:18)D(cid:9)(cid:18).F.Example:PullUpMethod(PHP5)Foramoreinterestingexample,letusconsideraPullUpMethodrefactoringforPHP5,whichmovesaconcretemethodde(cid:2)nitionfromaclassCintoitsimmediatesuperclassC0.4First,considerthetraditionalversion.Preconditions.1)AmethodwiththesamenameasMmustnotalreadyexistinC0.IfMwerepulledup,therewouldbetwomethodswiththesamename,orMwouldneedtoreplacetheexistingmethod.2)IfthereareanyreferencestoM(excludingrecursivereferencesinsideMitself),thenMmustnothaveprivatevisibility.Ifitweremovedup,itsvisibilitywouldneedtobeincreasedinorderforthesereferencestobepreserved.3)Mmustnotcontainanyreferencestothebuilt-inconstantsselfor__CLASS__.Ifitweremovedup,thesewouldrefertoC0insteadofC.(NotethatPHPcontainsbothselfand$this:Theformerreferstotheenclosingclass,whilethelatterreferstothethisobject.)4)MmustnotcontainanyreferencestoprivatemembersofC(exceptforMitself,ifitisprivate).PrivatemembersofCwouldnolongerbeaccessibletoMifitwerepulledup.5)MmustnotcontainanyreferencestomembersofCforwhichthereisasimilarly-namedprivatememberofC0.ThesereferenceswouldrefertotheprivatemembersofC0ifthemethodwerepulledup.6)IfMoverridesanotherconcretemethod,nosubclassesofC0mayinherittheoverriddenmethod.PullingupMwouldcausetheseclassestoinheritthepulledupmethodinstead.7)TheusershouldbewarnedifMoverridesanotherconcretemethod.IfMwerepulledupintoC0,thenMwouldreplacethemethodthatC0inherited,changingthebehaviorofthatmethodinobjectsoftypeC0,althoughtheusermightintendthissinceheexplicitlychosetopullupMintoC0.Transformation.MoveMfromCtoC0,replacingalloccur-rencesofparentinMwithself.Now,considerthedifferentialversion.Thetransformationcanbeexpressedasthecompositionoftwosmallerrefactor-ings:4Again,amorecompleteanddetailedspeci(cid:2)cationisavailable[12].1)CopyUpMethod.UsingpreservationruleNO (cid:19)(cid:9)(cid:19)I■(cid:18),copythemethodde(cid:2)nitionfromCtoC0,replacingalloccurrencesofparentinMwithself.2)DeleteOverridingDuplicate.Removetheoriginalmethodde(cid:2)nitionfromC,withruleNO(cid:9)(cid:18)I (cid:19).Pictorially,theprocessisasfollows.Theaffectedforestsarehighlightedingray.!"#$"%&'!'(!"#$"%&')'((#*+"",-+.!"#$"%&'!'('#!/01!2+3024!inheritsWhenthemethodiscopiedfromCtoC0,aninternaloverrideedgewillbeintroduced,asmayincomingoverrideedges(ifanotherclasswilloverridethepulledupmethod),hencetheruleO (cid:19)(cid:9)(cid:19).Ifthemethodbeingpulledupoverridesamethodinheritedfromtheimmediatesuperclass,thenaninheritanceedgewillbelost,henceI■(cid:18).However,thenewmethodinC0shouldnotbeinheritedbyanysubclasses,andallidenti(cid:2)ersshouldbindtothesamenamestheydidwhenthemethodwascontainedinC,sonootherinheritanceornamebindingedgesareexpectedtochange.Oncewehaveestablishedthatnosubclasseswillaccidentallyinheritthepulledupmethod,wecandeletetheoriginalmethodfromC.Thiswillremovetheoverrideedgeintroducedinthepreviousstep,andCwillinheritthepulledupmethod,sothepreservationruleisNO(cid:9)(cid:18)I (cid:19).Now,considerhowthedifferentialversionofthisrefac-toringsatis(cid:2)esallofthetraditionalversion’spreconditions.Precondition1wouldbecaughtbyacompilabilitycheck.Preconditions2(cid:150)5aresimplypreservingnamebindings.AprogramthatfailedPrecondition6wouldintroduceanincom-inginheritanceedge.IfaprogramfailedPrecondition7,anoutgoinginheritanceedgefromC0wouldvanish.Forthedifferentialversion,werede(cid:2)nedPullUpMethodasthecompositionoftwosmallerrefactorings.Wheneverthisispossible,itisgenerallyagoodidea:Itallowspreserva-tionrulestobespeci(cid:2)edata(cid:2)nergranularity;thesmallerrefactoringsareoftenusefulintheirownright;and,perhapsmostimportantly,simplerrefactoringsareeasiertoimplement,easiertotest,andthereforemorelikelytobecorrect.VI.THEPRESERVATIONANALYSISALGORITHMIfoneunderstandswhataprogramgraphis,andwhatthepreservationrulesmean,thepreservationanalysisalgorithmisstraightforward.AprogramgraphbecomesanabstractdatatypewithSorts:ProgramGraph,Edge,TypeOperations:getAllEdges:ProgramGraph!(cid:2)nitesetofEdgeclassify:Edge!f ;!;(cid:9);(cid:2)gtype:Edge!Typeequiv:Edge(cid:2)Edge!fTRUE,FALSEg.309

Theequivoperationdetermineswhethertwoedges(cid:151)oneintheoriginalprogramgraphandoneinthetransformedprogramgraph(cid:151)areequivalent,i.e.,iftheedgewaspreserved.Forsimplicity,wehaveleftthisunderspeci(cid:2)ed,althoughitsintentshouldbeclearfromtheprevioussection.Now,preservationisdeterminedbythefollowingalgorithm.Input:P:ProgramGraph(Originalprogram)P0:ProgramGraph(Transformedprogram)rule:Type(cid:2)f ;!;(cid:9);(cid:2)g!f=;(cid:18);(cid:19);=?gOutput:PASSorFAILletE:=getAllEdges(P)letE0:=getAllEdges(P0)foreachEdgee2Eifrule(type(e);classify(e))is(cid:19)or=but69e02E0s.t.equiv(e;e0)=TRUE,thenFAILforeachEdgee02E0ifrule(type(e0);classify(e0))is(cid:18)or=but69e2Es.t.equiv(e;e0)=TRUE,thenFAILotherwise,PASSVII.ANALYSISWITHTEXTUALINTERVALSThekeytoanef(cid:2)cientimplementationisbeingabletodetermine,foraparticularedge,whetheranequivalentedgeexistsinthetransformedprogram.IfthiscanbedoneinO(1)time,thentheabovealgorithm’sexecutiontimeislinearinthenumberofedgesinthetwoprogramgraphs.Inthissection,wewillsketchonewaytodothis(whichalsomakestheimplementationlanguageindependent).TheASTsinrefactoringtoolstendtomodelsourcecodeveryclosely.Thismeansthattheytendtoexhibitaveryusefulproperty:EverynodeinanASTcorrespondstoaparticulartextualregionofthesourcecode,andthistextualregioncanbemappedbacktoauniqueASTnode.ConsidertheprogramgraphfromFigure1.Thesourcecodeis115characterslong.TheClassASTnodecorrespondstotheentiresourcecode(cid:151)thecharactersatoffsets0through114,inclusive,ortheinterval[0;114].The(cid:2)elddeclarationintfield=0;correspondstotheinterval[14;30].Thepost-incrementfield++;becomes[70;82].SinceASTnodescanberepresentedasintervals,wecanusetheseintervalstodescribethesemanticedgesofaprogramgraph.Forexample,thenamebindingedgefromthepost-incrementtothe(cid:2)elddeclarationbecomes[70;82].B[14;30].(TheintervalrepresentationoftheprogramgraphinFigure1isshowninFigure2(a).)Duringarefactoringtransformation,itispossibletotrackwhatregionsoftheoriginalsourcecodearedeletedorreplaced,aswellaswherenewsourcecodeisinserted.Thesetextualregionsarecontainedintheaffectedforests.Sinceweknowexactlyhowmanycharacterswereaddedordeletedatwhatpositions,thenforanycharacteroutsidetheseregions,itispossibletodetermineexactlywherethatcharactershouldoccurinthetransformedprogram.Supposewehavea(partial)functionnewOffset(n)thatcandeterminethisvalue,foragivencharacteroffsetnintheoriginalprogram.Now,supposewetakeeachedgeofthederivativemodel,andifanendpointiscontainedintheaffectedforest,wereplacethatintervalwith(cid:3).Wewillcalltheresultthenormalizedderivativemodel.Then,wecantakeeachedgeoftheinitialprogramgraphandusethenewOffsetfunctiontodeterminetheequivalentedgeinthenormalizedderivativemodel,likewisereplacingendpointsintheaffectedforestwith(cid:3).Wewillcallthisthenormalizedinitialmodel.Ifthenormalizedmodelsarestoredassets(eliminatingdu-plicateedges),theneachedgeintheinitialmodelcorrespondstoexactlyoneedgeinthenormalizedinitialmodel,andeachedgeinthederivativemodelcorrespondstoexactlyoneedgeinthenormalizedderivativemodel.Now,anedgeintheinitialmodelisequivalenttoanedgeinthederivativemodel(inthenotationoftheprevioussection,equiv(e;e0)if,andonlyif,theircorrespondingedgesintheinitializedmodelsareequal.Bystoringtheedgesofthenormalizedmodelsinappropriatedatastructures(e.g.,hashsets),wecandetermineinO(1)timeifaparticularedgeoccursineithermodel.AnexampleisshowninFigure2.Suppose,intheJavaprograminFigure1,weattempttorenamethe(cid:2)elddeclarationfromfieldtoi.Thetransformationissimple:replacethe(cid:2)vecharactersfieldatoffsets20(cid:150)24(thedeclaration)and74(cid:150)78(thereference)withtheone-characterstringi.Sincefourcharactersaredeletedineachcase,newOffset(n)=nifn(cid:20)19n(cid:0)4if25(cid:20)n(cid:20)73n(cid:0)8if79(cid:20)n:Theaffectedforestconsistsofthe(cid:2)elddeclarationandthesecondpost-increment(initialintervals[14;30]and[70;82],derivativeintervals[14;26]and[66;74]).Sincefield++changestoi++,thenamebindingedgeforthe(cid:2)eldreferencedisappearsandbecomesareferencetothelocalvariableiinthederivativemodel.Also,anewdef-usechainisintroduced.Sincetherenamingtransformationwouldnotpreservenamebindings(ordu-chains,forthatmatter),itshouldnotbeallowedtoproceed.Implementingthepreservationanalysisusingtextualinter-vals,ratherthandirectlyontheprogramgraph,hasanumberofadvantages.Itallowsthepreservationanalysistobehighlydecoupledfromtherefactoringtool’sprogramrepresentation,whichmakesitmoreeasilyreusable.Itisfairlyspace-ef(cid:2)cient,sincesemanticedgesarerepresentedastuplesofintegers.Also,thereisafairlynaturalwaytodisplayerrors:highlighttheaffectedregion(s)ofthesourcecode.VIII.EVALUATIONInprevioussections,weillustrateddifferentialpreconditioncheckingusingSafeDelete,PullUpMethod,andRenameasillustrativeexamples.Wealsosketchedalinear-timealgorithm310

InitialModel(a)[74,78]⊲B[14,30][65,65]⊲B[46,60][106,106]⊲B[46,60][31,113]⊲C[46,60][46,60]⊲C[61,69][61,69]⊲C[70,82][70,82]⊲C[83,109][83,109]⊲C[−1,−1][46,60]⊲D[61,69][61,69]⊲D[106,106]Norm.Initial(b)∗⊲B∗[61,61]⊲B[42,56][98,98]⊲B[42,56][27,105]⊲C[42,56][42,56]⊲C[57,65][57,65]⊲C∗∗⊲C[75,101][75,101]⊲C[−1,−1][42,56]⊲D[57,65][57,65]⊲D[98,98]Norm.Deriv.(c)[61,61]⊲B[42,56]∗⊲B[42,56][98,98]⊲B[42,56][27,105]⊲C[42,56][42,56]⊲C[57,65][57,65]⊲C∗∗⊲C[75,101][75,101]⊲C[−1,−1][42,56]⊲D[57,65][57,65]⊲D[66,74]∗⊲D[98,98]Deriv.Model(d)[61,61]⊲B[42,56][70,70]⊲B[42,56][98,98]⊲B[42,56][27,105]⊲C[42,56][42,56]⊲C[57,65][57,65]⊲C[66,74][66,74]⊲C[75,101][75,101]⊲C[−1,−1][42,56]⊲D[57,65][57,65]⊲D[66,74][66,74]⊲D[98,98]Fig.2.TextualintervalmodelsoftheprogramgraphfromFigure1,whenfieldisrenamedtoiforperformingthepreservationanalysisandarguedforitslanguageindependence.Butisthistechniqueeffectiveinpractice?Wewillfocusontwoquestions:Q1.Expressivity.Arethepreservationspeci(cid:2)cationsinxIIIsuf(cid:2)cienttoimplementthemostcommonautomatedrefactorings?Q2.Performance.Whenpreconditionsarecheckeddifferen-tially,whataretheperformancebottlenecks?Howdoestheperformancecomparetoatraditionalimplementa-tion?Forourevaluation,weimplementedadifferentialprecon-ditioncheckerwhichwereusedinthreerefactoringtools:(1)Photran,apopularEclipse-basedIDEandrefactoringtoolforFortran;(2)aprototyperefactoringtoolforPHP5;and(3)asimilarprototypeforBC.A.Q1:ExpressivityToeffectivelyanswerquestionQ1,wemust(cid:2)rstidentifywhatthemostcommonautomatedrefactoringsare.ThebestempiricaldatasofararereportedbyMurphy-Hilletal.[13].TableIshowsseveralofthetoprefactorings;theEclipseJDTcolumnshowsthepopularityofeachrefactoringintheEclipseJDTaccordingto[13,Table1,(cid:147)Everyone(cid:148)].Forcomparison,wehavealsolistedtheavailabilityoftheserefactoringsinotherpopularrefactoringtoolsforvariouslanguages.Weselected18refactorings(seeTableII):7forFortran,9forBC,and4forPHP.FiveoftheserefactoringsareFortranorBCanalogsofthe(cid:2)vemostfrequently-usedinEclipseJDT.Nineothersaresupportrefactorings,necessitatedbydecomposition.Theremainingrefactoringswerechosenforotherreasons.AddEmptySubprogramandSafeDeletewerethe(cid:2)rsttobeimplemented;theyhelpedshapeandtestourimplementation.IntroduceImplicitNonepreservesnamebindingsinan(cid:147)interesting(cid:148)way.PullUpMethodrequiredustomodelmethodoverridingandotherclasshierarchyissuesinprogramgraphs.ItisworthnotingthatmanypopularIDEsprovidefewerthan10refactorings,includingAppleXcode(8refactorings),MicrosoftVisualStudio(6),andZendStudio(4).Sowhilegeneralityisimportantanddesirable(certainly,atechniquethatworksfor18refactoringswillapplytomanyothers),ex-peditingandimprovingtheimplementationofafewcommonrefactoringsisequallyimportant,perhapsmoreso.TABLEIAUTOMATEDREFACTORINGSINPOPULARTOOLS.RefactoringEclipseJDT(Rank)IntelliJIDEA1IntelliJReSharper2MSVisualStudio3EclipseCDTVisualAssistX4AppleXcode5ZendStudio6Rename1•••••••ExtractVariable2••◦•◦◦•Move3••◦◦◦◦•ExtractMethod4•••••••ChangeSignature5•••◦•◦◦PullUpMethod11••◦◦••◦Legend:•Included◦NotIncluded1http://www.jetbrains.com/idea/features/refactoring.html2http://www.jetbrains.com/resharper/features/coderefactoring.html3http://msdn.microsoft.com/en-us/library/719exd8s.aspx4http://www.wholetomato.com/products/featureRefactoring.asp5http://developer.apple.com/mac/library/documentation/DeveloperTools/Conceptual/XcodeWorkspace/150-Refactoring/refactoring.html6http://www.zend.com/en/products/studio/features#refactorTABLEIIREFACTORINGSEVALUATED.1.Rename2.Move3.Introduce USE4.Change Function Signature5.Introduce IMPLICIT NONE6.Add Empty Subprogram7.Safe Delete8.Pull Up Method9.Copy Up Method10.Extract Local Variable11.Add Local Variable12.Introduce Block13.Insert Assignment14.Move Expression15.Extract Function16.Add Empty Function17.Populate Function18.Replace ExpressionFortranPHPBCWewrotedetailedspeci(cid:2)cationsofall18refactoringsinatechnicalreport[12].Eachspeci(cid:2)cationdescribesboththetraditionalandthedifferentialversionoftherefactoring,bothatalevelofdetailsuf(cid:2)cienttoserveasabasisforimplementation.(SeveralundergraduateinternsworkingonPhotranimplementedrefactoringsbasedonourspeci(cid:2)cations.)Thestyleofthespeci(cid:2)cationsissimilartothePullUpMethodexamplefromxIIIbutmoreprecise.Forexample,theFortranrefactoringspeci(cid:2)cationsusethesameterminologyastheFortran95ISOstandard.Wedividedrefactoringsamongthethreelanguagesasfollows.Foralloftherefactoringsthatrelyprimarilyonname311

Fig.3.Renameperformancemeasurementsbindingpreservation,wetargetedFortran,sinceithasthemostcomplicatednamebindingrules.Wetargeted(cid:3)ow-basedrefactoringsforBC:Itcontainsfunctions,scalarandarrayvariables,andalloftheusualcontrol(cid:3)owconstructs,butitisamuchsmallerandsimplerlanguagethaneitherFortranorPHP.Thiskeptthespeci(cid:2)cationsofthese(usuallycomplex)refactoringstoamanageablesizewithoutsacri(cid:2)cinganyoftheessentialpreconditions.Theoneobject-orientedrefactoringtargetedPHP5.Weimplementedadifferentialpreconditionchecker(follow-ingxVII)andusedittoimplementdifferentialrefactoringsinthethreerefactoringtools,followingourdetailedspeci-(cid:2)cations.ForBCandPHP,weimplementedrefactoringsaslistedinTableII.Sincetherearenocomparablerefactoringtoolsfortheselanguages,wecouldnotperformdifferentialtesting.However,weportedseveralrelevantunittestsfromtheEclipseCDTandJDT,aswellastwoinformalrefactoringbenchmarks[14,15].ForFortran,weimplementeddifferentialversionsofRename,IntroduceImplicitNone,AddEmptySubprogram,andSafeDelete.Photranincludedtraditionalversionsoftheserefactorings,withfairlyextensiveunittests,sowewereabletoreusetheexistingtestcasestotestthedifferentialimplementations.B.Q2:PerformanceSinceadifferentialpreconditionchecker’sperformancede-pendsonthespeedofthelanguage-speci(cid:2)cfrontend,aswellwhatrefactoringisbeingperformedandwhatprogramisbeingrefactored,itisdif(cid:2)culttomakeanybroadclaimsaboutperformance.Inourexperience,whenarefactoringaffectsonlyoneortwo(cid:2)lesinatypicalapplication,theamountoftimedevotedtopreconditioncheckingisnegligible.Mostoftherefactoringsweimplementedfallintothiscategory.Performancebecomesaconcernonlyatscale,e.g.,whenarefactoringpotentiallyaffectsevery(cid:2)leinaproject.WewillusePhotran’sRenamerefactoringasanillustrativeexample.Renameisthemostexpensiveoftherefactoringsweim-plemented,sinceitcanpotentiallychangenamebindingsinevery(cid:2)leintheprogram,itoftenmakesmanychangestoasingle(cid:2)le,andcomputingnamebindingsinvolvesaccessingaindex/cross-referencedatabase.Figure3showsperformancemeasurements5fortheRenamerefactoringonthreeFortranprograms.Twoareexamplesintendedtotestscalability:(cid:147)1File(cid:148)isaprojectwith500sub-routinede(cid:2)nitionsinasingle(cid:2)le,while(cid:147)500Files(cid:148)contains1subroutineineachof500(cid:2)les.(cid:147)WindFunction(cid:148)showstheresultsofrenamingofthewindfunctioninanatmosphericdispersionsimulation(aproductionFortranprogramconsistingofabout53,000LOCin29(cid:2)les,fourofwhichwereultimatelyaffectedbytherefactoring).Fromlefttoright,theperformancemeasurementsrepresentcreationoftheinitialintervalmodel,normalizationofthismodel,runningthefrontendtore-analyzethemodi(cid:2)edcode,constructionofthederivativeintervalmodel,normalizationofthismodel,and,(cid:2)nally,thepreservationanalysis.Notethelogarithmicscaleonthey-axis:Inallthreecases,theperformancebottleneckwas,byfar,theRe-analyzemeasurement(cid:151)i.e.,theamountoftimetakenforthefrontendtoanalyzethemodi(cid:2)edprogramandrecomputenamebindings.Thiswasgenerallytrueforotherrefactoringsaswell.Itisnotparticularlysurprising:Whenanidenti(cid:2)erinone(cid:2)lecanrefertoanentityinanother(cid:2)le,computingnamebindingsinvolvespopulatingandaccessingacross-referencedatabase.Inourexperience,differentialpreconditioncheckingisnotasfastastraditionalpreconditionchecking,butitsspeedisacceptable.Afterall,theamountoftimeitrequiresisessentiallytheamountoftimethefrontendtakestoanalyzetheaffected(cid:2)les.IntheWindFunctionexample,differentialpreconditioncheckingtookabout9seconds,whiletraditionalcheckstookjustover1second.Photran’snamebindinganalysisisnotparticularlyfast,anditstraditionalRenamerefactoringhasbeenheavilyoptimizedoverthecourseofsixyearstocompensate.Incontrast,fortherefactoringswhichmadelocalizedchangestoonlyoneortwo(cid:2)les,thetimedevotedtopreconditioncheckingwasunnoticeable.IX.LIMITATIONSOurpreservationanalysishastwonotablelimitations.First,itassumesthat,ifareplacementsubtreeinterfaceswiththerestoftheASTinanexpectedway,itisavalidsubstitutefortheoriginalsubtree.Itistherefactoringdeveloper’sresponsibilitytoensurethatthisassumptionisappropriate.Forexample,replacingeveryinstanceoftheconstant0withtheconstant1wouldalmostcertainlybreakaprogram,butouranalysiswouldnotdetectanyproblem,sincethischangewouldnotaffectanyedgesinatypicalprogramgraph.However,therefactoringdevelopershouldrecognizethatnamebindings,control(cid:3)ow,anddu-chainsdonotmodeltheconditionsunderwhich1and0areinterchangeablevalues.Second,forourpreservationanalysistobeeffective,the(cid:147)behavior(cid:148)topreservemustbemodeledbytheprogramgraph.Thereareseveralcaseswherethisisunlikelytobetrue,includingthefollowing.5Thetestswereperformedona2GHzIntelCore2Duo(MacBook),Java1.6.024,withtheJVMheaplimitedto512MB.312

Interproceduraldataﬂow.Oneparticularlyinsidiousex-ampleisillustratedbyanEclipsebug(186253)reportedbyDanieletal.[9].Inthisbug,EncapsulateFieldreordersthe(cid:2)eldsinaclassdeclaration,causingone(cid:2)eldtobeinitializedincorrectlybyaccessingthevalueofanuninitialized(cid:2)eldviaanaccessormethod.Intheory,thiscouldbedetectedbyapreservationanalysis,asitisessentiallyafailuretopreservedu-chainsfor(cid:2)eldsamongtheirinitializers.Unfortunately,thesewouldprobablynotbemodeledinaprogramgraph,sincedoingsowouldrequireaninterproceduralanalysis.Libraryreplacements,suchasreplacingprimitiveintvalueswithAtomicIntegerobjectsinJava[16],orcon-vertingprogramstouseArrayListinsteadofVector.Programgraphsgenerallymodellanguagesemantics,notlibrarysemantics,andthereforeareincapableofexpressingtheinvariantsthattheserefactoringsmaintain.X.CONCLUSIONS&FUTUREWORKInthispaper,weclassi(cid:2)edrefactoringpreconditionsasen-suringinputvalidity,compilability,andbehaviorpreservation,andweproposedatechniqueformanycompilabilityandpreservationpreconditionstobecheckedaftertransformationinagenericway.Weshowedthat,ifessentialsemanticrelationshipsaretreatedasedgesinaprogramgraph,theseedgescanbeclassi(cid:2)edbasedontheirrelationshiptothemod-i(cid:2)edsubtree(s).Thepreservationrequirementsforcommonrefactoringscanbeexpressedbyindicating,foreachkindofedge,whetherasubsetorsupersetofthoseedgesshouldbepreserved.Byexploitinganisomorphismbetweengraphnodesandtextualintervals,thepreservationcheckingalgorithmcanbeimplementedinawaythatisbothef(cid:2)cientandlanguageindependent.WeimplementedthistechniqueinalibraryandappliedittorefactoringsforFortran95,PHP5,andBC.Muchfutureworkispossible.Whendifferentialprecon-ditioncheckingisused,howdoesitaffecttheamountoftimetakentoimplementarefactoring?Dorefactoringsimplementedwithdifferentialpreconditioncheckingtendtohavemoreorfewerbugsthanthoseimplementedwithtra-ditionalpreconditionchecks?Bothofthesequestionswillrequireempiricaldatafrommanydeveloperstoanswercon-clusively.Whatotherrefactoringscanbeimplementedusingthepreservationspeci(cid:2)cationsdescribedinthispaper?Canaprogramgraphrepresentationbeextendedtoovercomethelimitationsoutlinedintheprevioussection?CanitmodelCpreprocessordirectives?Isitusefultoextendadifferentialpreconditioncheckerwithexpensiveinterproceduralanalysesforthepurposesoftestingbuttoreplacetheseanalyseswithcheaper,traditionalpreconditionchecksinproduction?Wehopethatresearcherswilladdresstheseandotherquestionsaboutdifferentialpreconditioncheckinginthefuture.ACKNOWLEDGMENTThisresearchispartoftheBlueWaterssustained-petascalecomputingproject,whichissupportedbytheNationalScienceFoundation(awardnumberOCI07-25070)andthestateofIlli-nois.BlueWatersisajointeffortoftheUniversityofIllinoisatUrbana-Champaign,itsNationalCenterforSupercomput-ingApplications,IBM,andtheGreatLakesConsortiumforPetascaleComputation.Theauthorswouldliketothanktheanonymousreviewers,aswellasRobBocchino,JohnBrant,BrettDaniel,DannyDig,MatthewFotzler,MilosGligoric,VilasJagannath,AshleyKasza,DarkoMarinov,StasNegara,andmembersoftheBrettDanielSoftwareEngineeringSemi-narforprovidinginvaluablefeedbackonearlierdraftsofthispaper.REFERENCES[1]J.L.OverbeyandR.E.Johnson,(cid:147)Generatingrewritableabstractsyntaxtrees,(cid:148)inSLE2008,ser.LNCS,vol.5452,pp.114(cid:150)133.[2]K.KennedyandJ.R.Allen,Optimizingcompilersformodernarchitectures:adependence-basedapproach.SanFrancisco:MorganKaufmann,2002.[3]M.Sch¤aferandO.deMoor,(cid:147)Specifyingandimplement-ingrefactorings,(cid:148)inSPLASH’10.[4]M.Sch¤afer,T.Ekman,andO.deMoor,(cid:147)SoundandextensiblerenamingforJava,(cid:148)inOOPSLA’08.[5]M.Sch¤afer,M.Verbaere,T.Ekman,andO.deMoor,(cid:147)Steppingstonesovertherefactoringrubicon(cid:150)lightweightlanguageextensionstoeasilyrealiserefac-torings,(cid:148)inECOOP’09.[6]M.Sch¤afer,J.Dolby,M.Sridharan,F.Tip,andE.Torlak,(cid:147)CorrectrefactoringofconcurrentJavacode,(cid:148)inECOOP’10.[7]C.Reichenbach,D.Coughlin,andA.Diwan,(cid:147)Programmetamorphosis,(cid:148)inECOOP’09.[8]M.Verbaere,R.Ettinger,andO.deMoor,(cid:147)JunGL:ascriptinglanguageforrefactoring,(cid:148)inICSE’06.[9]B.Daniel,D.Dig,K.Garcia,andD.Marinov,(cid:147)Auto-matedtestingofrefactoringengines,(cid:148)inFSE’07.[10]J.L.Overbey,(cid:147)Atoolkitforconstructingrefactoringengines,(cid:148)Ph.D.dissertation,UniversityofIllinoisatUrbana-Champaign,2011.[11]T.Mens,N.VanEetvelde,S.Demeyer,andD.Janssens,(cid:147)Formalizingrefactoringswithgraphtransformations,(cid:148)J.Softw.Maint.Evol.,vol.17,no.4,pp.247(cid:150)276,2005.[12]J.L.Overbey,M.J.Fotzler,A.J.Kasza,andR.E.Johnson,(cid:147)Acollectionofrefactoringspeci(cid:2)ca-tionsforFortran95,BC,andPHP5,(cid:148)Tech.Rep.http://jeff.over.bz/papers/2011/tr-refacs.pdf,2011.[13]E.Murphy-Hill,C.Parnin,andA.P.Black,(cid:147)Howwerefactor,andhowweknowit,(cid:148)inICSE’09.[14](cid:147)Refactoringbenchmarksforextractmethod,(cid:148)http://c2.com/cgi/wiki?RefactoringBenchmarksForExtractMethod.[15](cid:147)Refactoringbenchmarksforpullupmethod,(cid:148)http://c2.com/cgi/wiki?RefactoringBenchmarksForPullUpMethod.[16]D.Dig,J.Marrero,andM.D.Ernst,(cid:147)RefactoringsequentialJavacodeforconcurrencyviaconcurrentlibraries,(cid:148)inICSE’09,2009,pp.397(cid:150)407.g u e s t   e d i t o r s ’   i n t r o d u c t i o n

.

Why Explore
Object Methodsd
Patternsd and
Architectures-
STEPHEN J. M EL
, Project Technology
, University of Illinois
R ALPH
HNSON

These three technologies each offer the
promise of a solution to the Òsoftware
crisis.Ó Yet each camp advocates
quite different means for
achieving that solution. 
Resolving their conflicting
views will likely require
a re-examination of core
assumptions.

O
bjects ,
  patterns ,
  and   architectures   ha ve   much   in   common .
Each
holds  the  promise  of  solving  chronic  software  development  prob-
  even  higher  maintenance  costs,
  high  development  costs,
lems:
  low
le vels   of   reuse ,
  unbelie vable (cid:209)and   unreali zed (cid:209)schedules ,
  and   so
 ele-
 Advocates have proposed excellent reasons(cid:209)in some cases,
on.
vating  them  to  universal  propositions(cid:209)as  to  why  their  particular  technology  can 
(cid:210)solve  the
software  crisis.
  All  advocates  stress  domain  analysis  and  reuse.
  The  object  methodologists
and patterns people discuss architecture,
 and object-oriented programming is popular in both
  suggest  processes  for
the  architectures  and  patterns  camp.
  They  all  use  modeling  notations,
developers  to  follow,
  advocate  tools  for  automating  software  development,
  and  produce  ref-
erence models.

I E E E   S O F T W A R E

0 7 4 0 - 7 4 5 9 / 9 7 / $ 1 0 . 0 0   ©   1 9 9 7   I E E E

2 7

 
(cid:211)
L
O
R
J
O
.

g u e s t   e d i t o r s ’   i n t r o d u c t i o n

PARADIGMS IN CONFLICT

take a back
 seat.
Each  of  these  descriptions  is  a  cari-
In its purest form,
 a domain-specific
cature,
 but they show that practitioners
 the
In spite of their many similarities,
s o f t w a r e   a r c h i t e c t u r e   i s   c l o s e l y
and   researchers   in   each   area   empha-
 proposals often conflict.
different camps(cid:213)
matched  to  a  specific 
kind  of  problem.
si zed   different   issues .
  And   in   some
Sometimes  this  is  just  because  they  use
No one assumes that a DSSA be inher
 they conflict.
cases,
different   definitions   for   words   li ke
  a n
e n t l y   o b j e c t - o r i e n t e d ;
  i n d e e d ,
One   e xample   of   a  
question   with
(cid:210)analysis,
 and 
(cid:210)domain,
(cid:210)architecture.
object-oriented  architecture  is  just  one
How   should
conflicting   answers   is  
  Once   the   architecture   has
possibility .
g e n e r i c   i n f o r m a t i o n   b e   t r e a t e d ?
Everyone agrees 
been selected,
 it provides the developer
Much   of   the   information   in   our   soft-
with  a  set  of  high-level  abstractions  in
w a r e   i s   g e n e r i c   t o   t h e   p r o b l e m
that all topics
which to express the application,
 so the
domain ,
  while   other   information   is
developer  moves 
(cid:210)backward(cid:211)
  from  the
specific   to   the   particular   problem   we
are impor tant,
architecture   to   the   problem   specifica
are   sol ving .
How   do   we   separate   the
tion.
  Notations  and  process  both  tend
two   and   encode   the   generic   informa-
they just disagree 
t o   b e   s p e c i f i c   t o   t h e   a r c h i t e c t u r e ,
tion so that it can be reused?
¤ Object -oriented   de velopers   tend
as to which is
rather  than  universal.
  Tools  may  sup -
to   encode   both   generic   and   specific
  sophisticated   code -
port   speciali zed ,
most impor tant.
information   in   different   objects   and
g e n e r a t i o n   s c h e m e s .
  T h e   s o f t w a r e
classes .
  Sometimes   they   use   abstract
architecture is itself a reference model.
classes   to   encode   generic   information
Work
 on architectural styles focuses
and put specific information in the con-
less   on   the   problem   and   more   on   the
crete   classes .
  Other   times   the   classes
  an  architectural  style
solution.
  Ideally,
represent  generic  information  and  the
can   be   applied   to   a   broad   range   of
specific information is in the scripts that
problems .
(cid:210)Objects (cid:211)
  is   just   one   style
instantiate   classes ,
  parameteri ze   the
among   many .
Each   architectural   style
instances,
 and connect them together.
has  its  own  notation  that  describes  the
¤ Domain -specific   software   archi-
s y s t e m   s t r u c t u r e ,
v o c a b u l a r y ,
  a n d
tects encode the generic information in
interaction   patterns   of   systems   built
a   DSSA   supported   by   special -purpose
with   that   style .
  One   conse quence   of
languages,
 encode the problem-specific
being   so   broadly   focused   is   that   it   is
information   using   those   languages ,
harder   to   ma ke   powerful   tools   and   to
then translate from the special-purpose
  so   less
specify   complete   processes ,
languages to the final code.
work
 has been done in these areas.
¤ P e o p l e   w o r k i n g   w i t h   p a t t e r n s
People   who   wor k
  with   design   pat -
question ,
view   this   as   an   unimportant  
terns observe that certain patterns man-
because what is important is to discover
  but
ifest  repeatedly  across  applications,
the   generic   patterns   and   document
in   different   guises .
  Contention   for   a
them.
 The software developer can then
resource,
  for  example,
  appears  in  hotel
decide  whether  to  encode  the  patterns
reservation systems and in printer man-
in   objects ,
  use   a   domain -specific   lan-
  This   pattern   can   be   described
agers .
 or just use the patterns to write a
guage,
and reused in each of these systems,
 but
single ,
  specific   program .
  The   biggest
with   different   names .
  The   de veloper
gain   comes   from   understanding   the
embeds  the  appropriate  name  into  the
patterns and making them explicit.
generic   logic   of   resource   contention
  each  of  these  points  is  over -
Again,
management .
  A   de veloper   wor king   in
simplified .
  Some   object -oriented   sys-
this   style   connects   a   problem   to   its
tems use special purpose languages and
solution by recognizing that the pattern
code   generation ,
  some   patterns   focus
  Notations   and   processes   are
applies .
on   how   to   separate   generic   informa-
used  eclectically.
Reference  models  are
tion   from   specific   information   in   an
  emphasis  is  placed  on  documenta-
all:
o b j e c t - o r i e n t e d   s y s t e m ,
  a n d   s o m e
  rather   than   on
tion   and   literary   style ,
DSSA  articles  focus  on  the  patterns  in
tools or code generation.

This  can  lead  to  unnecessary  misunder-
standings ,
  confusion ,
  and   e ven   argu -
ments   when   a   listener   assumes   that   a
s p e a k e r   h a s   t h e   s a m e   d e f i n i t i o n s ,
assumptions,
 and context.
  people   differ   in   what
Other   times ,
they   consider   most   important .
Each
group tends to focus on some topics to
the   e xclusion   of   others .
  In   general ,
e v e r y o n e   a g r e e s   t h a t   a l l   t o p i c s   a r e
  t h e y   j u s t   d i s a g r e e   a s   t o
i m p o r t a n t ,
which   is   most   important .
  This   can
affect the final conclusion.
M o s t   o b j e c t - o r i e n t e d   m e t h o d s
  notations ,
emphasi ze   concepts ,
  and
  In  contrast  to
processes  for  developers.
the earlier structured methods,
 they use
the same notation for both analysis and
design,
  and  try  to  reduce  the  transition
from   analysis   to   design   by   how   they
  Although   tools
organi ze   the   models .
are  recognized  as  important,
  originally
they   did   little   more   than   help   draw   a
method (cid:213)s   notation   and   na vigate   large
 and only later began to support
models,
semantics   and   code   generation .
  Most
methods   target   software   de velopment
in general or focus on broad areas such
as   real -time   systems .
Reference   mod -
els(cid:209)the production of completed mod -
els   that   ser ve   as   a   reference   to   others
wor king   in   the   same   area (cid:209)generally

2 8

J A N U A R Y   1 9 9 7

(cid:211)
 
(cid:211)
(cid:211)
 
 
-
-
 
 
 
 
(cid:210)
(cid:211)
 
.

ARTICLE SUMMARIES: OBJECT METHODS, PATTERNS, AND ARCHITECTURES

A Unified Ob ject
Topology, pp.  3
1- 3
5.
William Tepfenhart and
James Cusick
This  article  offers  a
structure  for  understanding
how  
kits ,
 framewor ks ,
 and
systems  fit  in  with  patterns ,
architectural  styles ,
 and
domain  analysis .
 The  arti-
cle  applies  the  structure  to
show  what  information (cid:209)
specifically ,
 patterns  and
architectural  styles (cid:209)are
re quired  to  de velop  
kits ,
framewor ks ,
 and  systems ,
and  how  that  information
fits  into  a  systems  de velop-
ment  lifecycle .
 The  topolo-
gy  also  identifies  potential
products  and  research
areas .

Idioms and Patterns as
Architectural  Literature,
pp.  3
6- 4
2.
James Coplien
One  of  the  leaders  of  the
patterns  community  and

He

the  author  of  Advanced C +
Coplien  describes  his  
view
of  why  patterns  are  impor-
tant ,
 and  what  they  con -
tribute  to  architecture .
argues  that  their  
value
e xtends  far  beyond  objects ,
that  they  are  a  powerful
way  of  thin king  about  soft-
ware  de velopment  organi -
zations  as  well  as  the  archi-
tecture  of  the  systems  they
de velop .

Architectural Styles,
Design Patterns, and
Ob jects, pp.  4
3- 5
2.
Robert Monroe , Andrew
Kompanek ,  Ralph Melton ,
and David  Garlan
This  article  shows  the
relationship  between  soft-
ware  architecture  and
object -oriented  design ,
 and
shows  that  neither  of  them
subsume  the  other  because
they  address  different  
(if
o verlapping )
 issues  and  use
different  abstraction  mech-
anisms .
 The  authors  also

argue  that  architectural
styles  and  design  patterns
are  complementary  mecha -
nisms  for  encapsulating
design  e xpertise ,
 and  that
architectural  styles  are
probably  more  directly
comparable  to  object -ori-
ented  methodologies  than
to  patterns .

Using Patterns to
Improve Our Architectural
Vision, pp.  5
3- 5
9.
Norm  Kerth and Ward
Cunningham
Christopher  Ale xander
is  an  architect  who  in vented
 for  use
the  term  
(cid:210)pattern (cid:211)
in  building  towns ,
 homes ,
and  offices .
Kerth  and
Cunning -ham  show  how
concepts  in  patterns  and
architecture  for  building
may  be  applied  in  software .
They  e xplore  the  relation-
ship  between  objects  and
architecture  and  propose
that  Ale xander (cid:213)s  concept  of
a  
(cid:210)pattern  language (cid:211)
 can  be

used  to  fill  the  gap  between
the  two (cid:209)especially  as  pro-
ject  si ze  increases .

Recursive Design of an
Application-Independent
Architecture, pp.  6
1- 7
2.
Sally Shlaer and Stephen
Mellor
This  article  defines  a
software  architecture  as  a
virtual  machine  that  under-
lies  a  system .
 The  authors
use  an  object -oriented
analysis  method  to  model
both  the  application  and
the  architecture ,
 and  they
use  formali zed  patterns  to
describe  how  to  map  appli-
cation  concepts  to  the
architecture .
 The  result  has
the  code  generation  ability
of  the  tools  for  a  domain -
specific  software  architec
 but  is  based  on  gener -
ture ,
al  notations .
 The  authors
use  the  de velopment  of  the
Timepoint  application  to
illustrate  how  their  method
wor ks .

FIVE ATTEMPTS AT SYNTHESIS

the   system   rather   than   on   languages
 refer to the box
each article,
 above.
We
lems   of   software   de velopment .
  It   is   possible   to
for   describing   them .
So   we   as k
  as   you   read   these
  you ,
further had the impression(cid:209)and a few
view,
reconcile these different points of 
  to   focus   your   attention   on
articles ,
stri king   e xamples (cid:209)that   indicated   that
but it requires effort to think
 nontradi-
assumptions ,
  definitions ,
  and   conte xt .
the   paradigms   were   in   conflict .
Good
tionally,
 whatever our tradition is.
When  you  read  something  that  seems
fodder ,
  you   might   thin k
  for   a   special
peculiar,
 or even absurd,
 think
 carefully
issue.
about what assumptions and definitions
  we   soon   found
But   as   co -editors ,
would  make  this  statement  sensible  in
that   we   had   trouble   understanding
the mind of the authors.
  Coming   from   different
each   other .
We
And   so   to   this   special   issue .
  consider
To  
kic k
  off   this   e xercise ,
bac kgrounds (cid:209)object   methods  
versus
have selected five articles that each take
  on   page  
questions   in   the   bo x
the  
p a t t e r n s (cid:209) h a d   g i v e n   u s   d i f f e r e n t
rather different perspectives.
However,
Write down your answers on a separate
vocabularies   and   we   did   not   ha ve   an
 architectures,
all of them relate objects,
ve   finished
sheet   of   paper .
When   you (cid:213)
easy   way   to   reconcile   our   different
and  patterns.
We  asked  the  authors  to
reading   the   articles ,
  come   bac k
  and
interests  and  concerns.
  Over  time ,
  we
focus   on   defining   their   assumptions
c o n s i d e r   t h e  
q u e s t i o n s   o n c e   m o r e .
c a m e   t o   r e a l i z e   t h a t   a   s y n t h e s i s   o f
and   definitions   so   as   to   ma ke   more
 At the least,
Compare your answers.
 we
these  three  topics  will  require  that   we
clear   the   reasons   that   they   draw   the
hope   that   you   will   find   the  
questions
break
 down core assumptions and look
a t   w h y a n   a s s u m p t i o n   i s   s o   d e e p l y
conclusions   they   do .
We   belie ve   that
more meaningful.
embedded in a particular camp .
the articles make sense within the con-
We  hope  that  this  issue(cid:213)s  articles  will
te xt   that   each   defines .
But   we   also
help you understand both the similarities
believe  that  these  articles  are  nonsense
e began   wor k
  on   this   special
and  differences  in  these  fields  and  will
if   you   don (cid:213)t   hold   at   least   some   of   the
issue  with  the  assumption  that
help  you  appreciate  and  use  work
  based
assumptions  that  animated  each  article
e a c h   o f   t h e s e   t o p i c s   h o l d s   o u t   t h e
on assumptions different than yours.
in   the   first   place .
For   a   summary   of
promise   of   sol ving   the   chronic   prob-

I E E E   S O F T W A R E

2 9

 
 
 
 
 
 
3
0
.
 
 
 
,
+
,
 
 
-
 
W
u
.

DEFINING OBJECT METHODS, PATTERNS, AND ARCHITECTURES

architecture,
When you use the term 
 what do you mean?
A. The high-level design of the system.
The structure of the lower-level,
 more technical 
layers of the system,
 such as multiprocessing,
distribution,
 and persistence.
C. The structure of a particular system layer,
such as the architecture of the user interface 
package or the architecture of the bank
Rules that pervade the structure of the system.
Architecture is outside the structure of the system.
architecture,
 how much detail

D.

When you use the term 
is implied?
 because architecture is high-level.
A. Not much,
Hence,
 we can talk
 about types of architecture,
Filters,
such as Pipes-and-
Rule-based,
Transaction-oriented,
 and so on.
A good deal,
 because to be able to talk
 about it we 
must be able to define an architecture precisely,
perhaps using an architecture description
language.
C. A great deal,
 because to be useful an architecture 
must be implemented.
Note: Some people use the terms architectural style and architecture
to distinguish between the high-level concept and the two more
detailed ones.

domain,
 what do you mean?

When you use the term 
Is it one of
A. An area of interest in a 
vertical market such as 
banking,
 insurance,
 or manufacturing?
An area of interest in a horizontal market such as 
real-time,
 or transaction-based,
 and so on?
 does the domain include information
If you answered 
(cid:210)A,
about the organization of the software?
 If you answered 
 about domain analysis for a 
 does it make sense to talk
transaction-based domain?
What would the conceptual 
entities be in such a domain?

analysis,
 how do you think
When you use the term 
 about it?
You need to perform an analysis to produce a 
A.
statement of requirements before design can begin 
for those requirements.
A complete analysis is futile because the require-
ments change as soon as you begin imple-
mentation.
C. The best form of analysis is a pre-existing pattern 
that represents the combined wisdom of those who
have worked in this domain.

 about notations to denote 
How do you think
various stages
in the development lifecycle?
 Do you
A. Think
 that notation should be specialized for the 
particular project at hand?
Think
 there should be a single notation that can be
used universally for all problem areas?
C. Think
 there should be a single notation that can be
used for all designs?

How do you think
 about tools?
 Do they
A. Derive primarily from the notational elements
of a method?
Support the architecture first,
 and translate the 
problem specification in those terms?
C. Support the specifics of the particular pattern 
you(cid:213)re working with?

Should there be a seamless transition between analysis
and design?
Yes,
A.
 our notation takes us from the form of the 
problem specification to the form of the software.
Yes,
 we decide on the form of the architecture,
 and
then express the application in those terms.
 the structure of the application and the struc-
C. No,
ture of the software do not 
(necessarily)
 match 
each other.

n J
. M
teaches and does research  at
Project Technology.
He began his career  at  CE
RN  in
Switzerland,
 where he supported accelerator control
systems.
 Subsequently,
 at 
Lawrence 
Berkeley
Laboratory,
 he led a team responsible for pro viding
control systems for several real-time applications.
BA in computer science from
Mellor recei ved a 
the University of 
Essex
 in the United 
Kingdom .

h J
is  a senior research scientist at the
His  research  interests include
University of Illinois.
 especially design patterns and
object-oriented design,
the design of object-oriented frameworks .
He is a co-
Helm,
Erich 
author with  
John
 and 
Richard 
Gamma ,
Elements  of  
Vlissides of 
Reusable
(cid:210)Design Patterns:
Object-Oriented Programming,
 and was one  of the
organizers of the original conference  on  Pattern
Languages of  Programs .
Johnson received a 
Knox
BS from 
 College and a PhD
from Cornell.
He is a member of the IE
 Computer Society and ACM.

 Ninth Street,
questions about this article to Mellor at Project  Technology ,
Address 
 CA ,
Ber keley ,
 Suite  
 johnson@cs.uiuc.edu .
 Springfield A ve,
University  of  Illinois ,
 Department of Computer Science ,
 Urbana,
 I L

 steve @

projtech.com;

 or to  

Johnson at

3 0

J A N U A R Y   1 9 9 7

1
.
B
.
 
.
E
.
2
.
 
 
 
 
B
.
 
3
.
B
.
(cid:211)
(cid:210)
B
,
(cid:211)
 
4
.
B
.
5
.
B
.
6
.
B
.
7
.
B
.
S
t
e
p
h
e
e
l
l
o
r
 
R
a
l
p
o
h
n
s
o
n
 
 
 
 
(cid:211)
 
E
E
 
2
5
6
0
2
1
4
,
 
 
9
4
7
0
8
;
 
1
3
0
4
 
W
.
 
6
1
8
0
1
;
2011 Ninth Working IEEE/IFIP Conference on Software Architecture

Patterns Transform Architectures

Munawar HaÞz

Paul Adamczyk

Ralph Johnson

-Pattern; Architecture; Transformation; Security

I. IN T RO D U C T I O N

, p. 365
C H R I S TO P H E R A L E X A N D E R

A b
—Software patterns have been used to guide de-
velopers and to disseminate expert knowledge. But patterns
can also be thought of as program transformations. Security
patterns are architectural. Therefore, program transformations
derived from those patterns transform architecture. This paper
describes how we used a catalog of security patterns to produce
a catalog of security-oriented program transformations. These
transformations can be used to make architectural changes
that make systems more secure. This paper is a ﬁrst example
of applying patterns to actively transform architectures.

meaning they are architectural [10]. Security patterns can
be applied to remove existing vulnerabilities or to add
protection against new attacks. Similar to design patterns, it
is easier to apply security patterns if there are speciÞcations
and tools for applying them to software. We have developed
such speciÞcations and tools as security-oriented program
transformations [11]. Similarly to design patterns, some
transformations can be applied automatically by a tool,
while others deÞne concrete steps but require programmer
intervention. However, improving security of a (new or
existing) system is different than refactoring, because their
goal is toi
the design, not to preserve the behavior.
This paper makes two contributions. First, it describes
Within this process, every individual act of building is
how to improve the security of a system by applying
a process in which space gets differentiated. It is not a
process of addition, in which pre-formed parts are
security-oriented program transformations [12]. These pro-
combined to create a whole; but a process of
gram transformations are not silver bullets; using them
unfolding, like the evolution of an embryo, in which
requires skill and knowledge of the program being trans-
the whole precedes its parts, and actually gives birth
formed. They are instead power tools that make it easier to
to them, by splitting.
systematically change the architecture. The paper describes
examples of applying program transformations, using a one-
step transformation tool as well as following a step-by-step
Patterns [1] [2] document best practices in software design
reÞnement process, in which the steps can be automated.
and architecture. They describe both the approach and the
The second contribution is that we support AlexanderÕs
reasoning behind it. Patterns can be used to design a system,
claim that individual acts of design are processes that
to drive design changes, or to document design [3]. As the
transform an old design to a new one. Thus, patterns can
quote from Christopher Alexander [4] shows, they can also
be converted from a passive guideline to a set of tools
be thought of as processes that transform the system under
that developers can use. Not all patterns can be turned into
design. Pattern descriptions can treat a pattern as a process if
program transformations, and it is possible that there are
they give example systems before and after the pattern. But
entire classes of patterns that cannot be automated. But we
most pattern descriptions treat patterns more like artifacts
have shown at least one class of patterns that can.
than processes that produce artifacts.
First, the paper describes how security patterns were ana-
The main book that describes software patterns as pro-
lyzed to convert them into program transformations. Then it
cesses is Joshua KerievskyÕs ÒRefactoring To PatternsÓ [5].
shows some example transformations, focusing on those that
This book shows how patterns from ÒDesign PatternsÓ [1]
can affect the entire architecture. Finally, it discusses several
can be introduced to a program through a series of refac-
open issues of using patterns and program transformations.
torings [6], i.e., small behavior-preserving program transfor-
mations. By combining refactorings and patterns, Kerievsky
II. SE C U R I T Y PAT T E R N S
treats patterns as complex program transformations rather
than as artifacts in the Þnal system. But Kerievsky did this
A security pattern describes a solution that experts use to
only for a small set of patterns. Can other patterns be treated
solve a security problem in a context. We have been main-
as program transformations? What are the advantages and
taining a comprehensive catalog of all published security
disadvantages of thinking of patterns as processes?
patterns [7]. The security pattern catalog currently contains
96 patterns. The catalog is a union of all security patterns
The domain of security has its own patterns [7] [8] [9].
that appear in many books, catalogs and papers.
Some are simple, but most patterns affect entire systems,

978-0-7695-4351
1 $26.00 © 201
1 IEEE
-2/
978-0-7695-4351-2/11 $26.00 ' 2011 IEEE
109/WICSA.201
DOI 10.1
1.39
DOI 10.1109/WICSA.2011.39

242
242

U
n
i
v
e
r
s
i
t
y
o
f
I
l
l
i
n
o
i
s
E
m
a
i
l
:
m
h
a
Þ
z
@
i
l
l
i
n
o
i
s
.
e
d
u
E
m
a
i
l
:
p
a
u
l
.
a
d
a
m
c
z
y
k
@
g
m
a
i
l
.
c
o
m
U
n
i
v
e
r
s
i
t
y
o
f
I
l
l
i
n
o
i
s
E
m
a
i
l
:
j
o
h
n
s
o
n
@
i
l
l
i
n
o
i
s
.
e
d
u
s
t
r
a
c
t
K
e
y
w
o
r
d
s
T
h
e
T
i
m
e
l
e
s
s
W
a
y
o
f
B
u
i
l
d
i
n
g
m
p
r
o
v
e
∈
(cid:48)
(cid:49)
(cid:49)
←
(cid:78)
(cid:105)
(cid:110)
(cid:116)
(cid:104)
←
(cid:87)
(cid:111)
(cid:114)
(cid:107)
(cid:105)
(cid:110)
}
←
(cid:67)
(cid:111)
(cid:110)
{
(cid:101)
(cid:114)
(cid:101)
(cid:110)
(cid:99)
(cid:101)
←
(cid:111)
(cid:110)
←
(cid:83)
(cid:111)
{
(cid:116)
(cid:119)
(cid:97)
(cid:114)
(cid:101)
←
(cid:65)
(cid:114)
(cid:99)
(cid:104)
(cid:105)
(cid:116)
(cid:101)
(cid:99)
(cid:116)
(cid:117)
(cid:114)
(cid:101)
1
There are 3 books on security patterns. Schumacher led
a working group on security patterns to write a security
pattern book [8]. This book had 46 security patterns from
the domain of enterprise security and risk management,
identiÞcation and authentication, access control, accounting,
Þrewall architecture, and secure internet applications. This
book aggregates many previous works, including the Þrst
catalog of security patterns [13], Schumacher [14] and Fer-
nandezÕs [15] [16] work on security patterns, etc. In another
book, Steel et al. [9] described 23 security patterns for J2EE
based applications, Web services and identity management.
MicrosoftÕs Patterns and Practices group published the third
Table I
C L A S S I FI C AT I O N O F SE C U R I T Y PAT T E R N S U S I N G T H E E N T E R P R I S E
book [17] that included 18 patterns.
A R C H I T E C T U R A L SPAC E O R G A N I Z I N G TA B L E
There are several pattern catalogs that were not published
as books. Blakley and Heath [18] compiled a security pattern
an artifact: data (what?), function (how?), network (where?),
catalog with the members of the Open Group forum. It
people (who?), time (when?) and motivation (why?).
contained 13 patterns: 5 for improving reliability, and 8 for
We applied a tabular classiÞcation scheme [7] which uses
security. Kienzle et al. [19] listed 26 patterns and 3 mini
ÔEnterprise Architectural Space Organizing TableÕ [27]. Out
patterns in their catalog. Romanosky [20] [21] compiled two
of the 7 columns of the table, 6 are from the Zachman
catalogs containing 12 security patterns in total.
framework. The seventh column (Scorecard) includes pat-
We have created two pattern catalogs. The Þrst stems
terns for testing. The rows describe stakeholders similar to
from the study of the evolution of mail transfer agent
the Zachman framework, but they have been speciÞed in
architecture [22]. This contains 11 security patterns, and 4
roles of Þner granularity.
reliability patterns. These patterns are not speciÞc to mail
Table I shows how the security patterns are classiÞed
transfer agents; they can be used by the designers of other
using this tabular scheme as well as some sample patterns. It
secure systems. Our second catalog compiles a collection of
shows only relevant rows of the larger table. As an example
12 privacy design patterns [23].
A F E D ATA ST RU C T U R E [22]
of classiÞcation, consider the S
The pattern sources describe 174 security patterns, but
pattern. This pattern is applied to remove the array bounds
with many overlaps. We developed our catalog of 96 patterns
checking vulnerability in an unsafe programming language,
by removing the overlaps. For example, patterns for authenti-
such as C. SA F E D ATA ST RU C T U R E advocates the inclusion
cation have been listed in a number of pattern catalogs under
of length and allocated memory information with a data
U T H E N T I C ATO R [16] [8], SE C U R I T Y
different names, e.g., A
structure. This pattern is considered in the development
PROV I D E R [20], AU T H E N T I C AT E D SE S S I O N [19], AU -
phase of an application when the safe string processing
T H E N T I C AT I O N E N F O R C E R [9], and DI R E C T A U T H E N T I -
libraries are written or re-used. Hence this pattern Þts
C AT I O N [17]. We have one AU T H E N T I C AT I O N E N F O R C E R
row ofA
into the cell deÞned by the
pattern for authentication, removing language-speciÞc and
perspective and the
column.
catalog-speciÞc descriptions of this pattern [7].
The tabular scheme has a number of problems. It can not
classify 16 patterns because they fall into multiple cells in
A catalog of 96 patterns is overwhelming. It is hard for
the table; Table I shows some examples. The scheme fails
developers to Þnd a pattern they need, let alone know when
to distinguish low level patterns from high level patterns.
to use it. We attempted to organize the security patterns [7]
We improved it using a classiÞcation scheme [7] that uses
by classifying them into small, correlated sets. This paper
domain knowledge (threat model) and embraces hierarchy.
narrates the derivation of a classiÞcation scheme that led to
But this tabular classiÞcation helped in identifying the
the identiÞcation of the patterns that can be described as
patterns that can be described as program transformations.
security-oriented program transformations.
The next section describes this process.
Several security pattern authors [8] [24] [25] have at-
III. FRO M PAT T E R N S TO PRO G R A M T R A N S F O R M AT I O N S
tempted to classify their respective pattern catalogs using
the Zachman framework. Zachman framework [26] was
We derived a security-oriented program transformation
introduced in 1987 as a table. Its 5 rows describe the
catalog by surveying the problem domain and solution
levels of information model from the perspective of various
domain of security. We identiÞed the most important security
stakeholders, e.g., the customer or the owner, the designer,
problems by surveying various vulnerability-trend reports.
the builder, etc. The 6 columns describe ways of describing
Then we identiÞed the solutions for these problems by sur-

243243

A
.
S
e
c
u
r
i
t
y
P
a
t
t
e
r
n
S
o
u
r
c
e
s
B
.
O
r
g
a
n
i
z
i
n
g
t
h
e
P
a
t
t
e
r
n
C
a
t
a
l
o
g
D
e
v
e
l
o
p
e
r
p
p
l
i
c
a
t
i
o
n
A
r
c
h
i
t
e
c
t
u
r
e
D
a
t
a
veying the security pattern catalog. Currently, the security-
hardware. PAC K E T FI LT E R FI R E WA L L [8] and STAT E F U L
FI R E WA L L [8] guide practitioners how to select the most ap-
oriented program transformation catalog contains 37 trans-
E M I L I TA R I Z E D Z O N E [8] guides
propriate Þrewall, while D
formations. 30 transformations come from 96 patterns in the
how to deploy multiple Þrewalls.
security pattern catalog. The remaining 7 transformations
The remaining 16 patterns could not be classiÞed in Table
originate from well-known security solutions.
I, because they straddled multiple cells in the classiÞcation
The approach can be summarized in four steps:
table. We counted the patterns that fell in either of the data
(A) Analyzing the problem domain and identifying relevant
or function columns and the rows grouped by application
security problems.
architecture perspective. There were 9 patterns.
(B) Analyzing security pattern catalog for candidates that
The remaining 7 patterns are about software processes.
can be described as program transformations.
There are patterns for asset evaluation, risk assessment, and
(C) Identifying other well-known security solutions that can
threat modeling [8] that describe a process, and can not be
be described as program transformations.
described as a program transformations of software.
(D) Describing the mechanism of security-oriented program
In total, 79 patterns were selected from the catalog. We
transformations.
analyzed these patterns and identiÞed the ones that can be
The following sections describe these steps.
described as program transformations in the next step.
2)
Out of the remaining 79 patterns, 14
We studied vulnerability trend reports [28] [29] [30] [31]
describe very high level solutions, 26 describe solutions that
to Þnd the important security problems. These tended to Þt
are hard to implement, and 10 describe solutions common to
into 5 vulnerability classes: input validation vulnerabilities,
other patterns. Removing these leaves 29 security patterns,
authentication vulnerabilities, access control vulnerabilities,
that contribute to 30 program transformations. Table II
error handling vulnerabilities, and denial of service vulner-
shows how the 79 patterns are partitioned.
abilities. These vulnerability classes have been derived pri-
14 patterns prescribe high level solutions. An example of
marily from the OWASP [28] list, and have been supported
E F E N S E I N D E P T H [32]; it is a security
such a pattern is D
by other vulnerability trend reports [29] [30] [31].
principle that is fundamental in any security design, but it
Next, we identiÞed the relevant solutions.
is too general to form a program transformation. Another
example is the AN O N Y M I T Y SE T [23] pattern. It is a core
Our pattern catalog accumulates the experience of the
pattern for privacy-preserving applications. It suggests that
entire security pattern community and is a fair representation
the fundamental principle of keeping information private is
of the solution domain of security. We analyzed the catalog
to mix it with other information and make private infor-
and found 30 security solutions that can be described as
mation indistinguishable. But implementing the high level
program transformations. This was done in two steps.
solution depends on the context of an application; it cannot
(1) We used the tabular classiÞcation scheme for security
be expressed as a general purpose program transformation.
patterns to identify patterns that describe solutions
26 security patterns provide solutions that are too com-
applicable to software. This step resulted in 79 patterns.
I M I T E D A C C E S S [8] and FU L L A C C E S S
plex. For example, L
(2) Next, we analyzed the implementation mechanism of
W I T H E R RO R S [8] describe how secure user interfaces
79 patterns. Some patterns describe high-level poli-
can be designed. For an application with many users and
cies, some describe solutions that are too difÞcult to
different privilege levels, one option is to give each user
implement; also there are patterns that describe the
a limited view of the user interface, i.e., only the options
same technique applied in different contexts. After
that his/her privilege allows. The other option is to show all
removing these, we had 29 patterns that contributed
functions to all users, but only allow access to functions that
to 30 security-oriented program transformations.
are permitted. Graphical user interface is difÞcult to code
These two steps are described in detail.
and almost impossible to code automatically. Therefore,
1)
automatically adapting an existing user interface to follow
either options is not possible. Another example is the R
Not all security patterns are about code
O L E
and software design. The tabular classiÞcation scheme for
B A S E D A C C E S S C O N T RO L [8] pattern. This complex pattern
organizing security patterns identiÞes the patterns relevant to
introduces many context sensitive changes in the code. It is
hard to describe its general solution as a transformation.
software. Table I shows the scheme. In the table, the suitable
candidates for program transformations are patterns from the
In 10 cases, the solution mechanism of multiple secu-
rows grouped by application architecture perspective, and in
rity patterns is the same; thus multiple security patterns
correspond to one program transformation. For example,
the function and data columns. This constitutes 70 patterns.
input Þltering is an important protection mechanism that mo-
Among the 26 discarded patterns, 10 patterns are about
tivates CO N T E N T D E P E N D E N T PRO C E S S I N G [22] pattern.
non-software artifacts. Some of these patterns are related to

244244

A
.
A
n
a
l
y
z
i
n
g
t
h
e
P
r
o
b
l
e
m
D
o
m
a
i
n
B
.
A
n
a
l
y
z
i
n
g
t
h
e
S
e
c
u
r
i
t
y
P
a
t
t
e
r
n
C
a
t
a
l
o
g
U
s
i
n
g
P
a
t
t
e
r
n
C
l
a
s
s
i
Þ
c
a
t
i
o
n
S
c
h
e
m
e
t
o
F
i
n
d
R
e
l
e
-
v
a
n
t
P
a
t
t
e
r
n
s
:
F
i
n
d
i
n
g
P
a
t
t
e
r
n
s
t
h
a
t
c
o
u
l
d
b
e
D
e
s
c
r
i
b
e
d
a
s
P
r
o
g
r
a
m
T
r
a
n
s
f
o
r
m
a
t
i
o
n
s
:
Table II
FI N D I N G C A N D I DAT E S E C U R I T Y PAT T E R N S

The Þltering mechanism in an application follows the P
known security solutions. Among these are program trans-
I P E S
A N D FI LT E R S [2] architectural pattern: an input variable
formations that introduce cryptographic operations. Program
passes through a series of Þlters. The same mechanism
transformations to create a message digest, or a message
applies to other cases when data has to be modiÞed, e.g.,
signature describe how classes of Java or .NET security API
encoding or decoding data, encrypting or decrypting, using
can be composed to perform the tasks. Similarly,
parity for error detection and correction, or padding data
transformation composes Java or .NET se-
packets so that all packets are of the same length. Each of
curity API. There are security patterns that use cryptographic
solutions (CL I E N T D ATA STO R AG E [19] and EN C RY P T E D
these cases is deÞned by its own security pattern, but the
STO R AG E [19] patterns in table II), but there are no speciÞc
underlying security-oriented program transformation is the
patterns describing these cryptographic operations.
program transformation in our
same. Similarly,
O M PA RT M E N TA L I Z AT I O N [32]
transformation adds missing type infor-
catalog is a combination of C
and DI S T R I BU T E D R E S P O N S I B I L I T Y[33] patterns.
mation to prevent integer overßow errors that originate from
the use of integer datatype in an unsafe context.
29 security patterns contribute to 30 security-oriented
transforms a program to encapsulate each resource
program transformations. S
A F E D ATA ST RU C T U R E [22] pat-
and the corresponding set of permissions in one object.
tern contributes to 2 program transformations:
andS
transformation automatically analyzes a program to
. Table III lists the
identify the lowest privilege level required.
transfor-
patterns and corresponding program transformations.
mation adds user-directed white box fuzzing components.

Table III lists 7 program transformations in our catalog
that do not derive from security patterns. Instead they
The Þnal step is deÞning the mechanics of transforma-
describe how to transform a program to implement well-
tions. The mapping from a security pattern to a program

245245

P
a
r
t
i
t
i
o
n
i
n
g
S
a
f
e
L
i
b
r
a
r
y
R
e
p
l
a
c
e
m
e
n
t
a
f
e
T
y
p
e
R
e
p
l
a
c
e
m
e
n
t
C
.
P
r
o
g
r
a
m
T
r
a
n
s
f
o
r
m
a
t
i
o
n
s
f
r
o
m
O
t
h
e
r
S
o
u
r
c
e
s
E
n
c
r
y
p
-
t
i
o
n
/
D
e
c
r
y
p
t
i
o
n
E
x
p
l
i
c
i
t
T
y
p
e
E
n
f
o
r
c
e
m
e
n
t
G
u
a
r
d
e
d
O
b
j
e
c
t
L
e
a
s
t
P
r
i
v
i
l
e
g
e
F
u
z
z
i
n
g
D
.
D
e
s
c
r
i
b
i
n
g
M
e
c
h
a
n
i
s
m
o
f
P
r
o
g
r
a
m
T
r
a
n
s
f
o
r
m
a
t
i
o
n
s
Table III
L I S T O F S E C U R I T Y-O R I E N T E D P RO G R A M T R A N S F O R M AT I O N S

transformation is not trivial. A security pattern provides a
Not all parts of program transformations can be auto-
high-level description of a solution and the justiÞcation for
mated. But if a program transformation can be automated,
it. It does not describe all the implementation details, nor the
tools will make it easier for developers to apply them. Some
steps to transform a program to introduce the solution. For
program transformations can be completely automated, but
each candidate security pattern, we had identiÞed the im-
most are interactive and require some manual intervention.
plementation method and then described the transformation
IV. WH AT I S A SE C U R I T Y-O R I E N T E D PRO G R A M
A F E D ATA B U FF E R [22] describes a
steps. For example, S
T R A N S F O R M AT I O N ?
solution to prevent buffer overßow attacks. Buffer overßow
A program transformation is a function that maps pro-
occurs because an unsafe language such as C does not check
grams to programs. A security-oriented program transforma-
buffer bounds before performing a buffer operation. S
A F E
tion [12] maps programs to security-augmented programs,
D ATA B U FF E R pattern says that one should check for length
i.e., it introduces a protection mechanism to make programs
information before performing any operation on the data.
more secure.
The lessons from this pattern have been implemented by a
Figure 1 shows a schematic diagram of such a function.
number of safe string libraries (e.g., strlcat and strlcpy [34],
Figure 1 also raises several concerns. What are the inputs
libmib library [35], etc) and safe data types [36] [22]. This
of a security-oriented program transformation? What is the
transfor-
solution is captured as a
speciÞcation for a transformation? What type of change
transformation.
mation as well as a
is made by a security-oriented program transformation?
Þnds all instances of an unsafe
Finally, what does it mean to improve the security of the
library function in a program and replaces them with a safe
output programs? What are the tradeoffs?
replaceschar *
library function.
pointers with a safe data type that keeps length information.
In some cases, a pattern describes a high level solution, yet
the program transformation implements a concrete solution.
For example,R
transformation randomizes a
data variable in a program or the instruction set of a system.
I N E FI E L D [19] pattern.
This has been motivated by the M
Figure 1. Diagram of a Security-oriented Program Transformation
The pattern suggests that systems should be varied so that
each instance is different; therefore, some instances will be
Security-oriented program transformations
an input
resistant to an attack vector that compromises other instances
program, i.e., the input programs and the target programs are
of the same system. There is no general way to implement
of the same language. However, they include both source-
the pattern. The program transformations introduce concrete
to-source and binary-to-binary transformations.
solutions for varying a system to make it secure.

246246

S
a
f
e
L
i
b
r
a
r
y
R
e
p
l
a
c
e
m
e
n
t
S
a
f
e
T
y
p
e
R
e
p
l
a
c
e
m
e
n
t
S
a
f
e
L
i
b
r
a
r
y
R
e
p
l
a
c
e
m
e
n
t
S
a
f
e
T
y
p
e
R
e
p
l
a
c
e
m
e
n
t
a
n
d
o
m
i
z
a
t
i
o
n
I
n
p
u
t
s
o
f
a
S
e
c
u
r
i
t
y
-
o
r
i
e
n
t
e
d
P
r
o
g
r
a
m
T
r
a
n
s
f
o
r
m
a
t
i
o
n
:
r
e
p
h
r
a
s
e
developer should be able to apply the transformation on any
patch program that uses
Program transformations require user speciÞcation.
C program. Compare this to a
diff outputs to transform a program. It is designed to work
A user applying a refactoring transformation needs to specify
where to make the change, e.g., which variable to rename,
with a single version of a program. But security-oriented
which method to extract, etc. Even an automated transfor-
program transformations are more general.
mation such as compilation requires user speciÞcation in
The impact of change made by a security-oriented pro-
the form of makeÞles and build conÞgurations. Security-
gram transformation distinguishes them from refactorings.
oriented program transformations can be interactive similar
Security-oriented program transformations are not behavior-
to refactorings, or more automated similar to compilers.
preserving the way refactorings are. They Þx the incorrect
Nevertheless, they need some form of user speciÞcation.
behavior caused by a security vulnerability. At the same
To use a security-oriented program transformation, a
time, they preserve good path behavior, i.e., the behavior
developer has to follow three stepsÐ1) identify the program
of a system when it is used correctly.
points where to apply a transformation, 2) determine which
transformation to apply, and 3) use a tool to automatically
Adopting a single protection mechanism is
transform the program. The Þrst two tasks are manual: a
not enough; one must have defense in depth [32]. Security-
developer typically supplies these parameters to a program
oriented program transformations should be composable.
transformation with a manual speciÞcation. Consider a
Security is closely related with other quality attributes,
transformation that minimizes the number
e.g., performance, simplicity and maintainability. Many of
of entry points of a program. With minimal access points, the
the program transformations in our catalog add a new
necessary checks on inputs can be performed at fewer entry
component, e.g., a component for authentication, or a com-
points. But how does one minimize the number of entry
ponent for Þltering inputs. When applied indiscriminately,
points? Once all the entry points of a system are identiÞed,
a transformation can negatively affect the performance of
it is possible to merge entry points through a series of code
a program. On the other hand, if the insertion points of
edits and refactorings. However, it is hard to automate the
new components are decoupled from the other parts of
part of identifying all entry points. It is better if a developer
the program, the addition not only has minimal impact on
manually speciÞes the entry points. A developerÕs speciÞca-
performace, but also has the additional beneÞt of making
tion is thep
. The tools implement the
; they
the code more maintainable and understandable. We are
automatically execute structural changes.
assuming that the decoupling is done as a preparatory
step, probably by applying a transformation to partition the
A security-oriented program transfor-
program. The beneÞt, then, stems from the fact that the
mation makes structural changes (similar to refactorings),
decoupling improves the simplicity and understandability of
such as replacing method calls, composing classes, refactor-
architecture. Proper partitioning requires deep understand-
ing to patterns, distributing artifacts, etc. Structural change
ing of the architecture; programmers have to make these
also means that the corresponding tool does not need to
architectural decisions. No tools or transformations can take
have a deep understanding of the program behavior; a user
these decisions efÞciently (yet). Some transformations come
provides the speciÞcation and a transformation tool performs
with many tradeoffs, others, especially the code-level ones,
the mechanical change. A transformation makes the same
with few. Every security-oriented program transformation
changes that a developer has to make to secure a program,
documents these tradeoffs explicitly. Once the programmer
only it makes the changes systematically.
makes a decision, the transformation guides the programmer
Security-oriented program transformations are larger than
to make sure all steps are performed correctly.
typical refactorings. They can be compared to large refac-
V. EX A M P L E O F A P P LY I N G PRO G R A M
torings comprised of many steps. Some of these steps can
T R A N S F O R M AT I O N S
be supported by tools while other steps can be manual.
The change, made by a transformation, can be categorized
We will describe our experience in applying 2 program
by two issues: the scope of change and the impact of change.
transformations and how they removed real vulnerabilities.
The same program transformation may make different type
of changes in different contexts. For example, a
A S
transformation secures system
transformation for a C program splits a process so that
perimeter by minimizing the number of access points. We
each partitioned process runs in its own address space. On
applied the transformation to extract the access points in
transformation for a Java
the other hand, a
jftpd version 0.3, an FTP server written in Java. It has
program distributes objects so that they can live in separate
11 Java Þles with 2138 lines of code. We extracted the
virtual machines. The mechanism of a partitioning tool for
functions that interact with external users, and created a
a C program is different from that for a Java program.
gatekeeper component. The gatekeeper component runs in a
However, it should be general-purpose in the sense that a

247247

S
p
e
c
i
Þ
c
a
t
i
o
n
f
o
r
a
S
e
c
u
r
i
t
y
-
o
r
i
e
n
t
e
d
P
r
o
g
r
a
m
T
r
a
n
s
f
o
r
-
m
a
t
i
o
n
:
S
i
n
-
g
l
e
A
c
c
e
s
s
P
o
i
n
t
o
l
i
c
y
m
e
c
h
a
n
i
s
m
S
t
r
u
c
t
u
r
a
l
C
h
a
n
g
e
s
m
a
d
e
b
y
a
S
e
c
u
r
i
t
y
-
o
r
i
e
n
t
e
d
P
r
o
-
g
r
a
m
T
r
a
n
s
f
o
r
m
a
t
i
o
n
:
P
a
r
t
i
t
i
o
n
i
n
g
P
a
r
t
i
t
i
o
n
i
n
g
I
m
p
r
o
v
i
n
g
S
e
c
u
r
i
t
y
u
s
i
n
g
P
r
o
g
r
a
m
T
r
a
n
s
f
o
r
m
a
t
i
o
n
s
a
n
d
i
t
s
T
r
a
d
e
o
f
f
s
:
A
.
M
a
n
u
a
l
l
y
A
p
p
l
y
i
n
g
a
P
r
o
g
r
a
m
T
r
a
n
s
f
o
r
m
a
t
i
o
n
i
n
g
l
e
A
c
c
e
s
s
P
o
i
n
t
(2) ConvertedServerPI
separate virtual machine and communicates with the internal
class in the gatekeeper partition
component using RMI. We manually performed the steps
so that its local calls are replaced with RMI calls
inside Eclipse IDE; one can easily envision building an
described by the interface.
automated tool to perform these tasks.
(3) ConvertedServerPI
class in the processor partition so
Server , ServerPI
The program has 3 main classes:
that it implements the RMI interface. This can involve
and ServerDTP . Server class binds to a socket, and
adding a stub.
listens to client requests. When a request comes, it creates
[6] refac-
The Þrst step is an instance of
a ServerPI
thread.ServerPI
methodclientloop
toring. The second and third steps are not refactorings, but
parses incoming requests and processes them. It con-
they can be automated easily. In fact, Java RMI framework
handle_user .
tains several handler methods, e.g.,
automates tasks such as stub generation.
ServerDTP .
The handler methods call methods in
This transformation does not remove any particular vul-
ServerDTP processes the tasks, e.g.,
sendFile
method
nerability, but it improves the overall security because one
handle_retr
processes RETR command submitted by
,
can applyL
transformation to run the gate-
receiveFile
method processes STOR command submit-
keeper component with a different privilege level, or one
ted byhandle_stor
, etc. Figure 2 shows the classes.
can apply transformations to add policy enforcement point,
authentication component, authorization component, input
validation component. The next example describes a trans-
formation that removes well-known security vulnerabilities.

Figure 2. Main classes and methods of jftpd

A S
transformation replaces un-
safe library functions with safe alternatives. We have devel-
The extraction of the gatekeeper component is an instance
oped a tool in the Eclipse IDE to apply this transformation
of P
transformation. The most efÞcient parti-
strcpy andstrcat functions
to C programs. It replaces
tioning has to minimize inter-component communications.
withg_strlcpy
and g_strlcat
functions from the
For jftpd,Server and ServerDTP fall into separate
glib 2.0
library. The safe functions require an additional
partitions: suppose we call them gatekeeper partition and
length parameter, which the tool supplies.
ServerPI
processor partition correspondingly.
is split be-
We have applied our tool to two open source C pro-
tween the partitions. The parsing part is in the gatekeeper
grams [11]: a pdf/ps viewer (gv) and a zip library (zzi-
partition, while the handler methods are in the processor
plib). These programs have recent buffer overßow ex-
partition. Thus, the only inter-component communication
ploits [37] [38], and the exploit codes are available. Our
parser (clientloop ) remotely calling
is theServerPI
strcpy and
tool replaced 88 out of 107 instances of
ServerPI
handler method. Figure
(RMI) the appropriate
strcat functions in gv, and all 5 instances in zziplib. It
3 shows the resulting partition.
modiÞed 4 instances in the conÞguration Þles of gv, and 15
instances in the MakeÞles of zziplib; these changes included
the new library information so that the programs compiled.
We manually replaced the remaining instances of unsafe
functions in gv, but our tool can be improved to handle
these cases.
In both cases, the resultant programs did not have buffer
overßow vulnerability. They compiled correctly, and showed
We manually made the changes in two steps. In the
the same behavior. They passed all the test cases ran with
Þrst step, we created the partitions by creating a separate
themake test
command.
package namespace called gatekeeper and moved all the
We also applied our program transformation to large code
parts that would eventually be in the gatekeeper partition
bases, e.g. kerberos 5 kadmind 1.5.1. It contains 1045 C
in this package. Moving a class to a different package
programs with 369,442 lines of C code, 129 MakeÞles
is a refactoring, so is splitting a class (
[6]
containing 102,018 lines of code, and 11 conÞguration Þle
refactoring). Eclipse provides automated support for these.
containing 9718 lines of code. Our transformation modiÞed
ServerPI
Then we replaced the local calls in
in the
470 strcat and strcpy instances, 110 instances in MakeÞles
gatekeeper partition with RMI calls in three steps.
and 5 instances in the conÞguration Þles. 35 instances of
(1) Created an RMI interface describing the handler meth-
strcpy and 3 instances of strcat were not modiÞed. These
ods inServerPI
in the processor partition.
instances have complex patterns for the parameters.

Figure 3. Class diagram showing the partitions

248248

a
r
t
i
t
i
o
n
i
n
g
E
x
t
r
a
c
t
C
l
a
s
s
E
x
t
r
a
c
t
I
n
t
e
r
f
a
c
e
e
a
s
t
P
r
i
v
i
l
e
g
e
B
.
A
p
p
l
y
i
n
g
P
r
o
g
r
a
m
T
r
a
n
s
f
o
r
m
a
t
i
o
n
w
i
t
h
a
T
o
o
l
a
f
e
L
i
b
r
a
r
y
R
e
p
l
a
c
e
m
e
n
t
VI. PAT T E R N S T R A N S F O R M A R C H I T E C T U R E S
We analyzed the problem domain of security as our Þrst
step (in section III-A). We identiÞed the Þve most important
We have started from a security pattern catalog and
security problems. Our security-oriented program transfor-
identiÞed patterns that can be described as a program
mation catalog includes transformations for all classes of
transformation. Our approach sheds a new light on the
security problems: 10 for unvalidated input vulnerabilities,
usefulness of a security pattern, by promoting a pattern from
6 for broken authentication vulnerabilities, 7 for broken
a guideline for improving security to a concrete mechanism
access control vulnerabilities, 5 for improper error handling
of transforming architecture.
vulnerabilities, and 4 for Denial of Service vulnerabilities.
There are several threats to validity of this approach. Are
The remaining 5 program transformations in our catalog are
the program transformations really useful? Do they cover
Ôfundamental program transformationsÕ. These transforma-
important security problems? Are there too many transfor-
tions do not target any speciÞc vulnerabilities, but they make
mations to be useful? How hard is it to automate program
other vulnerabilities harder to exploit.
transformations that make large, architectural changes? This
section discusses these issues.

37 program transformations may be too many for people
to use. This large number is a result of our vulnerability-
Section V gives examples of some program transforma-
speciÞc approach to Þnding transformations. Perhaps if we
tions being applied. We have applied other transformations
considered them differently, we could describe our lessons
from our catalog, either manually or using proof-of-concept
in fewer transformations.
tools, and removed real vulnerabilities from real programs.
One alternative approach for deriving a program trans-
Some program transformations, e.g.,
, do
formation catalog could be a look at the general strategies
not remove a vulnerability; they make other vulnerabilities
of transforming programs. For example, many of our pro-
harder to exploit. We have described these transformations
gram transformations are examples of connector transfor-
and described how to create a tool to automate the steps.
mations [39], which deÞne types of architectural changes
that can be applied to connectors. Our transformations are
We have derived our program transformation catalog
examples ofd
(e.g.,D
) ora
by analyzing the problem domain and solution domain of
where new components are added (e.g.
security. However, instead of Þnding all possible security
). However, other transformations do
problems, we have restricted ourselves to the most important
andR
not Þt this classiÞcation.
require
security vulnerabilities, identiÞed by the vulnerability trend
making changes to many existing components.
reports. On the other hand, we have searched for security
means breaking up components, while
transforms
solutions in our security pattern catalog, that represents the
primarily the execution environment of a process so that it
collective experience of the security patterns community.
can run inside a constrained environment (a chroot jail). This
The pattern catalog is a summation of solutions described
classiÞcation does not help us, because applying security so-
by many researchers; it covers the solution space better than
lutions means crossing and breaking architectural boundaries
any arbitrary approach.
of components and connectors.
Our approach lies in the middle ground between two
Nevertheless, top-down categorization is prevalent in soft-
extreme approaches of deriving a catalog. One extreme is
ware architecture research. Fahmy and Holt [40] describe
building a catalog by arbitrarily listing a number of security
6 types of software architecture transformations. Ryoo et
solutions. While it is easy to adopt, the resulting catalog
al. [41] discuss the classiÞcation of security tactics, where
does not provide any conÞdence in terms of coverage: it
each tactic addresses a single architectural force; in their
may miss many important transformation opportunities. The
preliminary classiÞcation scheme only 10 tactics are listed.
closest analog of our program transformation catalog, the
We feel this is because the authors focus on deÞning
refactoring catalog [6], was built this way; the catalog was
distinct categories rather than on completeness. More types
later extended by other practitioners with new refactorings.
of transformations and tactics are likely to be identiÞed later.
On the other hand, the most rigorous way to build a catalog
Alternatively one can identify the smaller building blocks
of program transformations is to enumerate every possible
that comprise our transformations. Several program trans-
security problem and their solutions, build tools to imple-
formations in our catalog add a new component, e.g., an
ment candidate solutions as program transformations, allow
authentication enforcer component, an authorization en-
developers to use the tools and identify which transforma-
forcer component, a perimeter Þlter component, etc. Each
tions are more useful, and Þnally include them in the catalog.
transformation is distinct, because it creates a component
It is impossible for a researcher to follow this rigorous
by composing classes of a speciÞc security framework, or it
path; building tools and user testing each transformation in
creates a component according to a speciÞc template. Cata-
a catalog would take hundreds of person years.
loging them together, for instance as a Ôcompose framework

249249

A
.
D
o
T
r
a
n
s
f
o
r
m
a
t
i
o
n
s
S
e
c
u
r
e
A
p
p
l
i
c
a
t
i
o
n
s
?
S
i
n
g
l
e
A
c
c
e
s
s
P
o
i
n
t
B
.
D
o
T
r
a
n
s
f
o
r
m
a
t
i
o
n
s
C
o
v
e
r
I
m
p
o
r
t
a
n
t
S
e
c
u
r
i
t
y
P
r
o
b
l
e
m
s
?
C
.
W
h
y
S
o
M
a
n
y
T
r
a
n
s
f
o
r
m
a
t
i
o
n
s
?
a
t
a
t
r
a
n
s
l
a
t
i
o
n
e
c
o
r
a
t
e
d
F
i
l
t
e
r
d
d
r
e
d
i
r
e
c
t
M
e
s
s
a
g
e
I
n
t
e
r
c
e
p
t
i
n
g
G
a
t
e
w
a
y
F
u
z
z
i
n
g
a
n
d
o
m
i
z
a
t
i
o
n
P
a
r
t
i
t
i
o
n
i
n
g
c
h
r
o
o
t
j
a
i
l
Table IV
FE A S I B I L I T Y O FB U I L D I N G PRO G R A M T R A N S F O R M AT I O N TO O L S

can be automated. It is natural that the Þrst tools are the
ones that are the easiest to build. However, the importance
of these tools cannot be minimized, because they target
the most important security vulnerabilities. Input validation
vulnerabilities are the most prominent, especially buffer
overßow vulnerability, SQL injection vulnerability and cross
site scripting vulnerability. Our catalog lists 10 program
transformations to prevent input validation vulnerabilities,
e.g.,S
,S
etc.
These program transformations make small changes at each
program point, but the changes occur at many points. Tools
that make small, structural changes are easy to build, and
the frequency of the changes suggests that it can be tedious
for a human to make them consistently without tool support.
Table IV lists our program transformations based on
classÕ transformation, does not make them general-purpose
two criteria: how feasible is it to build tools for program
the way connector transformations are, because each of these
transformations, and how much effort is needed to apply
transformations applies to speciÞc security problems.
the solution manually? The top-left quadrant lists the largest
Some program transformations share common steps, but
number of program transformations, including the program
transfor-
their end goals are vastly different. A
transformations that prevent injection attacks. Most of these
mation distributes functionality among various components
program transformations make small, but numerous changes.
and modiÞes inter-component communication. Many of the
Some apparently difÞcult program transformations such as
same steps are applied in a
transforma-
and P
are also listed. We
tion, that distributes components to extract access points of
described how parts of these transformations can be au-
an application. The apparent similarity in their mechanisms
tomated by reusing refactoring tools and other remoting
is complicated by the goals of these two distributions, which
tools. AP
transformation Þrst distributes program
means the analysis and the implementation mechanism will
components and may create new components; developers
be different. Identifying the building blocks of all the trans-
can apply refactoring tools that extract classes, split classes
formations would result in an even larger catalog.
and move methods to introduce these changes step by step.
We have limited ourselves to only the most important
Developers have to determine a partitioning strategy before-
security vulnerabilities and explored corresponding security
hand; this step can be aided by architecture visualization
patterns. We eliminated similar or overlapping solutions
tools. Once the partitioning is done, some local method calls
while developing our pattern catalog. There has been a
are replaced by remote method calls. There are existing tools
conscious effort throughout the process to minimize the
that automate these steps to improve performance [42] [43].
number of program transformations and remove overlaps. 37
The top-right quadrant lists program transformations that
program transformations is not too much. By comparison,
are difÞcult to perform manually, and are difÞcult to au-
FowlerÕs catalog [6] contains 72 refactorings.
tomate. These program transformations introduce a lot of
Besides, describing program transformations in terms of
change. Making these changes requires a lot of behavioral
vulnerabilities makes it easy for application developers to
information. These program transformations are more in-
apply the transformations. Tool builders might prefer that
teractive than the ones in the top-left quadrant; developers
the catalog contains building blocks that are composed into
perform some steps manually and use automated tools to
security solutions. Here, we have taken an application devel-
perform some of the steps. Consider the
operÕs perspective. Our aim is to understand the feasibility
transformation that composes an authentication
of introducing security solutions as program transforma-
component using an existing framework. The default au-
tions; a domain speciÞc approach that explores security
thentication component must be customized by developers
vulnerabilities is more appropriate for this study. The tool
to Þt their application; this involves specifying authentication
buildersÕ perspective is a logical next step of implementing
type (username/password), source of user inputs, authenti-
the program transformations.
cation knowledge base (username/password store), and the
outcome of a successful authentication (which principals and
credentials are added to the subject), etc. Many of these steps
can be automated, but a lot of tasks must be done manually.
We have derived the program transformation catalog by
The bottom-left quadrant lists two program transforma-
including only those security patterns that can be automated.
tions that perform small changes in a few places. These
Yet, it is easy to build tools for some program transfor-
program transformations are easy to automate, but manually
mations; for a few others, only parts of the transformation

250250

P
a
r
t
i
t
i
o
n
i
n
g
S
i
n
g
l
e
A
c
c
e
s
s
P
o
i
n
t
D
.
C
a
n
S
e
c
u
r
i
t
y
P
a
t
t
e
r
n
s
B
e
c
o
m
e
A
u
t
o
m
a
t
e
d
P
r
o
g
r
a
m
T
r
a
n
s
f
o
r
m
a
t
i
o
n
s
?
a
f
e
L
i
b
r
a
r
y
R
e
p
l
a
c
e
m
e
n
t
a
f
e
T
y
p
e
R
e
p
l
a
c
e
m
e
n
t
S
i
n
g
l
e
A
c
c
e
s
s
P
o
i
n
t
a
r
t
i
t
i
o
n
i
n
g
a
r
t
i
t
i
o
n
i
n
g
A
d
d
A
u
t
h
e
n
t
i
c
a
t
i
o
n
E
n
f
o
r
c
e
r
. Microsoft Press, March

applying them are equally easy. Hence the tools may not be
[16] E. B. Fernandez and J. C. Sinibaldi, ÒMore patterns for operating
systems access control,Ó In Proceedings of the European Conference
very useful.
on Patterns Language of Programming (EuroPLoP Õ03), 2003.
The bottom-right quadrant contains one program trans-
[17] J. Hogg, D. Smith, F. Chong, D. Taylor, L. Wall, and P. Slater,
formation that is easy to perform manually, but is hard
) 3 .0
to automate.A
restricts authentication
2006.
[18] B. Blakley and C. Heath, ÒSecurity design patterns technical guideÐ
attempts to a few tries to prevent brute-force attacks against
Version 1,Ó Open Group(OG), Tech. Rep., 2004.
authentication tokens. The transformation may be as simple
[19] D. Kienzle, M. Elder, D. Tyree, and J. Edwards-Hewitt, ÒSecu-
as adding a for loop with a conditional clause. But Þnding
(cid:2) celer/
rity patterns repository version 1.0,Ó http://www.scrypt.net/
securitypatterns/repository.pdf, 2002.
where to insert the code is difÞcult if the authentication
[20] S. Romanosky, ÒSecurity design patterns part 1,Ó http://citeseer.ist.psu.
component is implemented arbitrarily. A tool for this trans-
edu/575199.html, Nov 2001.
formation is unnecessary because of the small change the
[21] S. Romanosky, ÒEnterprise security patterns,Ó 2002, http://citeseer.ist.
psu.edu/romanosky02enterprise.html.
transformation makes in very few points in a program.
[22] M. Ha Þz and R. Johnson, ÒEvolution of the MTA architecture: The
impact of security,Ó
, vol. 38,
VII. CO N C L U S I O N
no. 15, pp. 1569 Ð1599, Dec 2008.
[23] M. Ha Þz, ÒA collection of privacy design patterns,Ó In Proceed-
Security-oriented program transformations are a power
ings of the 13th Conference on Patterns Language of Programming
tool for securing existing software systems. They capture
(PLoP Õ06), 2006.
the expertise of security patterns in a methodical, structured
[24] D. Hybertson, J. Heaney, and A. Reedy, ÒConceptual aspects of
security patterns,Ó 2002.
form that makes them easier to apply to existing software.
[25] J. Heaney, D. Hybertson, A. Reedy, S.Chapin, T. Bollinger,
We have described the process of deriving security-oriented
D. Williams, and M. Kirwan Jr., ÒInformation assurance for enterprise
engineering,Ó In Proceedings of the 9th Conference on Patterns
program transformations to show that they are based on
Language of Programming (PLoP Õ02), 2002.
proven solutions, rather than experimental work. They can
[26] J. A. Zachman, ÒA framework for information systems architecture,Ó
, vol. 26, no. 3, 1987.
be used to remove the most pressing security vulnerabilities
[27] D. Trowbridge, W. Cunningham, M. Evans, L. Brader, and P. Slater,
from the code, while transforming its underlying architecture
ÒDescribing the enterprise architectural space,Ó
, June 2004.
to better prepare it for future threats.
[28] Open Web Application Security Project (OWASP), ÒAttacks,Ó http:
//www.owasp.org/index.php/Category:Attack, 2008.
R E F E R E N C E S
[29] US-CERT, ÒVulnerability notes by severity metric,Ó Apr 2008.
[1] E. Gamma, R. Helm, R. Johnson, and J. Vlissides,
Addison-Wesley, 1995.
[30] SANS Institute, ÒSANS top-20 2007 security risks (2007 annual
update),Ó November 2007.
[2] F. Buschmann, R. Meunier, H. Rohnert, P. Sommerlad, and M. Stal,
, ser.
[31] S. Christey and R. Martin, ÒVulnerability type distributions in CVE,
Wiley series in Software design patterns. John Wiley & Sons, 1996.
version 1.1,Ó http://cwe.mitre.org/documents/vuln- trends/index.html,
May 2007.
[3] K. Beck and R. E. Johnson, ÒPatterns generate architectures,Ó in
e 8 t
[32] J. Viega and G. McGraw,
94
, ser. Lecture Notes in Computer Science,
. Addison-Wesley, 2002.
M. Tokoro and R. Pareschi, Eds., vol. 821. Bologna, Italy: Springer,
[33] R. Veryard and A. Ward, ÒTrusting components and services,Ó
4 Ñ8 Jul. 1994, pp. 139 Ð149.
summary.php3?topicid=23&report=
http://cbdiforum.com/report
Oxford University
[4] C. Alexander,
rec=15, 2001.
411&order=author&start
Press, New York, 1977.
strlcpy andstrlcat
[34] T. Miller and T. de Raadt, Ò
1 9
[5] J. Kerievsky,
safe, string copy and concatenation,Ó in
, 1999.
[6] M. Fowler,R
Addison-Wesley, Jun 1999.
[35] F. Cavalier III, ÒLibmib allocated string functions,Ó http://www.
mibsoftware.com/libmib/astring/.
[7] M. HaÞz, P. Adamczyk, and R. E. Johnson, ÒOrganizing security
[36] A. Narayanan, ÒDesign of a safe string library for C,Ó
patterns,Ó
, vol. 24, no. 4, pp. 52 Ð60, July/August 2007.
, vol. 24, no. 6, pp. 565 Ð578, 1994.
[8] M. Schumacher, E. Fernandez-Buglioni, D. Hybertson, F. Buschmann,
and P. Sommerlad,S
[37] Bugtraq ID 20978, Ògv stack buffer over ßow vulnerability,Ó http://
www.securityfocus.com/bid/20978, 2006.
. John Wiley and Sons, December 2005.
[38] Bugtraq ID 23013, ÒzzipLib zzip
opensharedio stack buffer over-
[9] C. Steel, R. Nagappan, and R. Lai,
J2E
ßow vulnerability,Ó http://www.securityfocus.com/bid/23013, 2007.
. Prentice Hall PTR, Oct 2005.
[39] B. Spitznagel and D. Garlan, ÒA compositional approach for con-
Õ01 :
structing connectors,Ó in
[10] D. Garlan and M. Shaw, ÒAn introduction to software architecture,Ó
in A
,
. Washington, DC,
Singapore: World ScientiÞc
V. Ambriola and G. Tortora, Eds.
USA: IEEE Computer Society, 2001, p. 148.
Publishing Company, 1993, pp. 1 Ð39.
[40] H. Fahmy and R. C. Holt, ÒSoftware architecture transformations,Ó in
[11] M. HaÞz, P. Adamczyk, and R. Johnson, ÒSystematically eradicating
Õ00 )
data injection attacks using security-oriented program transforma-
, ser. ICSM Õ00. Washington, DC, USA: IEEE Computer
tions,Ó inP
Society, 2000, pp. 88 Ð.
-0 9
, Feb 2009.
[41] J. Ryoo, P. Laplante, and R. Kazman, ÒA methodology for mining
[12] M. HaÞz,S
. PhD thesis, Univ. of Illinois, 2010.
security tactics from security patterns,Ó
, 2010.
[13] J. Yoder and J. Barcalow, ÒArchitectural patterns for enabling appli-
[42] M. Tatsubori, T. Sasaki, S. Chiba, and K. Itano, ÒA bytecode translator
cation security.Ó In Proceedings of the 4th Conference on Patterns
Õ01:
for distributed execution of Òlegacy Ó Java software,Ó in
Language of Programming (PLoP Õ97)., 1997.
e 15t
[14] M. Schumacher and U. Roedig, ÒSecurity engineering with patterns.Ó
. London, UK: Springer-Verlag, 2001, pp. 236 Ð255.
In Proceedings of the 8th Conference on Patterns Language of
[43] E. Tilevich and Y. Smaragdakis, ÒJ-orchestra: Automatic Java ap-
Programming (PLoP Õ01)., 2001.
Õ02 :
e 16 t
plication partitioning,Ó in
[15] F. L. Brown Jr., J. DiVietri, G. D. Villegas, and E. B. Fernandez, ÒThe
authenticator pattern,Ó 1999.
UK: Springer-Verlag, 2002, pp. 178 Ð204.

. Addison Wesley, 2004.
.

Ñ Consistent,

.

London,

.

.

251
251

d
d
A
c
c
o
u
n
t
L
o
c
k
o
u
t
D
e
s
i
g
n
P
a
t
t
e
r
n
s
P
a
t
t
e
r
n
-
O
r
i
e
n
t
e
d
S
o
f
t
w
a
r
e
A
r
c
h
i
t
e
c
t
u
r
e
:
A
S
y
s
t
e
m
o
f
P
a
t
t
e
r
n
s
O
b
j
e
c
t
-
O
r
i
e
n
t
e
d
P
r
o
g
r
a
m
m
i
n
g
,
P
r
o
c
e
e
d
i
n
g
s
o
f
t
h
h
E
u
r
o
p
e
a
n
C
o
n
f
e
r
e
n
c
e
E
C
O
O
P
Õ
T
h
e
T
i
m
e
l
e
s
s
W
a
y
o
f
B
u
i
l
d
i
n
g
R
e
f
a
c
t
o
r
i
n
g
t
o
P
a
t
t
e
r
n
s
e
f
a
c
t
o
r
i
n
g
:
I
m
p
r
o
v
i
n
g
T
h
e
D
e
s
i
g
n
o
f
E
x
i
s
t
i
n
g
C
o
d
e
I
E
E
E
S
o
f
t
w
a
r
e
e
c
u
r
i
t
y
P
a
t
t
e
r
n
s
:
I
n
t
e
g
r
a
t
i
n
g
S
e
c
u
r
i
t
y
a
n
d
S
y
s
t
e
m
s
E
n
g
i
n
e
e
r
i
n
g
C
o
r
e
S
e
c
u
r
i
t
y
P
a
t
t
e
r
n
s
:
B
e
s
t
P
r
a
c
t
i
c
e
s
a
n
d
S
t
r
a
t
e
g
i
e
s
f
o
r
E
(
T
M
)
,
W
e
b
S
e
r
v
i
c
e
s
,
a
n
d
I
d
e
n
t
i
t
y
M
a
n
a
g
e
m
e
n
t
d
v
a
n
c
e
s
i
n
S
o
f
t
w
a
r
e
E
n
g
i
n
e
e
r
i
n
g
a
n
d
K
n
o
w
l
e
d
g
e
E
n
g
i
n
e
e
r
i
n
g
r
o
c
e
e
d
i
n
g
s
o
f
t
h
e
I
n
t
e
r
n
a
t
i
o
n
a
l
S
y
m
p
o
s
i
u
m
o
n
E
n
g
i
n
e
e
r
i
n
g
S
e
c
u
r
e
S
o
f
t
w
a
r
e
a
n
d
S
y
s
t
e
m
s
(
E
S
S
o
S
)
e
c
u
r
i
t
y
o
n
D
e
m
a
n
d
W
e
b
S
e
r
v
i
c
e
S
e
c
u
r
i
t
y
:
S
c
e
n
a
r
i
o
s
,
P
a
t
t
e
r
n
s
,
a
n
d
I
m
p
l
e
m
e
n
t
a
t
i
o
n
G
u
i
d
a
n
c
e
f
o
r
W
e
b
S
e
r
v
i
c
e
s
E
n
h
a
n
c
e
m
e
n
t
s
(
W
S
E
S
o
f
t
w
a
r
e
Ñ
P
r
a
c
t
i
c
e
a
n
d
E
x
p
e
r
i
e
n
c
e
I
B
M
S
y
s
t
e
m
s
J
o
u
r
n
a
l
M
S
D
N
B
u
i
l
d
i
n
g
S
e
c
u
r
e
S
o
f
t
w
a
r
e
:
H
o
w
t
o
A
v
o
i
d
S
e
c
u
r
i
t
y
P
r
o
b
l
e
m
s
T
h
e
R
i
g
h
t
W
a
y
9
9
U
s
e
n
i
x
A
n
n
u
a
l
T
e
c
h
n
i
c
a
l
C
o
n
f
e
r
e
n
c
e
,
M
o
n
t
e
r
e
y
,
C
a
l
i
f
o
r
n
i
a
,
U
S
A
S
o
f
t
w
a
r
e
Ñ
P
r
a
c
t
i
c
e
a
n
d
E
x
p
e
r
i
e
n
c
e
W
I
C
S
A
P
r
o
c
e
e
d
i
n
g
s
o
f
t
h
e
W
o
r
k
i
n
g
I
E
E
E
/
I
F
I
P
C
o
n
f
e
r
e
n
c
e
o
n
S
o
f
t
w
a
r
e
A
r
c
h
i
t
e
c
t
u
r
e
P
r
o
c
e
e
d
i
n
g
s
o
f
t
h
e
I
n
t
e
r
n
a
t
i
o
n
a
l
C
o
n
f
e
r
e
n
c
e
o
n
S
o
f
t
w
a
r
e
M
a
i
n
t
e
n
a
n
c
e
(
I
C
S
M
H
a
w
a
i
i
I
n
t
e
r
n
a
t
i
o
n
a
l
C
o
n
f
e
r
-
e
n
c
e
o
n
S
y
s
t
e
m
S
c
i
e
n
c
e
s
E
C
O
O
P
P
r
o
c
e
e
d
i
n
g
s
o
f
t
h
h
E
u
r
o
p
e
a
n
C
o
n
f
e
r
e
n
c
e
o
n
O
b
j
e
c
t
-
O
r
i
e
n
t
e
d
P
r
o
g
r
a
m
m
i
n
g
E
C
O
O
P
P
r
o
c
e
e
d
i
n
g
s
o
f
t
h
h
E
u
r
o
p
e
a
n
C
o
n
f
e
r
e
n
c
e
o
n
O
b
j
e
c
t
-
O
r
i
e
n
t
e
d
P
r
o
g
r
a
m
m
i
n
g
